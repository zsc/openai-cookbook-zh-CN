<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../../../">
    <title>1. 执行摘要</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">articles</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/how_to_work_with_large_language_models_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用大型语言模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/openai-harmony_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">OpenAI harmony 响应格式</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/related_resources_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">网上相关资源</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/run-nvidia_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 NVIDIA TensorRT-LLM 优化 OpenAI GPT-OSS 模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/techniques_to_improve_reliability_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">提高可靠性的技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/text_comparison_examples_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">文本比较示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="articles/what_makes_documentation_good_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">什么样的文档是好文档</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">gpt-oss</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/fine-tune-transfomers_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">微调多语言推理器，使用 Hugging Face</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/handle-raw-cot_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">gpt-oss 中如何处理原始思维链</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/run-colab_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/run-locally-lmstudio_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何在本地使用 LM Studio 运行 gpt-oss</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/run-locally-ollama_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何在本地运行 gpt-oss 并使用 Ollama</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/run-transformers_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 Hugging Face Transformers 运行 gpt-oss</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="articles/gpt-oss/run-vllm_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 vLLM 运行 gpt-oss</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder expanded" data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">examples</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Assistants_API_overview_python_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Assistants API 概述 (Python SDK)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/batch_processing_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">批量处理与 Batch API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Chat_finetuning_data_prep_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">数据准备与分析，用于聊天模型微调</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Classification_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">split data into train and test</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Clustering_for_transaction_classification_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">交易分类聚类</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Clustering_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">导入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Code_search_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">数据加载</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/completions_usage_api_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">OpenAI Completions 使用 API 扩展示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Context_summarization_with_realtime_api_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">摘要 — 实时 API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Creating_slides_with_Assistants_API_and_DALL-E3_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Assistants API (GPT-4) 和 DALL·E-3 创建幻灯片</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Custom-LLM-as-a-Judge_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Braintrust 构建 LLM-as-a-judge 评估来检测幻觉</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/custom_image_embedding_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">安装</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Customizing_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">0. 导入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Data-intensive-Realtime-apps_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">实用指南：使用实时 API 处理数据密集型应用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Data_extraction_transformation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Developing_hallucination_guardrails_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">设置 pandas 显示选项的函数</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Embedding_long_inputs_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Embedding 长度超过模型最大上下文的文本</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Embedding_Wikipedia_articles_for_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">嵌入维基百科文章以供搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Enhance_your_prompts_with_meta_prompting_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">元提示：自动化提示优化指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Entity_extraction_for_long_documents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">长文档内容提取</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/File_Search_Responses_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用文件搜索工具的响应 API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Fine-tuned_classification_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">示例：微调分类器</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Fine_tuning_for_function_calling_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Function_calling_finding_nearby_places_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">函数调用，查找附近地点：利用谷歌地图 API 和客户档案</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Function_calling_with_an_OpenAPI_spec_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Function-calling with an OpenAPI specification</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Generate_Images_With_GPT_Image_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 GPT Image 生成和编辑图像</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Generate_Images_With_High_Input_Fidelity_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">以高输入保真度生成图像</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Get_embeddings_from_dataset_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">从数据集中获取嵌入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/gpt4-1_prompting_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT-4.1 提示指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_build_a_tool-using_agent_with_Langchain_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 LangChain 构建一个使用工具的 Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_call_functions_for_knowledge_retrieval_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用具有知识库的函数</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_call_functions_with_chat_models_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何结合聊天模型调用函数</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_combine_GPT4o_with_RAG_Outfit_Assistant_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何结合 GPT-4o Mini 与 RAG - 创建服装搭配应用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_count_tokens_with_tiktoken_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 tiktoken 计算 token 数量</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_finetune_chat_models_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何微调聊天模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_format_inputs_to_ChatGPT_models_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何为 ChatGPT 模型格式化输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_handle_rate_limits_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何处理速率限制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_stream_completions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何流式传输补全</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_use_guardrails_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用护栏</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/How_to_use_moderation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用审核 API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Leveraging_model_distillation_to_fine-tune_a_model_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">利用模型蒸馏微调模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Multiclass_classification_for_transactions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">多类别交易分类</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Named_Entity_Recognition_to_enrich_text_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">naively consider the first result as the best</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Optimize_Prompts_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">优化提示词</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Orchestrating_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">代理编排：例程和交接</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Prompt_Caching101_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">提示缓存入门</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Prompt_migration_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Question_answering_using_a_search_API_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Question_answering_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用基于嵌入的搜索来回答问题</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/RAG_with_graph_db_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">检索增强生成与图数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/reasoning_function_calls_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用推理模型管理函数调用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Recommendation_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用嵌入和最近邻搜索进行推荐</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Regression_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Reinforcement_Fine_Tuning_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">**探索用于强化微调的模型评分器**</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Reproducible_outputs_with_the_seed_parameter_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何通过新的 seed 参数使您的 completions 输出可复现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/SDG1_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">生成合成数据（第一部分）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Search_reranking_with_cross-encoders_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">搜索重排与交叉编码器</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Semantic_text_search_using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">搜索特定产品的评论</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Speech_transcription_methods_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">🗣️ 说话转文本方法与 OpenAI API 的比较</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Structured_Outputs_Intro_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">结构化输出简介</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Structured_outputs_multi_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">结构化输出用于多代理系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Summarizing_long_documents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">总结长文档</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Tag_caption_images_with_GPT4V_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 GPT-4o mini 标记和说明图片</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Unit_test_writing_using_a_multi-step_prompt_with_older_completions_API_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">单元测试编写：多步提示（使用旧版 API）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Unit_test_writing_using_a_multi-step_prompt_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">多步提示单元测试</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/User_and_product_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">将嵌入作为推荐项在 X_test 上进行评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Using_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">负面示例（速度慢且有速率限制）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Using_logprobs_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 logprobs 进行分类和问答评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Using_tool_required_for_customer_service_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用工具处理客户服务</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Visualizing_embeddings_in_2D_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">加载嵌入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Visualizing_embeddings_in_3D_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">三维可视化嵌入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Whisper_correct_misspelling_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">imports</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Whisper_processing_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Whisper_prompting_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">提示词指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="examples/Zero-shot_classification_with_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">convert 5-star rating to binary sentiment</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">agents_sdk</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/agents_sdk/dispute_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">引言</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/agents_sdk/evaluate_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Langfuse 评估代理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/agents_sdk/parallel_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">并行运行OpenAI Agents SDK的专用代理</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">multi-agent-portfolio-collaboration</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/multi_agent_portfolio_collaboration_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">多智能体编排与OpenAI Agents SDK：金融投资组合分析示例</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">prompts</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/code_interpreter_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">代码解释器提示（最佳实践，GPT-4.1）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/editor_base_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">备忘录编辑器 – 提示</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/fundamental_base_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">首席基本面分析师 – 提示</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/macro_base_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/pm_base_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">投资组合经理 – 系统提示</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/quant_base_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">定量研究员 – 提示</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/agents_sdk/multi-agent-portfolio-collaboration/prompts/tool_retry_prompt_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">工具调用重试说明</span>
                        </a>
                    </div>
                </div></div></div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">azure</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/azure/chat_with_your_own_data_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure chat completion models with your own data (preview)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/azure/chat_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 聊天补全示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/azure/embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 嵌入示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/azure/functions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 函数示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/azure/whisper_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 音频耳语（预览）示例</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">archive</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/chat_with_your_own_data_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure OpenAI on your own data is only supported by the 2023-08-01-preview API version</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/chat_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 聊天补全示例 (预览)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/completions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure completions 示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/DALL-E_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure DALL·E 图像生成示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 嵌入示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/functions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 函数示例</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/azure/archive/whisper_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure 音频耳语（预览）示例</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">book_translation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/book_translation/translate_latex_book_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">翻译一本用LaTeX写成的斯洛文尼亚语书籍成英语</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">chatgpt</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">gpt_actions_library</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/.gpt_action_getting_started_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT Action 库：入门指南 (Weather.gov)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_bigquery_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT Action 库：BigQuery</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_box_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Box</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_canvas_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Canvas LMS 食谱</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_confluence_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Confluence</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_github_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：GitHub</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_gmail_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Gmail</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_google_calendar_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Google 日历</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_google_drive_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">**GPT 操作库：Google 云端硬盘**</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_googleads_adzviser_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库 - 通过 Adzviser 连接 Google Ads</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_jira_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Jira</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_notion_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT Action 库：Notion</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_outlook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Outlook</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_redshift_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：AWS RedShift</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_retool_workflow_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Retool 工作流</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_salesforce_gong_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Salesforce + Gong</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_salesforce_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Sharepoint (返回文件以供数据分析/文档摘要)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Sharepoint (以文档形式返回)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_snowflake_direct_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT Actions - Snowflake 直接连接</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_snowflake_middleware_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作 - Snowflake 中间件</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_sql_database_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：SQL 数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_trayai_apim_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Tray.ai API 管理操作</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_workday_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">**Workday GPT 操作手册**</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_action_zapier_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库：Zapier</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_middleware_aws_function_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT Action 库（中间件）：AWS Lambda</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库（中间件）：Azure Function</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/gpt_actions_library/gpt_middleware_google_cloud_function_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT 操作库（中间件）：Google Cloud Function</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">rag-quickstart</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">azure</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/chatgpt/rag-quickstart/azure/Azure_AI_Search_with_Azure_Functions_and_GPT_Actions_in_ChatGPT_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">架构</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">gcp</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/chatgpt/rag-quickstart/gcp/Getting_started_with_bigquery_vector_search_and_openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GCP BigQuery 与 GCP Functions 和 ChatGPT 中的 GPT 操作</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">pinecone-retool</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/chatgpt/rag-quickstart/pinecone-retool/gpt-action-pinecone-retool-rag_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">sharepoint_azure_function</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/chatgpt/sharepoint_azure_function/Using_Azure_Functions_and_Microsoft_Graph_to_Query_SharePoint_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Azure Functions 结合 OAuth 和 Microsoft Graph API 从 ChatGPT 搜索 O365 / SharePoint</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">codex</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/codex/jira-github_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 `codex-cli` 自动化 Jira ↔ GitHub</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">dalle</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/dalle/How_to_create_dynamic_masks_with_DALL-E_and_Segment_Anything_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 DALL·E 和 Segment Anything 创建动态蒙版</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/dalle/Image_generations_edits_and_variations_with_DALL-E_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 DALL·E API</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">data</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">structured_outputs_articles</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/data/structured_outputs_articles/cnns_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/data/structured_outputs_articles/llms_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/data/structured_outputs_articles/moe_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">deep_research_api</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/deep_research_api/introduction_to_deep_research_api_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">深度研究代理食谱</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/deep_research_api/introduction_to_deep_research_api_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Deep Research API 入门</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">how_to_build_a_deep_research_mcp_server</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/deep_research_api/how_to_build_a_deep_research_mcp_server/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">深度研究的 MCP</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">evaluation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/evaluation/Evaluate_RAG_with_LlamaIndex_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 LlamaIndex 构建和评估 RAG</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/evaluation/Getting_Started_with_OpenAI_Evals_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 OpenAI Evals 入门</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/evaluation/How_to_eval_abstractive_summarization_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何评估摘要任务</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/evaluation/How_to_evaluate_LLMs_for_SQL_generation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何为 SQL 生成测试和评估 LLM</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">use-cases</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/bulk-experimentation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">设置您的评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/completion-monitoring_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">生成我们的测试数据</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/EvalsAPI_Image_Inputs_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Evals API：图像输入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/mcp_eval_notebook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用自定义数据集评估基于 MCP 的答案</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/regression_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">设置你的评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/responses-evaluation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">评估现有响应的新模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/structured-outputs-evaluation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">结构化输出评估食谱</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/tools-evaluation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 OpenAI Evals 进行工具评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/evaluation/use-cases/web-search-evaluation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用自定义数据集评估网络搜索质量</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">fine-tuned_qa</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/fine-tuned_qa/ft_retrieval_augmented_generation_qdrant_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Qdrant 和少样本学习对 OpenAI 模型进行检索增强生成 (RAG) 微调</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/fine-tuned_qa/olympics-1-collect-data_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">1. 收集关于 2020 年奥运会的维基百科数据</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/fine-tuned_qa/olympics-2-create-qa_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">2. 创建合成问答数据集</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/fine-tuned_qa/olympics-3-train-qa_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">3. 训练专门用于问答的微调模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/fine-tuned_qa/reinforcement_finetuning_healthbench_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 OpenAI API 进行对话推理的强化微调</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">gpt-5</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/gpt-5/gpt-5_frontend_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT-5 驱动的前端开发</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/gpt-5/gpt-5_new_params_and_tools_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT-5 新参数和工具</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/gpt-5/gpt-5_prompting_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT-5 提示指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/gpt-5/prompt-optimization-cookbook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">GPT-5 提示迁移与改进：使用新的提示优化器</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">mcp</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/mcp/databricks_mcp_cookbook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用OpenAI Agent SDK和Databricks MCP服务器构建供应链Copilot</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/mcp/mcp_tool_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">指南：使用响应式API的MCP工具</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">building-a-supply-chain-copilot-with-agent-sdk-and-databricks-mcp</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/mcp/building-a-supply-chain-copilot-with-agent-sdk-and-databricks-mcp/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Databricks MCP 助手（含 React UI）</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">ui</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/mcp/building-a-supply-chain-copilot-with-agent-sdk-and-databricks-mcp/ui/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">React + Vite</span>
                        </a>
                    </div>
                </div></div></div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">multimodal</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/multimodal/image_understanding_with_rag_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Download the dataset</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/multimodal/Using_GPT4_Vision_With_Function_Calling_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用具有函数调用的 GPT-4o Vision</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/multimodal/Vision_Fine_tuning_on_GPT4o_for_Visual_Question_Answering_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">加载数据集</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">o-series</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/o-series/o3o4-mini_prompting_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">o3/o4-mini 函数调用指南</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">o1</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/o1/Using_chained_calls_for_o1_structured_outputs_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">提示</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/o1/Using_reasoning_for_data_validation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Generate data three times using the existing dataGeneration function</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/o1/Using_reasoning_for_routine_generation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Set display options to show all text in the dataframe cells</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">object_oriented_agentic_approach</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/object_oriented_agentic_approach/Secure_code_interpreter_tool_for_LLM_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Run the container in restricted mode. The container will run in the background.</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder expanded" data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">partners</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">eval_driven_system_design</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/partners/eval_driven_system_design/receipt_inspection_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">评估驱动的系统设计：从原型到生产</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">model_selection_guide</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/partners/model_selection_guide/model_selection_guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">实用模型选择指南，面向真实用例</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder expanded" data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">temporal_agents_with_knowledge_graphs</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/partners/temporal_agents_with_knowledge_graphs/Appendix_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">A. 原型到生产</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" style="padding-left: 60px;">
                        <a href="examples/partners/temporal_agents_with_knowledge_graphs/temporal_agents_with_knowledge_graphs_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">1. 执行摘要</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">responses_api</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/responses_api/reasoning_items_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">调用函数</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/responses_api/responses_api_tool_orchestration_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/responses_api/responses_example_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Display the image from the provided URL</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">stripe_model_eval</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/stripe_model_eval/selecting_a_model_based_on_stripe_conversion_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">根据 Stripe 转化率选择模型：初创公司的实用评估</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">third_party</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Code_quality_and_security_scan_with_GitHub_Actions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Reasoning over Code Quality and Security in GitHub Pull Requests</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/financial_document_analysis_with_llamaindex_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">金融文档分析与 LlamaIndex</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/How_to_automate_S3_storage_with_functions_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用函数自动化任务（S3 存储桶示例）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Openai_monitoring_with_wandb_weave_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 W&B Weave 进行 OpenAI API 监控</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Visualizing_embeddings_in_Kangas_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Column                Non-Null Count DataGrid Type</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Visualizing_embeddings_in_wandb_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">加载嵌入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Visualizing_embeddings_with_Atlas_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">加载嵌入</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/third_party/Web_search_with_google_api_bring_your_own_browser_tool_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Check if 'items' exists in the results</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">vector_databases</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/vector_databases/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">PolarDB</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/PolarDB/Getting_started_with_PolarDB_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 PolarDB-PG 作为 OpenAI 嵌入的向量数据库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">SingleStoreDB</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/SingleStoreDB/OpenAI_wikipedia_semantic_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">简介</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/SingleStoreDB/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">analyticdb</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/analyticdb/Getting_started_with_AnalyticDB_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 AnalyticDB 作为 OpenAI 嵌入的向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/analyticdb/QA_with_Langchain_AnalyticDB_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">问答系统：Langchain、AnalyticDB 和 OpenAI</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">azuresearch</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/azuresearch/Getting_started_with_azure_ai_search_and_openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Azure AI Search 作为 OpenAI 嵌入的向量数据库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">cassandra_astradb</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/cassandra_astradb/Philosophical_Quotes_AstraPy_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">哲学与向量嵌入、OpenAI 和 Astra DB</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/cassandra_astradb/Philosophical_Quotes_cassIO_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Philosophy with Vector Embeddings, OpenAI and Cassandra / Astra DB through CQL</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/cassandra_astradb/Philosophical_Quotes_CQL_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">哲学与向量嵌入、OpenAI 和 Cassandra / Astra DB</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/cassandra_astradb/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">RAG 与 Astra DB 和 Cassandra</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">chroma</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/chroma/hyde-with-chroma-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">鲁棒问答系统：结合 Chroma 和 OpenAI</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/chroma/Using_Chroma_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Chroma 进行嵌入搜索</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">deeplake</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/deeplake/deeplake_langchain_qa_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 LangChain、Deep Lake 和 OpenAI 进行问答</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">elasticsearch</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/elasticsearch/elasticsearch-retrieval-augmented-generation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">检索增强生成，使用 Elasticsearch 和 OpenAI</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/elasticsearch/elasticsearch-semantic-search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Elasticsearch 和 OpenAI 进行语义搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/elasticsearch/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Elasticsearch</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">hologres</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/hologres/Getting_started_with_Hologres_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用Hologres作为OpenAI嵌入的向量数据库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">kusto</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/kusto/Getting_started_with_kusto_and_openai_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">文件大约为 700 MB，因此这需要一些时间</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/kusto/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Kusto 作为向量数据库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">milvus</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/milvus/Filtered_search_with_Milvus_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Milvus 和 OpenAI 进行过滤搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/milvus/Getting_started_with_Milvus_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Milvus 和 OpenAI 入门指南</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">mongodb_atlas</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/mongodb_atlas/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">MongoDB Atlas 向量搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/mongodb_atlas/semantic_search_using_mongodb_atlas_vector_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 步：设置环境</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">myscale</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/myscale/Getting_started_with_MyScale_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 MyScale 作为 OpenAI 嵌入的向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/myscale/Using_MyScale_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 MyScale 进行嵌入搜索</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">neon</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/neon/neon-postgres-vector-search-pgvector_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Neon Postgres 向量相似性搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/neon/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">什么是 Neon？</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">pinecone</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/Gen_QA_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Pinecone 进行检索增强生成问答</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/GPT4_Retrieval_Augmentation_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">create the length function</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Pinecone 向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/Semantic_Search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">我们可以将嵌入提取到一个列表中</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/Using_Pinecone_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Pinecone 进行嵌入搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/pinecone/Using_vision_modality_for_RAG_with_Pinecone_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">导入Pinecone库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">qdrant</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/qdrant/Getting_started_with_Qdrant_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Qdrant 作为 OpenAI embedding 的向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/qdrant/QA_with_Langchain_Qdrant_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Langchain、Qdrant 和 OpenAI 的问答系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/qdrant/Using_Qdrant_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Qdrant 进行嵌入搜索</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">redis</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/redis/getting-started-with-redis-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Redis 和 OpenAI 作为向量数据库</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/redis/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Redis</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/redis/redis-hybrid-query-examples_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Redis 和 OpenAI 运行混合 VSS 查询</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/redis/Using_Redis_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Redis 进行嵌入搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">redisjson</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/vector_databases/redis/redisjson/redisjson_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Redis Vectors as JSON with OpenAI</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="3" style="padding-left: 60px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">redisqna</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 80px;">
                        <a href="examples/vector_databases/redis/redisqna/redisqna_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Redis 作为上下文存储与 OpenAI Chat</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">supabase</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/supabase/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Supabase 向量数据库</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">tair</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/tair/Getting_started_with_Tair_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Tair作为OpenAI嵌入的向量数据库使用指南</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/tair/QA_with_Langchain_Tair_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Langchain、Tair 和 OpenAI 进行问答</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">typesense</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/typesense/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Typesense</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/typesense/Using_Typesense_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Typesense 进行嵌入搜索</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">weaviate</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/generative-search-with-weaviate-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">导出 OpenAI API 密钥</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/getting-started-with-weaviate-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">安装 Weaviate Python 客户端</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/hybrid-search-with-weaviate-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">安装用于 Python 的 Weaviate 客户端</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/question-answering-with-weaviate-and-openai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">在 Weaviate 中使用 OpenAI Q&A 模块进行问答</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Weaviate <> OpenAI</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/weaviate/Using_Weaviate_for_embeddings_search_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Weaviate 进行嵌入搜索</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">zilliz</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/zilliz/Filtered_search_with_Zilliz_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Zilliz和OpenAI的过滤搜索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/vector_databases/zilliz/Getting_started_with_Zilliz_and_OpenAI_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Zilliz 和 OpenAI 入门指南</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">voice_solutions</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/voice_solutions/running_realtime_api_speech_on_esp32_arduino_edge_runtime_elatoai_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">在 .env.local 中设置您的环境变量</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/voice_solutions/steering_tts_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="examples/voice_solutions/voice_translation_into_different_languages_using_GPT-4o_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">确保已安装 requests 包</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">one_way_translation_using_realtime_api</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="examples/voice_solutions/one_way_translation_using_realtime_api/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Translation Demo</span>
                        </a>
                    </div>
                </div></div></div></div></div></div></nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="1">1. 执行摘要</h1>
<hr />
<h2 id="11">1.1. 目的和受众</h2>
<p>本手册提供了一个关于构建<strong>时间感知知识图谱</strong>和执行<strong>直接在这些图谱上进行多跳检索</strong>的实践指南。</p>
<p>它面向工程师、架构师和分析师，他们从事时间感知知识图谱的工作。无论您是在进行原型设计、大规模部署，还是探索使用结构化数据的新方法，您都将找到实用的工作流程、最佳实践和决策框架来加速您的工作。</p>
<p>本手册介绍了两个您可以立即使用、扩展和部署的实践工作流程：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>时间感知知识图谱 (KG) 构建</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      开发知识驱动的 AI 系统的关键挑战是维护一个保持最新和相关的数据库。虽然许多注意力都集中在通过语义相似性和重新排序等技术来提高检索准确性，但本指南侧重于一个基本但经常被忽视的方面：<em>系统地更新和验证您的知识库，以应对新数据的到来</em>。
    </p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      无论您的检索算法多么先进，其有效性都受到数据库质量和新鲜度的限制。本手册演示了如何在有新数据到达时例行验证和更新知识图谱条目，以确保您的知识库保持准确和最新。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>使用知识图谱进行多跳检索</strong><br />
<p style="margin-top: 0.5em; margin-bottom: 0.5em;">
  了解如何将 OpenAI 模型（如 o3、o4-mini、GPT-4.1 和 GPT-4.1-mini）与通过工具调用进行的结构化图查询相结合，使模型能够跨实体和关系在多个步骤中遍历您的图谱。
</p>
<p style="margin-top: 0.5em; margin-bottom: 0.5em;">
  这种方法允许您的系统回答需要对多个链接事实进行推理的复杂、多方面的问题，远远超出了单跳检索所能达到的范围。
</p>
  </li>
</ol>

<p>在内部，您将发现：</p>
<ul>
<li><strong>实用的决策框架</strong>，用于在每个阶段选择模型和提示技术</li>
<li><strong>即插即用代码示例</strong>，可轻松集成到您的 ML 和数据管道中</li>
<li><strong>指向深入资源的链接</strong>，涵盖 OpenAI 工具使用、微调、图后端选择等</li>
<li><strong>从原型到生产的清晰路径</strong>，包含有关扩展和可靠性的可操作最佳实践</li>
</ul>
<blockquote>
<p><strong>注意</strong>：所有基准测试和建议均基于截至 2025 年 6 月的最佳可用模型和实践。随着生态系统的发展，请定期重新审视您的方法，以跟上新功能和改进的步伐。</p>
</blockquote>
<h2 id="12">1.2. 主要收获</h2>
<h3 id="_1">使用时间代理创建时间感知知识图谱</h3>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>为什么让您的知识图谱具有时间性？</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
     传统的知识图谱将事实视为静态的，但现实世界的信息在不断演变。上个季度正确的事情今天可能已经过时，如果图谱没有捕捉到随时间发生的变化，就会带来错误或误导性决策的风险。时间知识图谱允许您精确地回答“给定日期时什么才是正确的？”之类的问题，或分析事实和关系如何变化，确保决策始终基于最相关的上下文。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>什么是时间代理？</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      时间代理是一个管道组件，它接收原始数据并为您的知识图谱生成带时间戳的三元组。这使得精确的时间查询、时间线构建、趋势分析等成为可能。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>管道如何工作？</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      管道首先对原始文档进行语义分块。这些块被分解为供时间代理使用的语句，然后时间代理创建时间感知三元组。然后，无效代理可以执行时间有效性检查，发现并处理图谱中因新语句而无效的任何语句。
    </p>
  </li>
</ol>

<h3 id="_2">使用知识图谱进行多跳检索</h3>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>为什么使用多跳检索？</strong><br />
<p style="margin-top: 0.5em; margin-bottom: 0.5em;">
  直接的单跳查询经常会错过分布在图谱拓扑结构中的重要事实。多跳检索允许迭代遍历，沿着关系进行，并在多个跳之间聚合证据。这种方法可以揭示隐藏在单次查找中的复杂依赖关系和潜在连接，从而为复杂的查询提供更全面、更细致的答案。
</p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>规划器</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      规划器协调检索过程。<em>面向任务的</em>规划器将查询分解为具体的、顺序的子任务。相比之下，<em>面向假设的</em>规划器则提出要确认、反驳或演变的声明。选择最佳策略取决于问题在确定性报告（定义明确的路径）到探索性研究（开放式推理）的范围内的位置。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>工具设计范式</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      工具设计跨越一个连续体：<em>固定工具</em>为特定查询提供一致、可预测的输出（例如，一个始终为旧金山返回当日天气的服务）。在另一端，<em>自由格式工具</em>提供广泛的灵活性，例如代码执行或开放式数据检索。<em>半结构化工具</em>介于两者之间，限制某些操作，同时允许定制灵活性——专门的子代理是典型的例子。选择合适的范式是在控制、适应性和复杂性之间进行权衡。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>评估检索系统</strong><br />
<p style="margin-top: 0.5em; margin-bottom: 0.5em;">
  高保真评估依赖于专家策划的“黄金”答案，尽管这些答案成本高昂且劳动密集。可以快速生成自动判断，例如来自 LLM 或工具跟踪的判断，以补充或预筛选，但可能缺乏人类评估的精度。随着您的系统成熟，请转向利用真实用户反馈来衡量和优化生产中的检索质量。
</p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      一个经过验证的工作流程：从合成测试开始，在您策划的人工注释的“黄金”数据集上进行基准测试，并使用实时用户反馈和评分进行迭代优化。
    </p>
  </li>
</ol>

<h3 id="_3">原型到生产</h3>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>保持图谱精简</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      建立归档策略，并为每个边分配数字相关性分数（例如，时效性 x 信任度 x 查询频率）。自动归档或稀疏化低价值节点和边，确保只有最关键和最常访问的事实保留下来以供快速检索。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>并行化摄取管道</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      从线性文档 → 分块 → 提取 → 解析管道过渡到分阶段、异步架构。为每个处理阶段分配自己的队列和专用工作池。为无效作业应用聚类或基于网络的批处理，以最大化效率。尽可能将外部 API 请求（例如 OpenAI）和数据库写入进行批处理。这种设计提高了吞吐量，引入了用于可靠性的反压，并允许您独立扩展每个管道阶段。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>集成强大的生产安全措施</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      强制执行严格的输出验证：标准化时间字段（例如，ISO-8601 日期格式），将实体类型限制在您的受控词汇表中，并应用轻量级的基于模型的健全性检查以获得输出一致性。使用具有可追溯标识符的结构化日志记录，并实时监控实时质量和性能指标，以主动检测数据漂移、回归或管道异常，然后再影响下游应用程序。
    </p>
  </li>
</ol>

<h1 id="2">2. 如何使用本手册</h1>
<hr />
<p>本手册旨在灵活参与：</p>
<ol>
<li>将其用作全面的技术指南——从头到尾阅读，以深入了解时间感知知识图谱系统。</li>
<li>如果您倾向于高层次概述，请浏览以获取高级概念、方法论和实现模式。</li>
<li>跳转到三个模块化部分中的任何一个；每个部分都是独立的，并且直接适用于实际场景。</li>
</ol>
<p>在内部，您会发现：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>使用时间代理创建时间感知知识图谱</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      构建一个管道，该管道从非结构化文本中提取实体和关系，解析时间冲突，并在新信息到达时保持图谱的最新状态。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>使用知识图谱进行多跳检索</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用结构化查询和语言模型推理来链接图谱中的多个跳，以回答复杂问题。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>原型到生产</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      从实验转向部署。本节涵盖了架构技巧、集成模式以及可靠扩展的注意事项。
    </p>
  </li>
</ol>

<h2 id="21">2.1. 先决条件</h2>
<p>在深入构建时间代理和知识图谱之前，让我们设置您的环境。使用 pip 安装所有必需的依赖项，并将您的 OpenAI API 密钥设置为环境变量。需要 Python 3.12 或更高版本。</p>
<pre class="codehilite"><code class="language-python">!python -V
%pip install --upgrade pip
%pip install -qU chonkie datetime ipykernel jinja2 matplotlib networkx numpy openai plotly pydantic rapidfuzz scipy tenacity tiktoken pandas
%pip install -q &quot;datasets&lt;3.0&quot;
</code></pre>

<pre class="codehilite"><code>Python 3.12.8
Requirement already satisfied: pip in ./.venv/lib/python3.12/site-packages (25.1.1)
Note: you may need to restart the kernel to use updated packages.
Note: you may need to restart the kernel to use updated packages.
Note: you may need to restart the kernel to use updated packages.
</code></pre>

<pre class="codehilite"><code class="language-python">import os

if &quot;OPENAI_API_KEY&quot; not in os.environ:
    import getpass
    os.environ[&quot;OPENAI_API_KEY&quot;] = getpass.getpass(&quot;Paste your OpenAI API key here: &quot;)
</code></pre>

<h1 id="3">3. 使用时间代理创建时间感知知识图谱</h1>
<hr />
<p><strong>准确的数据是任何良好业务决策的基础。</strong>
OpenAI 的最新模型，如 o3、o4-mini 和 GPT-4.1 系列，使企业能够为其最重要的工作流程构建最先进的检索系统。然而，信息发展迅速：昨天自信地摄入的事实今天可能已经过时。</p>
<!-- ![Benefits of Temporal Knowledge Base](images/01_benefit_of_temporal_kb.jpg) -->
<p><img
  src="../../../images/01_benefit_of_temporal_kb.jpg"
  alt="时间知识库的好处"
  width="791"
  style="height:auto;"
/></p>
<p>如果没有跟踪每个事实何时有效的能力，检索系统就有可能返回过时、不合规或误导性的答案。在任何行业中，错过时间上下文的后果都可能很严重，如下面的示例所示。</p>
<table>
  <thead>
    <tr>
      <th>行业</th>
      <th>示例问题</th>
      <th>如果数据库不是时间性的，则存在风险</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3"><strong>金融服务</strong></td>
      <td><em>“自 2023 年 2 月以来，穆迪对 YY 银行的长期评级是如何演变的？”</em></td>
      <td>通过混合历史和当前评级来错误定价信用风险</td>
    </tr>
    <tr>
      <td><em>“ZZ 零售商在发布 22 财年指导时谁是首席财务官？”</em></td>
      <td>治理/内幕交易分析可能会错误地指责错误的执行官</td>
    </tr>
    <tr>
      <td><em>“AA 基金在 2024 年 1 月购买 CC 股票时是否受到 BB 条款的制裁？”</em></td>
      <td>如果规则后来发生变化，合规报告可能会错过违规行为</td>
    </tr>
    <tr>
      <td rowspan="3"><strong>制造业/汽车</strong></td>
      <td><em>“2022 年 5 月至 2023 年 3 月期间装运的 Q3 型号汽车中部署了哪个 ECU 固件？”</em></td>
      <td>由于固件漂移而错误诊断现场故障</td>
    </tr>
    <tr>
      <td><em>“在 8421 批次生产期间，7 号装配线的哪个机器人控制器软件版本在运行？”</em></td>
      <td>根本原因分析可能归咎于错误的软件版本</td>
    </tr>
    <tr>
      <td><em>“2024 年 5 月生产的车辆的转向柱螺栓的扭矩规格是多少？”</em></td>
      <td>安全召回可能遗漏受影响的车辆</td>
    </tr>
  </tbody>
</table>

<p>虽然我们在此处列出了一些具体示例，但这一主题在制药、法律、消费品等众多行业中都适用。</p>
<p><strong>超越标准检索</strong></p>
<p>时间感知知识图谱使您能够超越静态事实查找。它支持更丰富的检索工作流程，例如基于时间的问答、时间线生成、变更跟踪、反事实分析等。我们将在本手册后面的检索部分更详细地介绍这些内容。</p>
<!-- ![Question types suitable for temporal knowledge bases](./images/02_question_types_for_temporal_kbs.jpg) -->
<p><img
  src="../../../images/02_question_types_for_temporal_kbs.jpg"
  alt="适用于时间知识库的问题类型"
  style="width:1091px; height:auto;"
/></p>
<h2 id="31">3.1. 介绍我们的时间代理</h2>
<hr />
<p><strong>时间代理</strong>是一个专门的管道，它将原始的自由格式语句转换为时间感知的三元组，以便将其摄入知识图谱，然后可以使用“T 时刻什么才是正确的？”这类问题来查询该知识图谱。</p>
<p>三元组是知识图谱的基本构建块。它是一种使用三个部分（因此称为“三元组”）来表示单个事实或知识的方法：</p>
<ul>
<li><strong>主语</strong> - 您正在谈论的实体</li>
<li><strong>谓词</strong> - 关系的类型或属性</li>
<li><strong>宾语</strong> - 主语连接到的值或其他实体</li>
</ul>
<p>您可以将其视为一个具有结构 <code>[主语] - [谓词] - [宾语]</code> 的句子。更清晰的示例：</p>
<pre class="codehilite"><code>“伦敦” - “是首都” - “联合王国”
</code></pre>

<p>本手册中实现的时间代理从 <a href="https://arxiv.org/abs/2501.13956">Zep</a> 和 <a href="https://github.com/getzep/graphiti">Graphiti</a> 中汲取灵感，同时引入了对事实无效性的更严格控制以及对情节类型更细致的方法。</p>
<h3 id="311">3.1.1. 本手册中引入的关键增强功能</h3>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>时间有效性提取</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      在 Graphiti 的提示设计基础上，无需辅助参考语句即可识别时间跨度和情节上下文。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>事实无效逻辑</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      引入了双向检查，并限制了按情节类型进行的比较。这保留了 Zep 的非损耗方法，同时减少了不必要的评估。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间与情节类型化</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      区分 <code>事实</code>、<code>意见</code>、<code>预测</code>，以及时间类别 <code>静态</code>、<code>动态</code>、<code>非时间性</code>。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>多事件提取</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      在一次传递中处理复合句和嵌套日期引用。
    </p>
  </li>
</ol>

<p>此过程使我们能够高效可靠地更新我们的信息来源：</p>
<p><br></p>
<!-- ![Statement Invalidation in practice](./images/03_statement_invalidation.png) -->
<p><img
  src="../../../images/03_statement_invalidation.png"
  alt="实际中的语句无效"
  style="width:791px; height:auto;"
/></p>
<h2 id="pgvector">&gt; <strong>注意</strong>：虽然本手册中的实现侧重于基于图谱的实现，但这种方法可以推广到其他知识库结构，例如基于 pgvector 的系统。</h2>
<h3 id="312">3.1.2. 时间代理管道</h3>
<p>时间代理通过三个阶段的管道处理传入的语句：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>时间分类</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      将每个语句标记为<strong>非时间性</strong>、<strong>静态</strong>或<strong>动态</strong>：
    </p>
    <ul style="margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1em;">
      <li style="margin-bottom: 0.5em;"><em>非时间性</em>语句永不改变（例如，“光在真空中的速度约为 3×10⁸ m s⁻¹”）。</li>
      <li style="margin-bottom: 0.5em;"><em>静态</em>语句从某个时间点开始有效，之后不再改变（例如，“YY 先生于 2014 年 10 月 23 日担任 XX 公司首席执行官。”）。</li>
      <li><em>动态</em>语句会演变（例如，“YY 先生是 XX 公司的首席执行官。”）。</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间事件提取</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      识别相对或部分日期（例如，“星期二”、“三个月前”）并使用文档时间戳或回退启发式方法（例如，如果仅知道月份，则默认为该月的第一天或最后一天）将其解析为绝对日期。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间有效性检查</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      确保每个语句都包含 <code>t_created</code> 时间戳，并在适用时包含 <code>t_expired</code> 时间戳。然后，代理会将候选三元组与现有知识图谱条目进行比较以：
    </p>
    <ul style="margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1em;">
      <li style="margin-bottom: 0.5em;">检测矛盾并用 <code>t_invalid</code> 标记过时的条目</li>
      <li style="margin-bottom: 0.5em;">将较新的语句链接到它们无效的语句，使用 <code>invalidated_by</code></li>
    </ul>
  </li>
</ol>

<!-- ![Screenshot 2025-06-23 at 11.43.34.png](temporal_agents_with_knowledge_graphs_files/290fc94d-2358-44d9-829c-220cd96a8b34.png) -->
<p><img
  src="../../../images/04_temporal_agent.png"
  alt="时间代理"
  style="width:809px; height:auto;"
/></p>
<h3 id="313">3.1.3. 为时间代理选择合适的模型</h3>
<p>在构建具有 LLM 的系统时，一个好的做法是<a href="https://platform.openai.com/docs/guides/model-selection">先使用大型模型，然后再优化和缩小</a>。</p>
<p>GPT-4.1 系列因其强大的指令遵循能力而特别适合构建时间代理。在像 Scale 的 MultiChallenge 这样的基准测试中，<a href="https://openai.com/index/gpt-4-1/">GPT-4.1 的表现比 GPT-4o 高出 10.5%</a>，展示了其在保持上下文、对话推理和遵循指令方面的卓越能力——这些都是提取带时间戳三元组的关键特征。这些功能使其成为构建依赖于时间感知数据提取的代理的绝佳选择。</p>
<h4 id="_4">推荐的开发工作流程</h4>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>使用 GPT-4.1 进行原型设计</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      在构建核心管道逻辑时，最大化正确性并减少提示调试时间。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>切换到 GPT-4.1-mini 或 GPT-4.1-nano</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      一旦提示和逻辑稳定，切换到更小的变体以降低延迟和成本效益。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>蒸馏到 GPT-4.1-mini 或 GPT-4.1-nano</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用<a href="https://platform.openai.com/docs/guides/distillation" target="_blank">OpenAI 的模型蒸馏</a>来训练较小的模型，并使用来自 GPT-4.1 等较大“教师”模型的优质输出，从而在相对于 GPT-4.1 保持（甚至提高）性能。
    </p>
  </li>
</ol>

<p>| 模型                    | 相对成本 | 相对延迟  | 智能 | 工作流程中的理想角色                   |</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>相对成本</th>
<th>相对延迟</th>
<th>智能</th>
<th>工作流程中的理想角色</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>GPT-4.1</em></td>
<td>★★★</td>
<td>★★</td>
<td>★★★ <em>(最高)</em></td>
<td>基础事实原型设计、为蒸馏生成数据</td>
</tr>
<tr>
<td><em>GPT-4.1-mini</em></td>
<td>★★</td>
<td>★</td>
<td>★★</td>
<td>平衡成本效益、中到大型生产系统</td>
</tr>
<tr>
<td><em>GPT-4.1-nano</em></td>
<td>★ <em>(最低)</em></td>
<td>★ <em>(最快)</em></td>
<td>★</td>
<td>成本敏感和超大规模批量处理</td>
</tr>
</tbody>
</table>
<blockquote>
<p>实际上，这看起来是这样的：使用 GPT-4.1 进行原型设计 → 衡量质量 → 逐步降低模型，直到权衡不再满足您的需求。</p>
</blockquote>
<h2 id="32">3.2. 构建时间代理管道</h2>
<hr />
<p>在深入了解实现细节之前，了解管道的高层结构很有用：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>加载转录稿</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>创建语义分块器</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>为时间代理奠定基础</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>语句提取</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间范围提取</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>创建三元组</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间事件</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>定义时间代理</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>实体解析</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>无效代理</strong><br />
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>构建管道</strong><br />
  </li>
</ol>

<h3 id="_5">架构图</h3>
<!-- ![Screenshot 2025-06-23 at 11.44.13.png](temporal_agents_with_knowledge_graphs_files/5463dc6a-17fc-4f35-adde-5a77dc191925.png) -->
<p><img
  src="../../../images/06_temporal_agent_chunker.png"
  alt="时间代理管道 - 分块器"
  style="width:791px; height:auto;"
/></p>
<h3 id="321">3.2.1. 加载转录稿</h3>
<p>在本手册中，我们选择了 <a href="https://huggingface.co/datasets/jlh-ibm/earnings_call">"财报电话会议数据集" (jlh-ibm/earnings_call)</a>，该数据集在知识共享许可协议 1.0 版下提供。该数据集包含 188 份财报电话会议记录，这些记录源于 2016-2020 年期间与纳斯达克股市相关的记录。我们认为此数据集非常适合本手册，因为从财报电话会议记录中提取信息以及随后查询信息是世界各地许多金融机构的常见问题。</p>
<p>此外，同一公司在多次财报电话会议中陈述和主题的通常可变特征为演示时间知识图谱概念提供了有用的途径。</p>
<p>尽管此数据集侧重于金融界，但我们以通用结构构建时间代理，因此可以轻松地将其应用于制药、法律、汽车等其他行业的类似问题。</p>
<p>在本手册中，我们将处理限制为两家公司 - AMD 和 Nvidia - 尽管在实践中，此管道可以轻松扩展到任何公司。</p>
<p>现在让我们从 HuggingFace 加载数据集。</p>
<pre class="codehilite"><code class="language-python">from datasets import load_dataset

hf_dataset_name = &quot;jlh-ibm/earnings_call&quot;
subset_options = [&quot;stock_prices&quot;, &quot;transcript-sentiment&quot;, &quot;transcripts&quot;]

hf_dataset = load_dataset(hf_dataset_name, subset_options[2])
my_dataset = hf_dataset[&quot;train&quot;]
</code></pre>

<pre class="codehilite"><code class="language-python">my_dataset
</code></pre>

<pre class="codehilite"><code>Dataset({
    features: ['company', 'date', 'transcript'],
    num_rows: 150
})
</code></pre>

<pre class="codehilite"><code class="language-python">row = my_dataset[0]
row[&quot;company&quot;], row[&quot;date&quot;], row[&quot;transcript&quot;][:200]
</code></pre>

<pre class="codehilite"><code class="language-python">from collections import Counter

company_counts = Counter(my_dataset[&quot;company&quot;])
company_counts
</code></pre>

<p><strong>数据库设置</strong></p>
<p>在我们开始处理这些数据之前，让我们设置我们的数据库。</p>
<p>为了在笔记本电脑格式中方便使用，我们选择 SQLite 作为此实现的数据库。在“原型到生产”部分以及<a href="./Appendix.ipynb">附录 A.1“存储和检索高容量图数据”</a>中，我们更详细地介绍了围绕不同数据集选择的考虑因素。</p>
<p>如果您在本地运行此手册，您可以选择将 <code>memory</code> 设置为 <code>False</code> 以将数据库保存到存储中，默认文件路径 <code>my_database.db</code> 将用于存储您的数据库，或者您可以将自己的 <code>db_path</code> 参数传递给 <code>make_connection</code>。</p>
<p>我们将设置几个表来存储以下信息：</p>
<ul>
<li>转录稿</li>
<li>块</li>
<li>时间事件</li>
<li>三元组</li>
<li>实体（包括规范映射）</li>
</ul>
<p>此代码通过 <code>make_connection</code> 方法进行了抽象，该方法创建新的 SQLite 数据库。此方法的详细信息可以在本手册 GitHub 存储库的 <code>db_interface.py</code> 脚本中找到。</p>
<pre class="codehilite"><code class="language-python">from db_interface import make_connection

sqlite_conn = make_connection(memory=False, refresh=True)
</code></pre>

<h3 id="322">3.2.2. 创建语义分块器</h3>
<p>在深入构建 <code>Chunker</code> 类本身之前，我们首先定义我们的第一个数据模型。正如通常被认为是 Python 的良好实践，<a href="https://docs.pydantic.dev/latest/">Pydantic</a> 用于确保我们数据模型中的类型安全和清晰度。Pydantic 提供了一种声明式的方法来定义数据结构，同时自动验证和解析输入数据，使我们的数据模型既健壮又易于使用。</p>
<h4 id="_6">分块模型</h4>
<p>这是我们将用于存储从转录稿中提取的单个文本片段以及任何相关元数据的核心数据模型。当我们通过将转录稿分解为有意义的语义块来处理它们时，每个部分将保存为单独的 <code>Chunk</code>。</p>
<p>每个 <code>Chunk</code> 包含：</p>
<ul>
<li><code>id</code>: 为每个块自动生成的唯一标识符。这有助于我们在整个过程中识别和跟踪文本块</li>
<li><code>text</code>: 包含块的文本内容的字符串字段</li>
<li><code>metadata</code>: 一个字典，用于灵活存储元数据</li>
</ul>
<pre class="codehilite"><code class="language-python">import uuid
from typing import Any

from pydantic import BaseModel, Field


class Chunk(BaseModel):
    &quot;&quot;&quot;转录稿中的一段文本。&quot;&quot;&quot;

    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    text: str
    metadata: dict[str, Any]
</code></pre>

<h4 id="_7">转录稿模型</h4>
<p>顾名思义，我们将使用 <code>Transcript</code> 模型来表示财报电话会议转录稿的完整内容。它捕获了几个关键信息：</p>
<ul>
<li><code>id</code>: 类似于 <code>Chunk</code>，这为我们提供了唯一的标识符</li>
<li><code>text</code>: 转录稿的完整文本</li>
<li><code>company</code>: 财报电话会议涉及的公司名称</li>
<li><code>date</code>: 财报电话会议的日期</li>
<li><code>quarter</code>: 财报电话会议所在的财季</li>
<li><code>chunks</code>: 一个 <code>Chunk</code> 对象列表，每个对象代表完整转录稿的有意义的片段</li>
</ul>
<p>为了确保 <code>date</code> 字段得到正确处理，<code>to_datetime</code> 验证器用于将值转换为 datetime 对象。</p>
<pre class="codehilite"><code class="language-python">from datetime import datetime

from pydantic import field_validator


class Transcript(BaseModel):
    &quot;&quot;&quot;财报电话会议的转录稿。&quot;&quot;&quot;

    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    text: str
    company: str
    date: datetime
    quarter: str | None = None
    chunks: list[Chunk] | None = None

    @field_validator(&quot;date&quot;, mode=&quot;before&quot;)
    @classmethod
    def to_datetime(cls, d: Any) -&gt; datetime:
        &quot;&quot;&quot;将输入转换为 datetime 对象。&quot;&quot;&quot;
        if isinstance(d, datetime):
            return d
        if hasattr(d, &quot;isoformat&quot;):
            return datetime.fromisoformat(d.isoformat())
        return datetime.fromisoformat(str(d))
</code></pre>

<h4 id="_8">分块器类</h4>
<p>现在，我们定义 <code>Chunker</code> 类来将每个转录稿分割成有意义的语义块。我们不依赖于任意规则，如字符计数或换行符，而是应用语义分块来保留原始转录稿的更多上下文完整性。这确保每个块都是一个自包含的单元，能够将上下文相关的想法联系在一起。这对于下游任务（如语句提取）特别有用，因为上下文会严重影响准确性。</p>
<p>分块器类包含两个方法：</p>
<ul>
<li><code>find_quarter</code></li>
</ul>
<p>此方法尝试使用简单的正则表达式直接从转录稿文本中提取财季（例如，“Q1 2023”）。在这种情况下，这很简单，因为转录稿中的季度数据格式一致且定义明确。</p>
<p>然而，在实际场景中，可靠地检测季度可能需要更多工作。在多个来源或文档类型中，季度的详细程度可能不同。LLM 是帮助缓解此问题的好工具。尝试使用 GPT-4.1-mini 和一个专门用于在给定文档更广泛上下文的情况下提取季度的提示。</p>
<ul>
<li><code>generate_transcripts_and_chunks</code></li>
</ul>
<p>这是核心方法，它接收数据集（作为字典的可迭代对象）并返回一个 <code>Transcript</code> 对象列表，每个对象都填充了语义派生的 <code>Chunk</code>。它执行以下步骤：</p>
<ol>
<li><em>转录稿创建</em>：使用提供的文本、公司和日期字段初始化 <code>Transcript</code> 对象</li>
<li><em>过滤</em>：使用 <a href="https://chonkie.ai/">chonkie</a> 的 <code>SemanticChunker</code> 和 OpenAI 的 text-embedding-3-small 模型将转录稿分割成逻辑段</li>
<li><em>块分配</em>：将每个语义段包装到 <code>Chunk</code> 模型中，并附加相关的元数据，如开始和结束索引</li>
</ol>
<p>分块器落入我们管道的这个部分：</p>
<!-- ![Screenshot 2025-06-23 at 11.44.13.png](temporal_agents_with_knowledge_graphs_files/5463dc6a-17fc-4f35-adde-5a77dc191925.png) -->
<p><img
  src="../../../images/06_temporal_agent_chunker.png"
  alt="时间代理管道 - 分块器"
  style="width:791px; height:auto;"
/></p>
<pre class="codehilite"><code class="language-python">import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any

from chonkie import OpenAIEmbeddings, SemanticChunker
from tqdm import tqdm


class Chunker:
    &quot;&quot;&quot;
    接收财报电话会议的转录稿，并使用基于嵌入的相似性将转录稿分割成有意义的语义块。
    &quot;&quot;&quot;

    def __init__(self, model: str = &quot;text-embedding-3-small&quot;):
        self.model = model

    def find_quarter(self, text: str) -&gt; str | None:
        &quot;&quot;&quot;如果存在，则从输入文本中提取季度（例如，“Q1 2023”），否则返回 None。&quot;&quot;&quot;
        # 在此数据集中，我们可以仅使用正则表达式查找季度，因为它定义一致
        search_results = re.findall(r&quot;[Q]\d\s\d{4}&quot;, text)

        if search_results:
            quarter = str(search_results[0])
            return quarter

        return None


    def generate_transcripts_and_chunks(
        self,
        dataset: Any,
        company: list[str] | None = None,
        text_key: str = &quot;transcript&quot;,
        company_key: str = &quot;company&quot;,
        date_key: str = &quot;date&quot;,
        threshold_value: float = 0.7,
        min_sentences: int = 3,
        num_workers: int = 50,
    ) -&gt; list[Transcript]:
        &quot;&quot;&quot;使用语义块填充 Transcript 对象。&quot;&quot;&quot;
        # 使用传递的转录稿数据填充 Transcript 对象
        transcripts = [
            Transcript(
                text=d[text_key],
                company=d[company_key],
                date=d[date_key],
                quarter=self.find_quarter(d[text_key]),
            )
            for d in dataset
        ]

        if company:
            transcripts = [t for t in transcripts if t.company in company]

        def _process(t: Transcript) -&gt; Transcript:
            if not hasattr(_process, &quot;chunker&quot;):
                embed_model = OpenAIEmbeddings(self.model)
                _process.chunker = SemanticChunker(
                    embedding_model=embed_model,
                    threshold=threshold_value,
                    min_sentences=max(min_sentences, 1),
                )
            semantic_chunks = _process.chunker.chunk(t.text)
            t.chunks = [
                Chunk(
                    text=c.text,
                    metadata={
                        &quot;start_index&quot;: getattr(c, &quot;start_index&quot;, None),
                        &quot;end_index&quot;: getattr(c, &quot;end_index&quot;, None),
                    },
                )
                for c in semantic_chunks
            ]
            return t

        # 使用线程池创建语义块并将它们添加到各自的 Transcript 对象中
        with ThreadPoolExecutor(max_workers=num_workers) as pool:
            futures = [pool.submit(_process, t) for t in transcripts]
            transcripts = [
                f.result()
                for f in tqdm(
                    as_completed(futures),
                    total=len(futures),
                    desc=&quot;生成语义块&quot;,
                )
            ]

        return transcripts
</code></pre>

<pre class="codehilite"><code class="language-python">raw_data = list(my_dataset)

chunker = Chunker()
transcripts = chunker.generate_transcripts_and_chunks(raw_data)
</code></pre>

<p>或者，我们可以从 <code>transcripts/</code> 中预处理的文件加载 AMD 和 NVDA 的预分块转录稿</p>
<pre class="codehilite"><code class="language-python">import pickle
from pathlib import Path


def load_transcripts_from_pickle(directory_path: str = &quot;transcripts/&quot;) -&gt; list[Transcript]:
    &quot;&quot;&quot;从目录加载所有 pickle 文件到字典中。&quot;&quot;&quot;
    loaded_transcripts = []
    dir_path = Path(directory_path).resolve()


    for pkl_file in sorted(dir_path.glob(&quot;*.pkl&quot;)):
        try:
            with open(pkl_file, &quot;rb&quot;) as f:
                transcript = pickle.load(f)
                # 确保它是 Transcript 对象
                if not isinstance(transcript, Transcript):
                    transcript = Transcript(**transcript)
                loaded_transcripts.append(transcript)
                print(f&quot;✅ 从 {pkl_file.name} 加载了转录稿&quot;)
        except Exception as e:
            print(f&quot;❌ 加载 {pkl_file.name} 时出错：{e}&quot;)

    return loaded_transcripts
</code></pre>

<pre class="codehilite"><code class="language-python"># transcripts = load_transcripts_from_pickle()
</code></pre>

<p>现在我们可以检查几个块：</p>
<pre class="codehilite"><code class="language-python">chunks = transcripts[0].chunks
if chunks is not None:
    for i, chunk in enumerate(chunks[21:23]):
        print(f&quot;块 {i+21}:&quot;)
        print(f&quot;  ID: {chunk.id}&quot;)
        print(f&quot;  文本: {repr(chunk.text[:200])}{'...' if len(chunk.text) &gt; 100 else ''}&quot;)
        print(f&quot;  元数据: {chunk.metadata}&quot;)
        print()
else:
    print(&quot;第一个转录稿未找到块。&quot;)
</code></pre>

<p>至此，我们已成功将转录稿分割成语义分块。现在我们可以继续进行管道的下一步。</p>
<h3 id="323">3.2.3. 为时间代理奠定基础</h3>
<p>在定义 <code>TemporalAgent</code> 类之前，我们将首先定义它运行所需的相关提示和数据模型。</p>
<h4 id="_9">正式化我们的标签定义</h4>
<p>为了让时间代理能够准确地提取语句和时间类型，我们需要为它提供足够详细和具体的上下文。为了方便起见，我们在下面的结构化格式中定义了这些。</p>
<p>每个标签包含三个关键信息，我们稍后将把这些信息传递给我们的 LLM 提示。</p>
<ul style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <code>definition</code><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      提供了标签所代表内容的简洁描述。它建立了语句或时间类型的概念边界，并确保跨示例的解释一致性。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <code>date_handling_guidance</code><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      解释了如何解释与标签关联的语句的时间有效性。它描述了在处理该标签的实例时如何派生 <code>valid_at</code> 和 <code>invalid_at</code> 日期。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>日期处理示例</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      包含说明性示例，展示了在这些标签下，真实世界的语句将如何被标记和时间注释。这些将用作下游 LLM 的少量示例。
    </p>
  </li>
</ul>

<pre class="codehilite"><code class="language-python">LABEL_DEFINITIONS: dict[str, dict[str, dict[str, str]]] = {
    &quot;episode_labelling&quot;: {
        &quot;FACT&quot;: dict(
            definition=(
                &quot;客观的陈述，可以通过证据独立验证或证伪。 &quot;
            ),
            date_handling_guidance=(
                &quot;这些陈述可以由多个静态和动态的时间事件组成，标记例如陈述所描述的事实的开始、结束和持续时间。&quot;
            ),
            date_handling_example=(
                &quot;'公司 A 在 2022 年拥有公司 B'、'X 导致了 Y 的发生' 或 '约翰在活动中说了 X' 是可验证的事实，除非我们有矛盾的事实，否则它们目前仍然成立。&quot;
            ),
        ),
        &quot;OPINION&quot;: dict(
            definition=(
                &quot;包含个人意见、感受、价值观或判断的陈述，这些陈述无法独立验证。它还包括假设性和推测性陈述。&quot;
            ),
            date_handling_guidance=(
                &quot;此陈述始终是静态的。它是所做意见日期的记录。&quot;
            ),
            date_handling_example=(
                &quot;'我喜欢公司 A 的策略'、'X 可能导致了 Y 的发生' 或 '这次活动感觉像 X' 都是意见，取决于记者的解释。&quot;
            ),
        ),
        &quot;PREDICTION&quot;: dict(
            definition=(
                &quot;关于未来可能发生的事情的不确定陈述，假设性结果，未经证实的声明。它包括解释和建议。如果陈述的时态发生变化，该陈述将变为事实。&quot;
            ),
            date_handling_guidance=(
                &quot;此陈述始终是静态的。它是所做预测日期的记录。&quot;
            ),
            date_handling_example=(
                &quot;'据传闻，戴夫下个月将辞职'、'公司 A 预计 X 会发生' 或 'X 表明 Y' 都是预测。&quot;
            ),
        ),
    },
    &quot;temporal_labelling&quot;: {
        &quot;STATIC&quot;: dict(
            definition=(
                &quot;通常是过去时态，想想 -ed 动词，描述单个时间点。 &quot;
                &quot;这些陈述从它们发生的那天起就有效，并且永远不会失效。指的是事件发生的单个时间点，事实 X 在该日期发生将永远成立。&quot;
            ),
            date_handling_guidance=(
                &quot;valid_at 日期是事件发生的日期。invalid_at 日期为 None。&quot;
            ),
            date_handling_example=(
                &quot;'约翰于 2024 年 1 月 4 日被任命为首席执行官'、'公司 A 从上一个财年报告了 X% 的增长' 或 'X 导致了 Y 的发生' 是在其发生的当天就有效的，并且永远不会失效。&quot;
            ),
        ),
        &quot;DYNAMIC&quot;: dict(
            definition=(
                &quot;通常是现在时态，想想 -ing 动词，描述一段时间。 &quot;
                &quot;这些陈述在特定时间段内有效，并且通常会被标记事件开始或矛盾新事件开始的静态事实所无效。该陈述可能已经指代一个离散的时间段（无效）或可能是一个正在进行的关系（尚未无效）。&quot;
            ),
            date_handling_guidance=(
                &quot;valid_at 日期是事件开始的日期。invalid_at 日期是事件结束或关系的日期，对于正在进行的事件，此日期为 None。&quot;
            ),
            date_handling_example=(
                &quot;'约翰是首席执行官'、'公司 A 仍然是市场领导者' 或 'X 持续导致 Y 下降' 是从事件开始时就有效的，并且会被新事件无效。&quot;
            ),
        ),
        &quot;ATEMPORAL&quot;: dict(
            definition=(
                &quot;无论时间如何，始终为真的陈述，因此没有时间界限。&quot;
            ),
            date_handling_guidance=(
                &quot;这些陈述被假定为非时间性的，没有时间界限。它们的 valid_at 和 invalid_at 均为 None。&quot;
            ),
            date_handling_example=(
                &quot;'股票代表公司所有权的一部分'、'地球是圆的' 或 '欧洲是一个大陆'。这些陈述无论何时都是正确的。&quot;
            ),
        ),
    },
}
</code></pre>

<h3 id="324">3.2.4. 语句提取</h3>
<p>“语句提取”是指将我们的语义块分解为最小的“原子”事实的过程。在我们的时间代理中，这是通过以下方式实现的：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>查找每个独立的、声明性的主张</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      提取可以作为完整的“主语-谓词-宾语”表达式独立存在的语句，而无需依赖周围的上下文。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>确保原子性</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      将复杂或复合句子分解为最小的、不可分割的事实单元，每个单元表达一个单一的关系。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>解析引用</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用主语进行消歧，将代词或抽象引用（例如，“他”或“公司”）替换为特定的实体（例如，“约翰·史密斯”，“AMD”）。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>保持时间精度和数量精度</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      保留明确的日期、持续时间和数量，以精确地将每个事实锚定在时间和规模上。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>标记每个提取的语句</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      每个语句都用 `StatementType` 和 `TemporalType` 进行注释。
    </p>
  </li>
</ol>

<h4 id="_10">时间类型</h4>
<p><code>TemporalType</code> 枚举提供了一组标准化的时间类别，这些类别使得从财报电话会议记录中提取的语句的分类和处理更加容易。</p>
<p>每个类别都捕获不同类型的时间引用：</p>
<ul>
<li><strong>非时间性</strong>：普遍真实且随时间不变的语句（例如，“真空中的光速约为 3×10⁸ m s⁻¹。”）。</li>
<li><strong>静态</strong>：在特定时间点变为真实且之后保持不变的语句（例如，“YY 先生于 2014 年 10 月 23 日担任 XX 公司首席执行官。”）。</li>
<li><strong>动态</strong>：可能随时间变化的语句，需要时间上下文才能准确解释（例如，“YY 先生是 XX 公司的首席执行官。”）。</li>
</ul>
<pre class="codehilite"><code class="language-python">from enum import StrEnum


class TemporalType(StrEnum):
    &quot;&quot;&quot;语句的时间类型枚举。&quot;&quot;&quot;

    ATEMPORAL = &quot;ATEMPORAL&quot;
    STATIC = &quot;STATIC&quot;
    DYNAMIC = &quot;DYNAMIC&quot;
</code></pre>

<h4 id="_11">语句类型</h4>
<p>同样，<code>StatementType</code> 枚举对每个提取语句的性质进行分类，捕获其认识论特征。</p>
<ul>
<li><strong>事实</strong>：断言一个在声明时被认为是真实的、可验证的主张的语句。但是，它可能稍后被其他事实（例如，更新的信息或更正）所取代或矛盾。</li>
<li><strong>意见</strong>：反映说话者信念、情绪或判断的主观陈述。本质上，意见被认为是其表达时刻的暂时真实。</li>
<li><strong>预测</strong>：关于可能发生的未来事件或结果的前瞻性或假设性陈述。在时间上，预测被假定从其发布时间起有效，直到推断的预测窗口结束。</li>
</ul>
<pre class="codehilite"><code class="language-python">class StatementType(StrEnum):
    &quot;&quot;&quot;语句的语句类型枚举。&quot;&quot;&quot;

    FACT = &quot;FACT&quot;
    OPINION = &quot;OPINION&quot;
    PREDICTION = &quot;PREDICTION&quot;
</code></pre>

<h4 id="_12">原始语句</h4>
<p><code>RawStatement</code> 模型代表由 LLM 提取的单个语句，并带有其语义类型（<code>StatementType</code>）和时间分类（<code>TemporalType</code>）的注释。这些原始语句作为中间表示，并打算在后续处理阶段转换为 <code>TemporalEvent</code> 对象。</p>
<p>核心字段：</p>
<ul>
<li><code>statement</code>：提取语句的文本内容</li>
<li><code>statement_type</code>：语句的类型（事实、意见、预测），基于 <code>StatementType</code> 枚举</li>
<li><code>temporal_type</code>：语句的时间分类（静态、动态、非时间性），来自 <code>TemporalType</code> 枚举</li>
</ul>
<p>该模型包含字段级验证器，以确保所有类型注释都符合各自的枚举，从而提供一层针对无效输入的稳健性。</p>
<p>配套模型 <code>RawStatementList</code> 包含语句提取步骤的输出：<code>RawStatement</code> 实例列表。</p>
<pre class="codehilite"><code class="language-python">from pydantic import field_validator


class RawStatement(BaseModel):
    &quot;&quot;&quot;表示带有类型和时间信息的原始语句的模型。&quot;&quot;&quot;

    statement: str
    statement_type: StatementType
    temporal_type: TemporalType

    @field_validator(&quot;temporal_type&quot;, mode=&quot;before&quot;)
    @classmethod
    def _parse_temporal_label(cls, value: str | None) -&gt; TemporalType:
        if value is None:
            return TemporalType.ATEMPORAL
        cleaned_value = value.strip().upper()
        try:
            return TemporalType(cleaned_value)
        except ValueError as e:
            raise ValueError(f&quot;无效的时间类型：{value}。必须是以下之一：{[t.value for t in TemporalType]}&quot;) from e

    @field_validator(&quot;statement_type&quot;, mode=&quot;before&quot;)
    @classmethod
    def _parse_statement_label(cls, value: str | None = None) -&gt; StatementType:
        if value is None:
            return StatementType.FACT
        cleaned_value = value.strip().upper()
        try:
            return StatementType(cleaned_value)
        except ValueError as e:
            raise ValueError(f&quot;无效的时间类型：{value}。必须是以下之一：{[t.value for t in StatementType]}&quot;) from e

class RawStatementList(BaseModel):
    &quot;&quot;&quot;表示原始语句列表的模型。&quot;&quot;&quot;

    statements: list[RawStatement]
</code></pre>

<h4 id="_13">语句提取提示</h4>
<p>这是驱动我们的时间代理提取和标记原子语句的核心提示。它以 <a href="https://jinja.pallet.com/en/stable/">Jinja</a> 编写，允许我们通过模块化方式组合动态输入，而无需重写核心逻辑。</p>
<h5 id="_14">提示的结构</h5>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>设置提取任务</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      我们指示助手充当金融领域专家，并清晰地定义两个子任务：(i) 提取原子声明语句，以及 (ii) 为每个语句标记 <code>statement_type</code> 和 <code>temporal_type</code>。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>强制执行严格的提取指南</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      提取规则有助于强制执行一致性和清晰性。语句必须：
    </p>
    <ul style="margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1em;">
      <li style="margin-bottom: 0.5em;">结构为清晰的主语-谓词-宾语三元组</li>
      <li style="margin-bottom: 0.5em;">自包含且与上下文无关</li>
      <li style="margin-bottom: 0.5em;">解析共指（例如，“他”→“约翰·史密斯”）</li>
      <li style="margin-bottom: 0.5em;">包含时间/数量限定词（如果存在）</li>
      <li>在描述多个事件或时间性时进行拆分</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>支持即插即用定义</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      <code>{% if definitions %}</code> 块使注入结构化定义（如语句类别、时间类型和领域特定术语）变得容易。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>包含少量示例</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      我们提供一个带注释的示例块和相应的 JSON 输出，以向模型演示其应如何行为。
    </p>
  </li>
</ol>

<pre class="codehilite"><code class="language-python">statement_extraction_prompt = '''
{% macro tidy(name) -%}
  {{ name.replace('_', ' ')}}
{%- endmacro %}

您是一位专业的金融人士和信息提取助手。

===输入===
{% if inputs %}
{% for key, val in inputs.items() %}

- {{ key }}: {{val}}
{% endfor %}
{% endif %}

===任务===

1. 根据提取指南，从给定的块中识别并提取原子声明语句
2. 将这些语句（1）标记为事实、意见或预测，以及（2）时间性标记为静态或动态

===提取指南===

- 将语句结构化，以清晰显示主语-谓词-宾语关系
- 每个语句应表达一个完整、完整的关系（最好有多个较小的语句来实现这一点）
- 避免复杂的或复合的谓词，这些谓词组合了多个关系
- 在没有整个文档的上下文的情况下也必须能够理解
- 应尽可能少地修改原始文本
- 在没有整个文档的上下文的情况下也必须能够理解，
    - 解析共指和代词以提取完整语句，如有疑问，请使用 main_entity，例如：
      “您最近的竞争对手” -&gt; “main_entity 的最近的竞争对手”

    - 不应引用抽象实体，如“公司”，应替换为实际的公司名称。
    - 展开缩写词和首字母缩略词以获得完整形式

- 语句与单个时间事件或关系相关联
- 包括任何明确的日期、时间或数量限定词，使事实精确
- 如果语句涉及多个时间事件，则应将其分解为描述事件不同时间性的多个语句。
- 如果描述的关系存在静态版本和动态版本，则应同时提取这两个版本

{%- if definitions %}
  {%- for section_key, section_dict in definitions.items() %}
==== {{ tidy(section_key) | upper }} 定义和指南 ====
    {%- for category, details in section_dict.items() %}
{{ loop.index }}. {{ category }}

- 定义： {{ details.get(&quot;definition&quot;, &quot;&quot;) }}
    {% endfor -%}
  {% endfor -%}
{% endif -%}

===示例===
示例块： &quot;&quot;&quot;
  TechNova 第一季度财报（编辑版）
  与会者：

  * Matt Taylor
    ABC 有限公司 - 分析师

  * Taylor Morgan
    BigBank 高级协调员
  ----
  2024 年 4 月 1 日，John Smith 被任命为 TechNova 公司首席财务官。他与现任高级副总裁 Olivia Doe 一起工作。他目前负责监督公司自 2024 年 5 月开始的全球重组计划，该计划预计将持续到 2025 年。
  分析师认为此策略可能会提高盈利能力，尽管其他人认为这会损害员工士气。一位投资者表示：“我认为 Jane 有正确的愿景。”
  根据 TechNova 的第一季度财报，与 2023 年第一季度相比，该公司收入增长了 10%。预计 TechNova 将于 2025 年第三季度推出其人工智能驱动的产品线。
  自 2024 年 6 月以来，TechNova 公司一直在亚洲进行战略合作伙伴关系的谈判。与此同时，自 2024 年 7 月起，它还在扩大在欧洲的业务。截至 2025 年 9 月，该公司正在试点一项针对所有部门的远程优先工作政策。
  竞争对手 SkyTech 上个月宣布他们开发了一款新的人工智能芯片并推出了其云学习平台。
&quot;&quot;&quot;

示例输出： {
  &quot;statements&quot;: [
    {
      &quot;statement&quot;: &quot;Matt Taylor 在 ABC 有限公司工作。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;Matt Taylor 是一名分析师。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;Taylor Morgan 在 BigBank 工作。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;Taylor Morgan 是一名高级协调员。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;John Smith 于 2024 年 4 月 1 日被任命为 TechNova 公司的首席财务官。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;John Smith 自 2024 年 4 月 1 日起担任 TechNova 公司的首席财务官。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;Olivia Doe 是 TechNova 公司的首席财务官。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;John Smith 与 Olivia Doe 一起工作。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;John Smith 自 2024 年 5 月起负责监督 TechNova 公司的全球重组计划。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;分析师认为 TechNova 公司的策略可能会提高盈利能力。&quot;,
      &quot;statement_type&quot;: &quot;OPINION&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;一些人认为 TechNova 公司的策略会损害员工士气。&quot;,
      &quot;statement_type&quot;: &quot;OPINION&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;一位投资者表示“我认为 John 有正确的愿景”，日期未指定。&quot;,
      &quot;statement_type&quot;: &quot;OPINION&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;与 2023 年第一季度相比，TechNova 公司在 2024 年第一季度的收入增长了 10%。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;预计 TechNova 公司将于 2025 年第三季度推出其人工智能驱动的产品线。&quot;,
      &quot;statement_type&quot;: &quot;PREDICTION&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;TechNova 公司于 2024 年 6 月开始在亚洲谈判战略合作伙伴关系。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;TechNova 公司自 2024 年 6 月以来一直在亚洲谈判战略合作伙伴关系。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;TechNova 公司自 2024 年 7 月起一直在扩大在欧洲的业务。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;TechNova 公司于 2024 年 7 月开始扩大在欧洲的业务。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;TechNova 公司将于 2025 年 9 月试点一项针对所有部门的远程优先工作政策。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;SkyTech 是 TechNova 的竞争对手。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;DYNAMIC&quot;
    },
    {
      &quot;statement&quot;: &quot;SkyTech 开发了新的人工智能芯片。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    },
    {
      &quot;statement&quot;: &quot;SkyTech 推出了云学习平台。&quot;,
      &quot;statement_type&quot;: &quot;FACT&quot;,
      &quot;temporal_type&quot;: &quot;STATIC&quot;
    }
  ]
}
===示例结束===

**输出格式**
仅返回匹配以下模式的 JSON 对象数组中的提取的标记语句列表：
{{ json_schema }}
'''
</code></pre>

<h3 id="325">3.2.5. 时间范围提取</h3>
<h4 id="_15">原始时间范围</h4>
<p><code>RawTemporalRange</code> 模型保存了语句的 <code>valid_at</code> 和 <code>invalid_at</code> 日期字符串的原始提取。两者都使用日期时间 <a href="https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses">支持的字符串属性</a>。</p>
<ul>
<li><code>valid_at</code> 表示语句有效期的开始时间</li>
<li><code>invalid_at</code> 表示语句有效期的结束时间</li>
</ul>
<pre class="codehilite"><code class="language-python">class RawTemporalRange(BaseModel):
    &quot;&quot;&quot;表示原始时间有效性范围作为字符串的模型。&quot;&quot;&quot;

    valid_at: str | None = Field(..., json_schema_extra={&quot;format&quot;: &quot;date-time&quot;})
    invalid_at: str | None = Field(..., json_schema_extra={&quot;format&quot;: &quot;date-time&quot;})
</code></pre>

<h4 id="_16">时间有效性范围</h4>
<p>虽然 <code>RawTemporalRange</code> 模型保留了原始提取的日期字符串，但 <code>TemporalValidityRange</code> 模型将这些字符串转换为标准化的 <code>datetime</code> 对象以供下游处理。</p>
<p>它解析原始的 <code>valid_at</code> 和 <code>invalid_at</code> 值，将它们从字符串转换为时区感知的 <code>datetime</code> 实例。这通过字段级验证器来处理。</p>
<pre class="codehilite"><code class="language-python">from utils import parse_date_str


class TemporalValidityRange(BaseModel):
    &quot;&quot;&quot;表示解析后的时间有效性范围作为 datetime 的模型。&quot;&quot;&quot;

    valid_at: datetime | None = None
    invalid_at: datetime | None = None

    @field_validator(&quot;valid_at&quot;, &quot;invalid_at&quot;, mode=&quot;before&quot;)
    @classmethod
    def _parse_date_string(cls, value: str | datetime | None) -&gt; datetime | None:
        if isinstance(value, datetime) or value is None:
            return value
        return parse_date_str(value)
</code></pre>

<h4 id="_17">日期提取提示</h4>
<p>现在让我们创建指导我们的时间代理准确确定语句时间有效性的提示。</p>
<h5 id="_18">提示的结构</h5>
<p>此提示有助于时间代理精确理解和提取时间有效性范围。</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>清晰定义提取任务</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      提示指示我们的模型确定语句何时变为真实（<code>valid_at</code>）以及何时停止真实（<code>invalid_at</code>）。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>使用上下文指导</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      通过动态合并 <code>{{ inputs.temporal_type }}</code> 和 <code>{{ inputs.statement_type }}</code>，提示根据每个语句的性质（例如，区分事实与预测或静态与动态上下文）指导模型解释时间细微差别。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>确保与清晰的格式规则一致</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      为了保持清晰和一致，提示要求将所有日期转换为标准化的 ISO 8601 日期时间格式，并标准化为 UTC。它明确地将相对表达式（如“上个季度”）锚定到已知的发布日期，使时间信息精确可靠。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>与业务报告周期保持一致</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      认识到在商业和金融环境中基于季度的推理的实际需求，提示可以根据业务季度解释和计算时间范围，从而最大限度地减少歧义。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>根据语句类型进行调整以实现语义准确性</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      特定规则确保语句的语义完整性——例如，意见可能只有一个反映其表达时刻的开始日期（<code>valid_at</code>），而预测将使用结束日期（<code>invalid_at</code>）明确定义其预测窗口。
    </p>
  </li>
</ol>

<pre class="codehilite"><code class="language-python">date_extraction_prompt = &quot;&quot;&quot;
{#
  此提示（模板）改编自 [getzep/graphiti]
  根据 Apache 许可证 2.0 版许可

  原始作品：
    https://github.com/getzep/graphiti/blob/main/graphiti_core/prompts/extract_edge_dates.py

  Tomoro 于 2025 年 4 月 14 日进行了修改
  请参阅 LICENSE 文件以获取完整的 Apache 2.0 许可证文本。
#}

{% macro tidy(name) -%}
  {{ name.replace('_', ' ')}}
{%- endmacro %}

输入：
{% if inputs %}
{% for key, val in inputs.items() %}

- {{ key }}: {{val}}
{% endfor %}
{% endif %}

任务：

- 分析语句并确定时间事件或关系的有效时间范围作为日期。
- 使用您提取的时间信息、下面的指南以及语句的制作或发布日期。不要使用任何外部知识来确定有效性范围。
- 仅在日期明确与语句所描述的关系有效性相关时才设置日期。否则，请忽略提到的时间。
- 如果关系不是跨越性的，而是代表一个时间点，但您仍然能够确定发生日期，则仅设置 valid_at。

{{ inputs.get(&quot;temporal_type&quot;) | upper }} 时间类型特定指南：
{% for key, guide in temporal_guide.items() %}

- {{ tidy(key) | capitalize }}: {{ guide }}
{% endfor %}

{{ inputs.get(&quot;statement_type&quot;) | upper }} 语句类型特定指南：
{%for key, guide in statement_guide.items() %}

- {{ tidy(key) | capitalize }}: {{ guide }}
{% endfor %}

有效范围定义：

- `valid_at` 是语句所描述的关系变为真实或建立的日期和时间。
- `invalid_at` 是语句所描述的关系停止真实或结束的日期和时间。如果事件正在进行中，则此值可能为 None。

通用指南：

  1. 对日期时间使用 ISO 8601 格式 (YYYY-MM-DDTHH:MM:SS.SSSSSSZ)。
  2. 使用参考或发布日期作为当前时间来确定 valid_at 和 invalid_at 日期。
  3. 如果事实以现在时态书写但未包含时间信息，请使用参考或发布日期作为 valid_at 日期。
  4. 不要从相关事件或外部知识推断日期。仅使用直接陈述以建立或更改关系的日期。
  5. 根据参考或发布时间戳将相对时间（例如，“两周前”）转换为绝对 ISO 8601 日期时间。
  6. 如果仅提及日期而没有特定时间，则该日期的该时间使用 00:00:00（午夜）。
  7. 如果仅提及年份或月份，请使用适当的开始或结束时间 00:00:00，例如，如果仅提及年份，请不要选择随机日期，请使用 YYYY-01-01 或 YYYY-12-31。
  8. 始终包含时区偏移量（如果未提及特定时区，则使用 Z 表示 UTC）。
{% if inputs.get('quarter') and inputs.get('publication_date') %}

  9. 假设 {{ inputs.quarter }} 结束于 {{ inputs.publication_date }}，并从中推断任何 Qx 引用的日期。
{% endif %}

特定语句规则：

- 当 `statement_type` 为 **opinion** 时，仅设置 valid_at
- 当 `statement_type` 为 **prediction** 时，将其 `invalid_at` 设置为明确提及的**预测窗口结束时间**。

切勿凭空捏造外部知识日期。

**输出格式**
仅返回匹配以下模式的 JSON 对象数组中的有效范围。
{{ json_schema }}
&quot;&quot;&quot;
</code></pre>

<h3 id="326">3.2.6. 创建三元组</h3>
<p>现在我们将构建创建三元组的定义和提示。如上所述，它们是以下组合：</p>
<ul>
<li><strong>主语</strong> - 您正在谈论的实体</li>
<li><strong>谓词</strong> - 关系或属性的类型</li>
<li><strong>宾语</strong> - 谓词影响或描述的值或另一个实体</li>
</ul>
<p>让我们从谓词开始。</p>
<h4 id="_19">谓词</h4>
<p><code>Predicate</code> 枚举提供了一组标准化的谓词，它们清晰地描述了从文本中提取的关系。</p>
<p>我们为财报电话会议记录定义了以下谓词集，以适应它们。以下是一些关于这些谓词如何融入我们知识图谱中的三元组的示例：
以下是更多匿名化、通用化的示例，遵循您的模板：</p>
<ul>
<li><code>IS_A</code>: [ABC 公司]-[IS_A]-[软件供应商]</li>
<li><code>HAS_A</code>: [XYZ 公司]-[HAS_A]-[创新部门]</li>
<li><code>LOCATED_IN</code>: [123 工厂]-[LOCATED_IN]-[德国]</li>
<li><code>HOLDS_ROLE</code>: [简·多]- [HOLDS_ROLE]-[LMN 公司首席执行官]</li>
<li><code>PRODUCES</code>: [DEF 公司]-[PRODUCES]-[智能手机型号 X]</li>
<li><code>SELLS</code>: [789 零售商]-[SELLS]-[家具]</li>
<li><code>LAUNCHED</code>: [UVW 公司]-[LAUNCHED]-[新订阅服务]</li>
<li><code>DEVELOPED</code>: [GHI 初创公司]-[DEVELOPED]-[云基础工具]</li>
<li><code>ADOPTED_BY</code>: [新技术]-[ADOPTED_BY]-[ABC 行业]</li>
<li><code>INVESTS_IN</code>: [JKL 投资公司]-[INVESTS_IN]-[清洁能源初创公司]</li>
<li><code>COLLABORATES_WITH</code>: [PQR 公司]-[COLLABORATES_WITH]-[XYZ 大学]</li>
<li><code>SUPPLIES</code>: [STU 制造商]-[SUPPLIES]-[汽车零部件给 VWX 公司]</li>
<li><code>HAS_REVENUE</code>: [LMN 公司]-[HAS_REVENUE]-[5 亿欧元]</li>
<li><code>INCREASED</code>: [YZA 公司]-[INCREASED]-[市场份额]</li>
<li><code>DECREASED</code>: [BCD 公司]-[DECREASED]-[运营费用]</li>
<li><code>RESULTED_IN</code>: [成本降低计划]-[RESULTED_IN]-[利润率提高]</li>
<li><code>TARGETS</code>: [产品发布活动]-[TARGETS]-[千禧一代消费者]</li>
<li><code>PART_OF</code>: [EFG 子公司]-[PART_OF]-[HIJ 母公司]</li>
<li><code>DISCONTINUED</code>: [KLM 公司]-[DISCONTINUED]-[遗留产品线]</li>
<li><code>SECURED</code>: [NOP 初创公司]-[SECURED]-[B 轮融资]</li>
</ul>
<pre class="codehilite"><code class="language-python">class Predicate(StrEnum):
    &quot;&quot;&quot;规范化谓词的枚举。&quot;&quot;&quot;

    IS_A = &quot;IS_A&quot;
    HAS_A = &quot;HAS_A&quot;
    LOCATED_IN = &quot;LOCATED_IN&quot;
    HOLDS_ROLE = &quot;HOLDS_ROLE&quot;
    PRODUCES = &quot;PRODUCES&quot;
    SELLS = &quot;SELLS&quot;
    LAUNCHED = &quot;LAUNCHED&quot;
    DEVELOPED = &quot;DEVELOPED&quot;
    ADOPTED_BY = &quot;ADOPTED_BY&quot;
    INVESTS_IN = &quot;INVESTS_IN&quot;
    COLLABORATES_WITH = &quot;COLLABORATES_WITH&quot;
    SUPPLIES = &quot;SUPPLIES&quot;
    HAS_REVENUE = &quot;HAS_REVENUE&quot;
    INCREASED = &quot;INCREASED&quot;
    DECREASED = &quot;DECREASED&quot;
    RESULTED_IN = &quot;RESULTED_IN&quot;
    TARGETS = &quot;TARGETS&quot;
    PART_OF = &quot;PART_OF&quot;
    DISCONTINUED = &quot;DISCONTINUED&quot;
    SECURED = &quot;SECURED&quot;
</code></pre>

<p>我们还为每个谓词分配一个定义，然后将其传递给下游的提取提示。</p>
<pre class="codehilite"><code class="language-python">PREDICATE_DEFINITIONS = {
    &quot;IS_A&quot;: &quot;表示两个实体之间的类别或类型关系（例如，“Model Y IS_A electric-SUV”）。包括“is”和“was”。&quot;,
    &quot;HAS_A&quot;: &quot;表示两个实体之间的部分-整体关系（例如，“Model Y HAS_A electric-engine”）。包括“has”和“had”。&quot;,
    &quot;LOCATED_IN&quot;: &quot;指定地理或组织包含或邻近性（例如，总部 LOCATED_IN Berlin）。&quot;,
    &quot;HOLDS_ROLE&quot;: &quot;将一个人与组织内的正式职位或头衔（CEO、主席、董事等）联系起来。&quot;,
    &quot;PRODUCES&quot;: &quot;表示实体制造、构建或创建产品、服务或基础设施（包括规模化和组件包含）。&quot;,
    &quot;SELLS&quot;: &quot;标记商业卖家与客户之间的产品或服务关系（市场、分销、销售）。&quot;,
    &quot;LAUNCHED&quot;: &quot;捕获产品、服务或计划的官方首次发布、发货或公开启动。&quot;,
    &quot;DEVELOPED&quot;: &quot;显示技术、产品或功能的设计、研发或创新来源。包括“研究”或“创建”。&quot;,
    &quot;ADOPTED_BY&quot;: &quot;表示技术或产品已被另一个实体采用、部署或实施。&quot;,
    &quot;INVESTS_IN&quot;: &quot;表示资本或资源从一个实体流向另一个实体（股权、融资轮次、战略投资）。&quot;,
    &quot;COLLABORATES_WITH&quot;: &quot;实体之间的通用合作伙伴关系、联盟、合资企业或许可关系。&quot;,
    &quot;SUPPLIES&quot;: &quot;捕获供应商-客户供应链链接或依赖关系（提供给、来源自）。&quot;,
    &quot;HAS_REVENUE&quot;: &quot;将实体与收入金额或指标相关联——实际的、报告的或预测的。&quot;,
    &quot;INCREASED&quot;: &quot;表示相对于先前时期或基线的指标（收入、市场份额、产出）的向上变化。&quot;,
    &quot;DECREASED&quot;: &quot;表示相对于先前时期或基线的指标的向下变化。&quot;,
    &quot;RESULTED_IN&quot;: &quot;捕获一个事件或因素导致特定结果（正面或负面）的因果关系。&quot;,
    &quot;TARGETS&quot;: &quot;表示实体寻求达到的战略目标、市场细分或客户群体。&quot;,
    &quot;PART_OF&quot;: &quot;表示层级成员资格或子集关系（部门、子公司、由...管理、属于）。&quot;,
    &quot;DISCONTINUED&quot;: &quot;表示产品、服务或关系的官方生命周期结束、关闭或终止。&quot;,
    &quot;SECURED&quot;: &quot;标记实体成功获得资金、合同、资产或权利。&quot;,
}
</code></pre>

<h4 id="_20">定义自己的谓词</h4>
<p>在处理不同的数据源时，您需要定义适合您用例的自己的谓词。</p>
<p>要定义自己的谓词：</p>
<ol>
<li>首先，使用 <code>PREDICATE_DEFINITIONS = {}</code> 在代表性的文档样本上运行您的管道。此初始运行将派生一个嘈杂的图谱，其中包含许多非标准化和重叠的谓词。</li>
<li>接下来，将一些初始结果放入 <a href="https://chatgpt.com/">ChatGPT</a> 或手动审查它们以合并相似的谓词类别。此过程有助于消除重复项，例如 <code>IS_CEO</code> 和 <code>IS_CEO_OF</code>。</li>
<li>最后，仔细审查并优化此谓词列表，以确保清晰度和准确性。然后，这些最终确定的谓词定义将指导您的提取过程，并确保提取管道的一致性。</li>
</ol>
<h4 id="_21">原始三元组</h4>
<p>在谓词定义完善后，我们可以开始构建三元组的数据模型。</p>
<p><code>RawTriplet</code> 模型代表直接从文本数据中提取的基本主语-谓词-宾语关系。这作为我们稍后介绍的更详细的三元组表示 <code>Triplet</code> 的前身。</p>
<p>核心字段：</p>
<ul>
<li><code>subject_name</code>：提取的主语实体的文本表示</li>
<li><code>subject_id</code>：主语实体的数字标识符</li>
<li><code>predicate</code>：由 <code>Predicate</code> 枚举指定的类型</li>
<li><code>object_name</code>：提取的宾语实体的文本表示</li>
<li><code>object_id</code>：宾语实体的数字标识符</li>
<li><code>value</code>：与关系关联的数值，可能为 None，例如 <code>公司</code> -&gt; <code>HAS_A</code> -&gt; <code>收入</code>，值为 <code>'$100 mill'</code></li>
</ul>
<pre class="codehilite"><code class="language-python">class RawTriplet(BaseModel):
    &quot;&quot;&quot;表示主语-谓词-宾语三元组的模型。&quot;&quot;&quot;

    subject_name: str
    subject_id: int
    predicate: Predicate
    object_name: str
    object_id: int
    value: str | None = None
</code></pre>

<h4 id="_22">三元组</h4>
<p><code>Triplet</code> 模型通过包含唯一标识符并可选地将每个三元组链接到特定事件来扩展 <code>RawTriplet</code>。这些标识符有助于集成到像我们的时间知识图谱这样的结构化知识库中。</p>
<pre class="codehilite"><code class="language-python">class Triplet(BaseModel):
    &quot;&quot;&quot;表示主语-谓词-宾语三元组的模型。&quot;&quot;&quot;

    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    event_id: uuid.UUID | None = None
    subject_name: str
    subject_id: int | uuid.UUID
    predicate: Predicate
    object_name: str
    object_id: int | uuid.UUID
    value: str | None = None

    @classmethod
    def from_raw(cls, raw_triplet: &quot;RawTriplet&quot;, event_id: uuid.UUID | None = None) -&gt; &quot;Triplet&quot;:
        &quot;&quot;&quot;从 RawTriplet 创建 Triplet 实例，可选地将其与 event_id 关联。&quot;&quot;&quot;
        return cls(
            id=uuid.uuid4(),
            event_id=event_id,
            subject_name=raw_triplet.subject_name,
            subject_id=raw_triplet.subject_id,
            predicate=raw_triplet.predicate,
            object_name=raw_triplet.object_name,
            object_id=raw_triplet.object_id,
            value=raw_triplet.value,
        )
</code></pre>

<h4 id="_23">原始实体</h4>
<p><code>RawEntity</code> 模型代表从 <code>Statement</code> 中提取的实体。这作为我们接下来介绍的更详细的三元组表示 <code>Entity</code> 的前身。</p>
<p>核心字段：</p>
<ul>
<li><code>entity_idx</code>：一个整数，用于区分从语句中提取的实体（链接到 <code>RawTriplet</code>）</li>
<li><code>name</code>：提取的实体名称，例如 <code>AMD</code></li>
<li><code>type</code>：提取的实体类型，例如 <code>公司</code></li>
<li><code>description</code>：实体的文本描述，例如 <code>以制造半导体而闻名的科技公司</code></li>
</ul>
<pre class="codehilite"><code class="language-python">class RawEntity(BaseModel):
    &quot;&quot;&quot;表示实体（用于实体解析）的模型。&quot;&quot;&quot;

    entity_idx: int
    name: str
    type: str = &quot;&quot;
    description: str = &quot;&quot;
</code></pre>

<h4 id="_24">实体</h4>
<p><code>Entity</code> 模型通过包含唯一标识符并可选地将每个实体链接到特定事件来扩展 <code>RawEntity</code>。
此外，它包含 <code>resolved_id</code>，将在实体解析期间使用规范实体的 id 填充，以消除数据库中重复的实体命名。
这些更新的标识符有助于实体与事件和三元组的集成和链接。</p>
<pre class="codehilite"><code class="language-python">class Entity(BaseModel):
    &quot;&quot;&quot;
    表示实体（用于实体解析）的模型。
    如果这是规范实体，则“id”是规范实体 id。
    如果这是别名，则“resolved_id”设置为规范 id。
    &quot;&quot;&quot;

    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    event_id: uuid.UUID | None = None
    name: str
    type: str
    description: str
    resolved_id: uuid.UUID | None = None

    @classmethod
    def from_raw(cls, raw_entity: &quot;RawEntity&quot;, event_id: uuid.UUID | None = None) -&gt; &quot;Entity&quot;:
        &quot;&quot;&quot;从 RawEntity 创建 Entity 实例，可选地将其与 event_id 关联。&quot;&quot;&quot;
        return cls(
            id=uuid.uuid4(),
            event_id=event_id,
            name=raw_entity.name,
            type=raw_entity.type,
            description=raw_entity.description,
            resolved_id=None,
        )
</code></pre>

<h4 id="_25">原始提取</h4>
<p><code>RawTriplet</code> 和 <code>RawEntity</code> 在每个 <code>Statement</code> 中同时提取，以减少 LLM 调用并方便通过三元组引用实体。</p>
<pre class="codehilite"><code class="language-python">class RawExtraction(BaseModel):
    &quot;&quot;&quot;表示三元组提取的模型。&quot;&quot;&quot;

    triplets: list[RawTriplet]
    entities: list[RawEntity]
</code></pre>

<h4 id="_26">三元组提取提示</h4>
<p>下面的提示指导我们的时间代理有效地从提供的语句中提取三元组和实体。</p>
<h5 id="_27">提示的结构</h5>
<ul style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>避免时间细节</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      代理被特别指示忽略时间关系，因为这些关系已在 `TemporalValidityRange` 中单独捕获。
      定义的 `Predicates` 被故意设计为时间中性的——例如，`HAS_A` 同时涵盖现在（`HAS_A`）和过去（`HAD_A`）的上下文。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>维护结构化输出</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      提示产生结构化的 `RawExtraction` 输出，并附有详细示例，这些示例清楚地说明了：
    </p>
    <ul style="margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em;">
      <li>如何从给定的 `Statement` 中提取信息</li>
      <li>如何将 `Entities` 与相应的 `Triplets` 链接</li>
      <li>如何处理提取的 `values`</li>
      <li>如何管理多个涉及同一 `Entity` 的 `Triplets`</li>
    </ul>
  </li>
</ul>

<pre class="codehilite"><code class="language-python">triplet_extraction_prompt = &quot;&quot;&quot;
您是一位信息提取助手。

**任务：** 您将获得一个语句。请按步骤遵循指南。

**语句：**“{{ statement }}”

**指南**
首先，NER：

- 识别语句中的实体、它们的类型以及与上下文无关的描述。
- 不要包含报告中的任何长引号
- 不要包含任何日历日期或时间范围或时间表达式
- 数值应提取为 _Numeric_ 实例，其中名称是单位字符串，numeric_value 是值。例如：£30 -&gt; name: 'GBP', numeric_value: 30, instance_of: 'Numeric'

其次，三元组提取：

- 识别该谓词的主语实体——执行操作或被描述的主要实体。
- 识别该谓词的宾语实体——谓词影响或描述的实体、值或概念。
- 识别语句中表达的实体之间的谓词，例如“是”、“在...工作”、“相信”等。如果给定，请遵循下面的模式。
- 提取相应的（主语、谓词、宾语、日期）知识三元组。
- 从所有字段中排除所有时间表达式（日期、年份、季节等）。
- 直到从语句中提取了所有谓词。

{%- if predicate_instructions -%}
-------------------------------------------------------------------------
谓词说明：
请尽量遵循以下谓词，除非找不到相关定义，否则不要偏离。
{%- for pred, instruction in predicate_instructions.items() -%}

- {{ pred }}: {{ instruction }}
{%- endfor -%}
-------------------------------------------------------------------------
{%- endif -%}

输出：
请按照下面的 JSON 模式列出实体和三元组。仅返回匹配此模式的有效 JSON。
不要包含任何评论或解释。
{{ json_schema }}

===示例===
示例 1 语句：“Google 的收入在 1 月至 3 月期间增长了 10%。”
示例 1 输出： {
  &quot;triplets&quot;: [
    {
      &quot;subject_name&quot;: &quot;Google&quot;,
      &quot;subject_id&quot;: 0,
      &quot;predicate&quot;: &quot;INCREASED&quot;,
      &quot;object_name&quot;: &quot;Revenue&quot;,
      &quot;object_id&quot;: 1,
      &quot;value&quot;: &quot;10%&quot;,
    }
  ],
  &quot;entities&quot;: [
    {
      &quot;entity_idx&quot;: 0,
      &quot;name&quot;: &quot;Google&quot;,
      &quot;type&quot;: &quot;Organization&quot;,
      &quot;description&quot;: &quot;Technology Company&quot;,
    },
    {
      &quot;entity_idx&quot;: 1,
      &quot;name&quot;: &quot;Revenue&quot;,
      &quot;type&quot;: &quot;Financial Metric&quot;,
      &quot;description&quot;: &quot;Income of a Company&quot;,
    }
  ]
}

示例 2 语句：“亚马逊在 2024 年开发了一款新的人工智能芯片。”
示例 2 输出：
{
  &quot;triplets&quot;: [
    {
      &quot;subject_name&quot;: &quot;Amazon&quot;,
      &quot;subject_id&quot;: 0,
      &quot;predicate&quot;: &quot;DEVELOPED&quot;,
      &quot;object_name&quot;: &quot;AI chip&quot;,
      &quot;object_id&quot;: 1,
      &quot;value&quot;: None,
    },
  ],
  &quot;entities&quot;: [
    {
      &quot;entity_idx&quot;: 0,
      &quot;name&quot;: &quot;Amazon&quot;,
      &quot;type&quot;: &quot;Organization&quot;,
      &quot;description&quot;: &quot;E-commerce and cloud computing company&quot;
    },
    {
      &quot;entity_idx&quot;: 1,
      &quot;name&quot;: &quot;AI chip&quot;,
      &quot;type&quot;: &quot;Technology&quot;,
      &quot;description&quot;: &quot;Artificial intelligence accelerator hardware&quot;
    }
  ]
}

示例 3 语句：“预计 TechNova 公司将于 2025 年第三季度推出其人工智能驱动的产品线。”
示例 3 输出：{
  &quot;triplets&quot;: [
    {
      &quot;subject_name&quot;: &quot;TechNova&quot;,
      &quot;subject_id&quot;: 0,
      &quot;predicate&quot;: &quot;LAUNCHED&quot;,
      &quot;object_name&quot;: &quot;AI-driven Product&quot;,
      &quot;object_id&quot;: 1,
      &quot;value&quot;: &quot;None,
    }
  ],
  &quot;entities&quot;: [
    {
      &quot;entity_idx&quot;: 0,
      &quot;name&quot;: &quot;TechNova&quot;,
      &quot;type&quot;: &quot;Organization&quot;,
      &quot;description&quot;: &quot;Technology Company&quot;,
    },
    {
      &quot;entity_idx&quot;: 1,
      &quot;name&quot;: &quot;AI-driven Product&quot;,
      &quot;type&quot;: &quot;Product&quot;,
      &quot;description&quot;: &quot;General AI products&quot;,
    }
  ]
}

示例 4 语句：“AMD 的 SVP、CFO 和财务主管在财报电话会议上发表了讲话。”
示例 4 输出： {
  &quot;triplets&quot;: [],
  &quot;entities&quot;:[].
}

===示例结束===
&quot;&quot;&quot;
</code></pre>

<h3 id="327">3.2.7. 时间事件</h3>
<p><code>TemporalEvent</code> 模型将 <code>Statement</code> 和所有相关信息整合到一个方便的类中。它是 <code>TemporalAgent</code> 的主要输出，并在 <code>InvalidationAgent</code> 中起着重要作用。</p>
<p>主要字段包括：</p>
<ul>
<li><code>id</code>：事件的唯一标识符</li>
<li><code>chunk_id</code>：指向与事件关联的特定 <code>Chunk</code></li>
<li><code>statement</code>：从 <code>Chunk</code> 中提取的特定 <code>RawStatement</code>，详细说明关系或事件</li>
<li><code>embedding</code>：<code>statement</code> 的表示，由 <code>InvalidationAgent</code> 用于评估事件相似性</li>
<li><code>triplets</code>：从 <code>Statement</code> 中提取的单个 <code>Triplet</code> 的唯一标识符</li>
<li><code>valid_at</code>：指示事件何时有效的日期时间戳</li>
<li><code>invalid_at</code>：指示事件何时无效的日期时间戳</li>
<li><code>temporal_type</code>：描述来自 <code>RawStatement</code> 的时间特征</li>
<li><code>statement_type</code>：根据原始 <code>RawStatement</code> 对语句进行分类</li>
<li><code>created_at</code>：首次创建事件的日期。</li>
<li><code>expired_at</code>：标记事件无效的日期（如果在构建 <code>TemporalEvent</code> 时已设置 <code>invalid_at</code>，则设置为 <code>created_at</code>）</li>
<li><code>invalidated_by</code>：负责使此事件无效的 <code>TemporalEvent</code> 的 ID（如果适用）</li>
</ul>
<pre class="codehilite"><code class="language-python">import json

from pydantic import model_validator


class TemporalEvent(BaseModel):
    &quot;&quot;&quot;表示带有语句、三元组和有效性信息的事件的模型。&quot;&quot;&quot;

    id: uuid.UUID = Field(default_factory=uuid.uuid4)
    chunk_id: uuid.UUID
    statement: str
    embedding: list[float] = Field(default_factory=lambda: [0.0] * 256)
    triplets: list[uuid.UUID]
    valid_at: datetime | None = None
    invalid_at: datetime | None = None
    temporal_type: TemporalType
    statement_type: StatementType
    created_at: datetime = Field(default_factory=datetime.now)
    expired_at: datetime | None = None
    invalidated_by: uuid.UUID | None = None

    @property
    def triplets_json(self) -&gt; str:
        &quot;&quot;&quot;将三元组列表转换为 JSON 字符串。&quot;&quot;&quot;
        return json.dumps([str(t) for t in self.triplets]) if self.triplets else &quot;[]&quot;

    @classmethod
    def parse_triplets_json(cls, triplets_str: str) -&gt; list[uuid.UUID]:
        &quot;&quot;&quot;将 JSON 字符串解析回 UUID 列表。&quot;&quot;&quot;
        if not triplets_str or triplets_str == &quot;[]&quot;:
            return []
        return [uuid.UUID(t) for t in json.loads(triplets_str)]

    @model_validator(mode=&quot;after&quot;)
    def set_expired_at(self) -&gt; &quot;TemporalEvent&quot;:
        &quot;&quot;&quot;如果设置了 invalid_at 且 temporal_type 为 DYNAMIC，则设置 expired_at。&quot;&quot;&quot;
        self.expired_at = self.created_at if (self.invalid_at is not None) and (self.temporal_type == TemporalType.DYNAMIC) else None
        return self
</code></pre>

<h3 id="328">3.2.8. 定义时间代理</h3>
<p>现在我们到达了管道的一个中心点：<code>TemporalAgent</code> 类。它将我们上面建立的步骤整合在一起——分块、数据模型和提示。让我们仔细看看它是如何工作的。</p>
<p>核心函数 <code>extract_transcript_events</code> 处理所有关键流程：</p>
<ol>
<li>它从每个 <code>Chunk</code> 中提取 <code>RawStatement</code>。</li>
<li>从每个 <code>RawStatement</code> 中，它识别 <code>TemporalValidityRange</code> 以及相关的 <code>Triplet</code> 和 <code>Entity</code> 对象列表。</li>
<li>最后，它将所有这些信息整齐地打包成每个 <code>RawStatement</code> 的 <code>TemporalEvent</code>。</li>
</ol>
<p>这是您将获得的内容：</p>
<ul>
<li><code>transcript</code>：当前正在分析的转录稿。</li>
<li><code>all_events</code>：所有生成的 <code>TemporalEvent</code> 对象的综合列表。</li>
<li><code>all_triplets</code>：所有事件中提取的 <code>Triplet</code> 对象的完整集合。</li>
<li><code>all_entities</code>：从事件中提取的所有 <code>Entity</code> 对象的详细列表，这些对象将在后续步骤中进一步细化。</li>
</ul>
<p>下图可视化了我们管道的这一部分：</p>
<!-- ![Screenshot 2025-06-23 at 12.10.06.png](temporal_agents_with_knowledge_graphs_files/79ba1c3c-35e6-406a-aff4-24ab9b8fe9e4.png) -->
<p><img
  src="../../../images/07_temporal_agent_class.png"
  alt="时间代理类"
  style="width:791px; height:auto;"
/></p>
<pre class="codehilite"><code class="language-python">import asyncio
from typing import Any

from jinja2 import DictLoader, Environment
from openai import AsyncOpenAI
from tenacity import retry, stop_after_attempt, wait_random_exponential


class TemporalAgent:
    &quot;&quot;&quot;处理用于从文本中提取和处理时间事件的时间相关操作。&quot;&quot;&quot;

    def __init__(self) -&gt; None:
        &quot;&quot;&quot;使用客户端初始化 TemporalAgent。&quot;&quot;&quot;
        self._client = AsyncOpenAI()
        self._model = &quot;gpt-4.1-mini&quot;

        self._env = Environment(loader=DictLoader({
            &quot;statement_extraction.jinja&quot;: statement_extraction_prompt,
            &quot;date_extraction.jinja&quot;: date_extraction_prompt,
            &quot;triplet_extraction.jinja&quot;: triplet_extraction_prompt,
        }))
        self._env.filters[&quot;split_and_capitalize&quot;] = self.split_and_capitalize
    @staticmethod
    def split_and_capitalize(value: str) -&gt; str:
        &quot;&quot;&quot;分割字典键字符串并重新格式化为 jinja 提示。&quot;&quot;&quot;
        return &quot; &quot;.join(value.split(&quot;_&quot;)).capitalize()

    async def get_statement_embedding(self, statement: str) -&gt; list[float]:
        &quot;&quot;&quot;获取语句的嵌入。&quot;&quot;&quot;
        response = await self._client.embeddings.create(
            model=&quot;text-embedding-3-large&quot;,
            input=statement,
            dimensions=256,
        )
        return response.data[0].embedding

    @retry(wait=wait_random_exponential(multiplier=1, min=1, max=30), stop=stop_after_attempt(3))
    async def extract_statements(
        self,
        chunk: Chunk,
        inputs: dict[str, Any],
    ) -&gt; RawStatementList:
        &quot;&quot;&quot;确定语句的初始有效日期范围。

        Args:
            chunk (Chunk): 要分析的文本块。
            inputs (dict[str, Any]): 用于提取的附加输入参数。

        Returns:
            Statement: 更新了时间范围的语句。
        &quot;&quot;&quot;
        inputs[&quot;chunk&quot;] = chunk.text

        template = self._env.get_template(&quot;statement_extraction.jinja&quot;)
        prompt = template.render(
            inputs=inputs,
            definitions=LABEL_DEFINITIONS,
            json_schema=RawStatementList.model_fields,
        )

        response = await self._client.responses.parse(
                model=self._model,
                temperature=0,
                input=prompt,
                text_format=RawStatementList,
            )


        raw_statements = response.output_parsed
        statements = RawStatementList.model_validate(raw_statements)
        return statements

    @retry(wait=wait_random_exponential(multiplier=1, min=1, max=30), stop=stop_after_attempt(3))
    async def extract_temporal_range(
        self,
        statement: RawStatement,
        ref_dates: dict[str, Any],
    ) -&gt; TemporalValidityRange:
        &quot;&quot;&quot;确定语句的初始有效日期范围。

        Args:
            statement (Statement): 要分析的语句。
            ref_dates (dict[str, Any]): 语句的参考日期。

        Returns:
            Statement: 更新了时间范围的语句。
        &quot;&quot;&quot;
        if statement.temporal_type == TemporalType.ATEMPORAL:
            return TemporalValidityRange(valid_at=None, invalid_at=None)

        template = self._env.get_template(&quot;date_extraction.jinja&quot;)
        inputs = ref_dates | statement.model_dump()

        prompt = template.render(
            inputs=inputs,
            temporal_guide={statement.temporal_type.value: LABEL_DEFINITIONS[&quot;temporal_labelling&quot;][statement.temporal_type.value]},
            statement_guide={statement.statement_type.value: LABEL_DEFINITIONS[&quot;episode_labelling&quot;][statement.statement_type.value]},
            json_schema=RawTemporalRange.model_fields,
        )

        response = await self._client.responses.parse(
                model=self._model,
                temperature=0,
                input=prompt,
                text_format=RawTemporalRange,
            )

        raw_validity = response.output_parsed
        temp_validity = TemporalValidityRange.model_validate(raw_validity.model_dump()) if raw_validity else TemporalValidityRange()

        if temp_validity.valid_at is None:
            temp_validity.valid_at = inputs[&quot;publication_date&quot;]
        if statement.temporal_type == TemporalType.STATIC:
            temp_validity.invalid_at = None

        return temp_validity

    @retry(wait=wait_random_exponential(multiplier=1, min=1, max=30), stop=stop_after_attempt(3))
    async def extract_triplet(
        self,
        statement: RawStatement,
        max_retries: int = 3,
    ) -&gt; RawExtraction:
        &quot;&quot;&quot;从语句中提取三元组和实体作为 RawExtraction 对象。&quot;&quot;&quot;
        template = self._env.get_template(&quot;triplet_extraction.jinja&quot;)
        prompt = template.render(
            statement=statement.statement,
            json_schema=RawExtraction.model_fields,
            predicate_instructions=PREDICATE_DEFINITIONS,
        )

        for attempt in range(max_retries):
            try:
                response = await self._client.responses.parse(
                        model=self._model,
                        temperature=0,
                        input=prompt,
                        text_format=RawExtraction,
                    )
                raw_extraction = response.output_parsed
                extraction = RawExtraction.model_validate(raw_extraction)
                return extraction
            except Exception as e:
                if attempt == max_retries - 1:
                    raise
                print(f&quot;尝试 {attempt + 1} 失败，错误：{str(e)}。正在重试...&quot;)
                await asyncio.sleep(1)

        raise Exception(&quot;所有重试尝试均未能提取三元组&quot;)

    async def extract_transcript_events(
        self,
        transcript: Transcript,
    ) -&gt; tuple[Transcript, list[TemporalEvent], list[Triplet], list[Entity]]:
        &quot;&quot;&quot;
        对于转录稿中的每个块：

            - 提取语句
            - 对于每个语句，并行提取时间范围和提取结果
            - 为每个语句构建 TemporalEvent
            - 收集所有事件、三元组和实体以供后续数据库插入
        返回转录稿、所有事件、所有三元组和所有实体。
        &quot;&quot;&quot;
        if not transcript.chunks:
            return transcript, [], [], []
        doc_summary = {
            &quot;main_entity&quot;: transcript.company or None,
            &quot;document_type&quot;: &quot;Earnings Call Transcript&quot;,
            &quot;publication_date&quot;: transcript.date,
            &quot;quarter&quot;: transcript.quarter,
            &quot;document_chunk&quot;: None,
        }
        all_events: list[TemporalEvent] = []
        all_triplets: list[Triplet] = []
        all_entities: list[Entity] = []

        async def _process_chunk(chunk: Chunk) -&gt; tuple[Chunk, list[TemporalEvent], list[Triplet], list[Entity]]:
            statements_list = await self.extract_statements(chunk, doc_summary)
            events: list[TemporalEvent] = []
            chunk_triplets: list[Triplet] = []
            chunk_entities: list[Entity] = []

            async def _process_statement(statement: RawStatement) -&gt; tuple[TemporalEvent, list[Triplet], list[Entity]]:
                temporal_range_task = self.extract_temporal_range(statement, doc_summary)
                extraction_task = self.extract_triplet(statement)
                temporal_range, raw_extraction = await asyncio.gather(temporal_range_task, extraction_task)
                # 首先创建事件以获取其 id
                embedding = await self.get_statement_embedding(statement.statement)
                event = TemporalEvent(
                    chunk_id=chunk.id,
                    statement=statement.statement,
                    embedding=embedding,
                    triplets=[],
                    valid_at=temporal_range.valid_at,
                    invalid_at=temporal_range.invalid_at,
                    temporal_type=statement.temporal_type,
                    statement_type=statement.statement_type,
                )
                # 将原始三元组/实体映射到带有 event_id 的 Triplet/Entity
                triplets = [Triplet.from_raw(rt, event.id) for rt in raw_extraction.triplets]
                entities = [Entity.from_raw(re, event.id) for re in raw_extraction.entities]
                event.triplets = [triplet.id for triplet in triplets]
                return event, triplets, entities

            if statements_list.statements:
                results = await asyncio.gather(*(_process_statement(stmt) for stmt in statements_list.statements))
                for event, triplets, entities in results:
                    events.append(event)
                    chunk_triplets.extend(triplets)
                    chunk_entities.extend(entities)
            return chunk, events, chunk_triplets, chunk_entities

        chunk_results = await asyncio.gather(*(_process_chunk(chunk) for chunk in transcript.chunks))
        transcript.chunks = [chunk for chunk, _, _, _ in chunk_results]
        for _, events, triplets, entities in chunk_results:
            all_events.extend(events)
            all_triplets.extend(triplets)
            all_entities.extend(entities)
        return transcript, all_events, all_triplets, all_entities
</code></pre>

<pre class="codehilite"><code class="language-python">temporal_agent = TemporalAgent()
# transcripts: list[Transcript] = chunker.generate_transcripts_and_chunks(dataset)

# 只处理第一个转录稿
results = await temporal_agent.extract_transcript_events(transcripts[0])
</code></pre>

<pre class="codehilite"><code class="language-python"># 解析并以良好格式显示结果
transcript, events, triplets, entities = results

print(&quot;=== 转录稿处理结果 ===\n&quot;)

print(f&quot;📄 转录稿 ID: {transcript.id}&quot;)
print(f&quot;📊 总块数： {len(transcript.chunks) if transcript.chunks is not None else 0}&quot;)
print(f&quot;🎯 总事件数： {len(events)}&quot;)
print(f&quot;🔗 总三元组数： {len(triplets)}&quot;)
print(f&quot;🏷️  总实体数： {len(entities)}&quot;)

print(&quot;\n=== 示例事件 ===&quot;)
for i, event in enumerate(events[:3]):  # 显示前 3 个事件
    print(f&quot;\n📝 事件 {i+1}:&quot;)
    print(f&quot;   语句： {event.statement[:100]}...&quot;)
    print(f&quot;   类型： {event.temporal_type}&quot;)
    print(f&quot;   有效时间： {event.valid_at}&quot;)
    print(f&quot;   三元组数： {len(event.triplets)}&quot;)

print(&quot;\n=== 示例三元组 ===&quot;)
for i, triplet in enumerate(triplets[:5]):  # 显示前 5 个三元组
    print(f&quot;\n🔗 三元组 {i+1}:&quot;)
    print(f&quot;   主语： {triplet.subject_name} (ID: {triplet.subject_id})&quot;)
    print(f&quot;   谓词： {triplet.predicate}&quot;)
    print(f&quot;   宾语： {triplet.object_name} (ID: {triplet.object_id})&quot;)
    if triplet.value:
        print(f&quot;   值： {triplet.value}&quot;)

print(&quot;\n=== 示例实体 ===&quot;)
for i, entity in enumerate(entities[:5]):  # 显示前 5 个实体
    print(f&quot;\n🏷️  实体 {i+1}:&quot;)
    print(f&quot;   名称： {entity.name}&quot;)
    print(f&quot;   类型： {entity.type}&quot;)
    print(f&quot;   描述： {entity.description}&quot;)
    if entity.resolved_id:
        print(f&quot;   解析 ID： {entity.resolved_id}&quot;)
</code></pre>

<h3 id="329">3.2.9. 实体解析</h3>
<p>在深入研究时间无效性之前，我们需要先解决实体解析问题。此过程至关重要，可确保每个现实世界的实体都有一个唯一的、权威的表示，从而消除重复并保持数据一致性。例如，<code>AMD</code> 和 <code>Advanced Micro Devices</code> 显然指的是同一个实体，因此它们应该在统一的规范实体下表示。</p>
<p>这是我们进行实体解析的方法：</p>
<ul>
<li>
<p>我们使用 <code>EntityResolution</code> 类按类型（<code>Entity.type</code>）对实体进行批处理，这有助于我们进行特定于上下文的比较——例如区分公司与个人。</p>
</li>
<li>
<p>为了有效处理嘈杂的数据，我们利用 <a href="https://rapidfuzz.github.io/RapidFuzz/">RapidFuzz</a> 基于名称相似性对实体进行聚类。此方法涉及简单的、不区分大小写、无标点的比较，使用部分匹配比率，允许对细微的键入错误和子字符串匹配进行容忍。</p>
</li>
<li>
<p>在每个模糊匹配的集群中，我们选择中位数——基于整体相似性，该实体最能代表集群。然后，中位数充当初始规范实体，为组提供语义上有意义的表示。</p>
</li>
<li>
<p>在添加新的规范实体之前，我们会将中位数与现有规范进行交叉检查，同时考虑模糊匹配和缩略语。例如，<code>Advanced Micro Devices Inc.</code> 可能会产生 <code>AMDI</code>，这与缩略语 <code>AMD</code> 非常匹配。此步骤有助于防止不必要地创建重复的规范实体。</p>
</li>
<li>
<p>如果未找到全局匹配，则中位数将成为新的规范实体，并且集群中的所有实体都通过解析 ID 与其链接。</p>
</li>
<li>
<p>最后，我们执行额外的安全检查，以跨所有规范实体解析潜在的缩略语重复，确保彻底清理。</p>
</li>
</ul>
<p>为了进一步增强实体解析，您可以考虑高级技术，例如：</p>
<ul>
<li>在 <code>Entity.description</code> 和 <code>Entity.name</code> 上使用基于嵌入的相似性，从而超越简单的文本相似性进行消歧。</li>
<li>采用大型语言模型（LLM）来智能地将实体分组到其规范形式下，通过语义理解提高准确性。</li>
</ul>
<pre class="codehilite"><code class="language-python">import sqlite3
import string

from rapidfuzz import fuzz

from db_interface import (
    get_all_canonical_entities,
    insert_canonical_entity,
    remove_entity,
    update_entity_references,
)


class EntityResolution:
    &quot;&quot;&quot;
    实体解析类。
    &quot;&quot;&quot;

    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self.global_canonicals: list[Entity] = get_all_canonical_entities(conn)
        self.threshold = 80.0
        self.acronym_thresh = 98.0


    def resolve_entities_batch(
        self, batch_entities: list[Entity],
     ) -&gt; None:
        &quot;&quot;&quot;
        为一批实体编排可扩展的实体解析工作流程。
        &quot;&quot;&quot;
        type_groups = {t: [e for e in batch_entities if e.type == t] for t in set(e.type for e in batch_entities)}

        for entities in type_groups.values():
            clusters = self.group_entities_by_fuzzy_match(entities)

            for group in clusters.values():
                if not group:
                    continue
                local_canon = self.set_medoid_as_canonical_entity(group)
                if local_canon is None:
                    continue

                match = self.match_to_canonical_entity(local_canon, self.global_canonicals)
                if &quot; &quot; in local_canon.name:  # 多词实体
                    acronym = &quot;&quot;.join(word[0] for word in local_canon.name.split())
                    acronym_match = next(
                        (c for c in self.global_canonicals if fuzz.ratio(acronym, c.name) &gt;= self.acronym_thresh and &quot; &quot; not in c.name), None
                    )
                    if acronym_match:
                        match = acronym_match

                if match:
                    canonical_id = match.id
                else:
                    insert_canonical_entity(
                        self.conn,
                        {
                            &quot;id&quot;: str(local_canon.id),
                            &quot;name&quot;: local_canon.name,
                            &quot;type&quot;: local_canon.type,
                            &quot;description&quot;: local_canon.description,
                        },
                    )
                    canonical_id = local_canon.id
                    self.global_canonicals.append(local_canon)

                for entity in group:
                    entity.resolved_id = canonical_id
                    self.conn.execute(
                        &quot;UPDATE entities SET resolved_id = ? WHERE id = ?&quot;,
                        (str(canonical_id), str(entity.id))
                    )

        # 处理完所有实体后清理任何缩略语重复项
        self.merge_acronym_canonicals()


    def group_entities_by_fuzzy_match(
            self, entities: list[Entity],
     ) -&gt; dict[str, list[Entity]]:
        &quot;&quot;&quot;
        使用 rapidfuzz 的 partial_ratio 按名称相似性对实体进行模糊匹配分组。
        返回从规范名称到分组实体列表的映射。
        &quot;&quot;&quot;
        def clean(name: str) -&gt; str:
            return name.lower().strip().translate(str.maketrans(&quot;&quot;, &quot;&quot;, string.punctuation))

        name_to_entities: dict[str, list[Entity]] = {}
        cleaned_name_map: dict[str, str] = {}
        for entity in entities:
            name_to_entities.setdefault(entity.name, []).append(entity)
            cleaned_name_map[entity.name] = clean(entity.name)
        unique_names = list(name_to_entities.keys())

        clustered: dict[str, list[Entity]] = {}
        used = set()
        for name in unique_names:
            if name in used:
                continue
            clustered[name] = []
            for other_name in unique_names:
                if other_name in used:
                    continue
                score = fuzz.partial_ratio(cleaned_name_map[name], cleaned_name_map[other_name])
                if score &gt;= self.threshold:
                    clustered[name].extend(name_to_entities[other_name])
                    used.add(other_name)
        return clustered


    def set_medoid_as_canonical_entity(self, entities: list[Entity]) -&gt; Entity | None:
        &quot;&quot;&quot;
        选择组中与所有其他实体具有最高总相似度（partial_ratio 总和）的实体作为规范实体。
        返回中位数实体，如果组为空则返回 None。
        &quot;&quot;&quot;
        if not entities:
            return None

        def clean(name: str) -&gt; str:
            return name.lower().strip().translate(str.maketrans(&quot;&quot;, &quot;&quot;, string.punctuation))

        n = len(entities)
        scores = [0.0] * n
        for i in range(n):
            for j in range(n):
                if i != j:
                    s1 = clean(entities[i].name)
                    s2 = clean(entities[j].name)
                    scores[i] += fuzz.partial_ratio(s1, s2)
        max_idx = max(range(n), key=lambda idx: scores[idx])
        return entities[max_idx]


    def match_to_canonical_entity(self, entity: Entity, canonical_entities: list[Entity]) -&gt; Entity | None:
        &quot;&quot;&quot;
        将单个实体模糊匹配到规范实体列表。
        如果分数低于 self.threshold 则返回最佳匹配的规范实体或 None。
        &quot;&quot;&quot;
        def clean(name: str) -&gt; str:
            return name.lower().strip().translate(str.maketrans(&quot;&quot;, &quot;&quot;, string.punctuation))

        best_score: float = 0
        best_canon = None
        for canon in canonical_entities:
            score = fuzz.partial_ratio(clean(entity.name), clean(canon.name))
            if score &gt; best_score:
                best_score = score
                best_canon = canon
        if best_score &gt;= self.threshold:
            return best_canon
        return None


    def merge_acronym_canonicals(self) -&gt; None:
        &quot;&quot;&quot;
        合并一个规范实体是另一个规范实体缩略语的情况。
        &quot;&quot;&quot;
        multi_word = [e for e in self.global_canonicals if &quot; &quot; in e.name]
        single_word = [e for e in self.global_canonicals if &quot; &quot; not in e.name]

        acronym_map = {}
        for entity in multi_word:
            acronym = &quot;&quot;.join(word[0].upper() for word in entity.name.split())
            acronym_map[entity.id] = acronym

        for entity in multi_word:
            acronym = acronym_map[entity.id]
            for single_entity in single_word:
                score = fuzz.ratio(acronym, single_entity.name)
                if score &gt;= self.threshold:
                    update_entity_references(self.conn, str(entity.id), str(single_entity.id))
                    remove_entity(self.conn, str(entity.id))
                    self.global_canonicals.remove(entity)
                    break
</code></pre>

<h3 id="3210">3.2.10. 无效代理</h3>
<h5 id="_28">理解无效过程</h5>
<p>为了有效地使时间事件失效，代理会进行双向检查：</p>
<blockquote>
<ol>
<li><strong>传入 vs. 现有</strong>：传入事件是否被已存在的事件无效化？</li>
<li><strong>现有 vs. 传入</strong>：当前事件是否被新传入的事件无效化？</li>
</ol>
</blockquote>
<p>这种双向评估会产生一个清晰的真/假决策。</p>
<h4 id="_29">事件无效提示</h4>
<p>提示有三个关键组成部分：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
<li style="margin-bottom: 1.2em;"><strong>任务设置</strong><br />
定义了两个事件比较的角色——<code>primary</code> 和 <code>secondary</code>。评估检查 <code>primary</code> 事件是否被 <code>secondary</code> 事件无效化。</li>

<li style="margin-bottom: 1.2em;"><strong>指南</strong><br />
提供了解释时间元数据的清晰标准。重要的是，无效化必须仅依赖于事件之间明确陈述的关系。外部信息不能影响决策。</li>

<li style="margin-bottom: 1.2em;"><strong>事件信息</strong><br />
两个事件（<code>primary</code> 和 <code>secondary</code>）都包含时间戳详细信息（<code>valid_at</code> 和 <code>invalid_at</code>）以及通过 <code>Statement</code>、<code>Triplet</code> 或两者兼有的语义上下文。此上下文确保了准确且相关的比较。</li>
</ol>

<pre class="codehilite"><code class="language-python">event_invalidation_prompt = &quot;&quot;&quot;
任务：将主要事件与次要事件进行比较，并确定主要事件是否被次要事件无效化。
仅在日期明确与文本中描述的关系有效性相关时才设置日期。

重要提示：仅当事件直接被给定上下文中的另一个事件无效化时才无效化事件。请勿使用任何外部知识来确定有效性范围。
仅使用直接陈述以无效化关系的日期。被无效化的事件的 invalid_at 应为导致无效化的事件的 valid_at。

无效指南：

1. 日期以 ISO 8601 格式（YYYY-MM-DDTHH:MM:SS.SSSSSSZ）给出。
2. invalid_at 为 null 时，表示该事件仍然有效且被视为正在进行中。
3. invalid_at 已定义时，表示该事件先前已被其他事件无效化，可以视为“已完成”。
4. 事件只能将已完成事件的 invalid_at 精炼为更早的日期。
5. 事件不能无效化在时间上发生在它之后的事件。
6. 事件不能被在时间上发生在它之前的事件无效化。
7. 事件不能无效化自身。

---
主要事件：
{% if primary_event -%}
语句： {{primary_event}}
{%- endif %}
{% if primary_triplet -%}
三元组： {{primary_triplet}}
{%- endif %}
有效时间： {{primary_event.valid_at}}
无效时间： {{primary_event.invalid_at}}
---
次要事件：
{% if secondary_event -%}
语句： {{secondary_event}}
{%- endif %}
{% if secondary_triplet -%}
三元组： {{secondary_triplet}}
{%- endif %}
有效时间： {{secondary_event.valid_at}}
无效时间： {{secondary_event.invalid_at}}
---

返回“True”表示主要事件被无效化或其 invalid_at 被精炼，否则返回“False”
&quot;&quot;&quot;
</code></pre>

<h4 id="_30">需要比较以进行无效化的要求</h4>
<p>我们只能无效化尚未被标记为无效的动态事实。这些事实是我们主要事件的来源，而潜在的无效化候选者是我们次要事件的来源。为了简化无效化过程，请在评估次要事件时考虑这些指南：</p>
<ol>
<li>必须是<em>事实</em>类型，而不是<em>非时间性</em></li>
<li>在三元组级别共享至少一个规范实体</li>
<li>在三元组级别属于同一语义谓词组（如下定义）</li>
<li>时间上重叠且当前正在进行中</li>
<li>语句余弦相似度高于阈值（当前设置为 0.5）</li>
<li>相似度阈值（0.5）有助于我们有效地过滤噪声，仅选择最相关的 top_k 个结果。低级别的语义相似性是可以接受的，因为我们的目标是精炼发送给 LLM 进行进一步评估的数据</li>
</ol>
<p>当发生无效化时，我们会用 <code>expired_at</code> 和 <code>invalidated_by</code> 来注释受影响的事件，以清楚地指示因果关系。</p>
<pre class="codehilite"><code class="language-python">PREDICATE_GROUPS: list[list[str]] = [
    [&quot;IS_A&quot;, &quot;HAS_A&quot;, &quot;LOCATED_IN&quot;, &quot;HOLDS_ROLE&quot;, &quot;PART_OF&quot;],
    [&quot;PRODUCES&quot;, &quot;SELLS&quot;, &quot;SUPPLIES&quot;, &quot;DISCONTINUED&quot;, &quot;SECURED&quot;],
    [&quot;LAUNCHED&quot;, &quot;DEVELOPED&quot;, &quot;ADOPTED_BY&quot;, &quot;INVESTS_IN&quot;, &quot;COLLABORATES_WITH&quot;],
    [&quot;HAS_REVENUE&quot;, &quot;INCREASED&quot;, &quot;DECREASED&quot;, &quot;RESULTED_IN&quot;, &quot;TARGETS&quot;],
]
</code></pre>

<p>当我们把所有这些放在一起时，我们的 <code>InvalidationAgent</code> 的工作流程如下所示：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>时间范围检测</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      我们首先使用 <code>get_incoming_temporal_bounds()</code> 来确定事件发生的时间。此函数检查事件的 <code>valid_at</code>，如果事件是动态的，则检查其 <code>invalid_at</code>。此处不包括非时间性事件。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>时间事件选择</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      我们使用 <code>select_events_temporally()</code> 来过滤事件，方法是：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>检查它们是静态的还是动态的。</li>
      <li>确定它们的时间范围是否与我们的传入事件重叠。</li>
      <li>仔细处理动态事件，特别是“正在进行中”的事件（没有 <code>invalid_at</code>）或具有各种重叠的事件。</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>嵌入相似性过滤</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      然后，<code>filter_by_embedding_similarity()</code> 根据语义相似性比较事件：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>计算嵌入之间的余弦相似度。</li>
      <li>低于相似度阈值（<code>_similarity_threshold = 0.5</code>）的事件将被过滤掉。</li>
      <li>我们只保留最相关的 top-K 个事件（<code>_top_k = 10</code>）。</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>结合时间和语义过滤器</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用 <code>select_temporally_relevant_events_for_invalidation()</code>，我们：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>首先应用时间过滤器。</li>
      <li>然后应用嵌入相似性过滤器。</li>
      <li>这将为我们提供最有可能与传入事件交互或冲突的事件的精炼列表。</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>事件无效决策（基于 LLM）</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      基于 LLM 的 <code>invalidation_step()</code>（由 GPT-4.1-mini 提供支持）确定传入事件是否无效化另一个事件：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>如果无效化，我们更新：
        <ul style="margin-left: 1.5em;">
          <li><code>invalid_at</code> 以匹配次要事件的 <code>valid_at</code>。</li>
          <li><code>expired_at</code> 为当前时间戳。</li>
          <li><code>invalidated_by</code> 为次要事件的 ID。</li>
        </ul>
      </li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>双向事件检查</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      我们使用 <code>bi_directional_event_invalidation()</code> 来检查：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>传入事件是否无效化现有事件。</li>
      <li>现有、较晚的事件是否无效化传入事件，特别是当传入事件是动态且当前有效时。</li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>去重逻辑</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      最后，<code>resolve_duplicate_invalidations()</code> 确保无效化干净利落：
    </p>
    <ul style="margin-left: 1.5em; margin-bottom: 0.5em;">
      <li>每个事件只允许一次无效化。</li>
      <li>选择最早的无效化时间以避免冲突。</li>
      <li>这有助于有效管理批量处理。</li>
    </ul>
  </li>
</ol>

<p>下面的无效化代表了我们管道的这一部分：</p>
<!-- ![Screenshot 2025-06-23 at 11.45.20.png](temporal_agents_with_knowledge_graphs_files/aa62bb3c-d497-4027-ac15-51649e4d9c4d.png) -->
<p><img
  src="../../../images/08_invalidation_agent.png"
  alt="无效代理"
  style="width:791px; height:auto;"
/></p>
<pre class="codehilite"><code class="language-python">import asyncio
import logging
import pickle
import sqlite3
from collections import Counter, defaultdict
from collections.abc import Coroutine
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from typing import Any

from jinja2 import DictLoader, Environment
from openai import AsyncOpenAI
from scipy.spatial.distance import cosine
from tenacity import retry, stop_after_attempt, wait_random_exponential


class InvalidationAgent:
    &quot;&quot;&quot;处理用于从文本中提取和处理时间事件的时间相关操作。&quot;&quot;&quot;

    def __init__(self, max_workers: int = 5) -&gt; None:
        &quot;&quot;&quot;使用客户端初始化 TemporalAgent。&quot;&quot;&quot;
        self.max_workers = max_workers
        self._executor = ThreadPoolExecutor(max_workers=max_workers)
        self.logger = logging.getLogger(__name__)
        self._client = AsyncOpenAI()
        self._model = &quot;gpt-4.1-mini&quot;
        self._similarity_threshold = 0.5
        self._top_k = 10

        self._env = Environment(loader=DictLoader({
            &quot;event_invalidation.jinja&quot;: event_invalidation_prompt,
        }))

    @staticmethod
    def cosine_similarity(v1: list[float], v2: list[float]) -&gt; float:
        &quot;&quot;&quot;计算两个向量之间的余弦相似度。&quot;&quot;&quot;
        return float(1 - cosine(v1, v2))

    @staticmethod
    def get_incoming_temporal_bounds(
        event: TemporalEvent,
    ) -&gt; dict[str, datetime] | None:
        &quot;&quot;&quot;获取与语句关联的所有时间事件的时间边界。&quot;&quot;&quot;
        if (event.temporal_type == TemporalType.ATEMPORAL) or (event.valid_at is None):
            return None

        temporal_bounds = {&quot;start&quot;: event.valid_at, &quot;end&quot;: event.valid_at}

        if event.temporal_type == TemporalType.DYNAMIC:
            if event.invalid_at:
                temporal_bounds[&quot;end&quot;] = event.invalid_at

        return temporal_bounds

    def select_events_temporally(
        self,
        triplet_events: list[tuple[Triplet, TemporalEvent]],
        temp_bounds: dict[str, datetime],
        dynamic: bool = False,
    ) -&gt; list[tuple[Triplet, TemporalEvent]]:
        &quot;&quot;&quot;根据时间边界选择时间相关的事件（静态或动态）。

        根据时间边界将事件分为之前、之后和重叠类别。

        Args:
            triplet_events: 要过滤的 (Triplet, TemporalEvent) 元组列表
            temp_bounds: 包含 'start' 和 'end' datetime 边界的字典
            dynamic: 如果为 True，则过滤动态事件；如果为 False，则过滤静态事件
            n_window: 要包含在边界之前和之后的事件数

        Returns:
            包含键 '{type}_before'、'{type}_after'、'{type}_overlap' 的字典，其中 type 为 'dynamic' 或 'static'
        &quot;&quot;&quot;

        def _check_overlaps_dynamic(event: TemporalEvent, start: datetime, end: datetime) -&gt; bool:
            &quot;&quot;&quot;检查动态事件是否与传入事件的时间边界重叠。&quot;&quot;&quot;
            if event.temporal_type != TemporalType.DYNAMIC:
                return False

            event_start = event.valid_at or datetime.min
            event_end = event.invalid_at

            # 1. 事件包含开始时间
            if (event_end is not None) and (event_start &lt;= start &lt;= event_end):
                return True

            # 2. 正在进行的事件在传入开始时间之前开始
            if (event_end is None) and (event_start &lt;= start):
                return True

            # 3. 事件在传入间隔内开始
            if start &lt;= event_start &lt;= end:
                return True
            return False

        # 按时间类型过滤
        target_type = TemporalType.DYNAMIC if dynamic else TemporalType.STATIC
        filtered_events = [(triplet, event) for triplet, event in triplet_events if event.temporal_type == target_type]

        # 按 valid_at 时间戳排序
        sorted_events = sorted(filtered_events, key=lambda te: te[1].valid_at or datetime.min)

        start = temp_bounds[&quot;start&quot;]
        end = temp_bounds[&quot;end&quot;]

        if dynamic:
            overlap: list[tuple[Triplet, TemporalEvent]] = [
                (triplet, event) for triplet, event in sorted_events if _check_overlaps_dynamic(event, start, end)
            ]
        else:
            overlap = []
            if start != end:
                overlap = [(triplet, event) for triplet, event in sorted_events if event.valid_at and start &lt;= event.valid_at &lt;= end]

        return overlap

    def filter_by_embedding_similarity(
        self,
        reference_event: TemporalEvent,
        candidate_pairs: list[tuple[Triplet, TemporalEvent]],
    ) -&gt; list[tuple[Triplet, TemporalEvent]]:
        &quot;&quot;&quot;按嵌入相似度过滤三元组-事件对。&quot;&quot;&quot;
        pairs_with_similarity = [
            (triplet, event, self.cosine_similarity(reference_event.embedding, event.embedding)) for triplet, event in candidate_pairs
        ]

        filtered_pairs = [
            (triplet, event) for triplet, event, similarity in pairs_with_similarity if similarity &gt;= self._similarity_threshold
        ]

        sorted_pairs = sorted(filtered_pairs, key=lambda x: self.cosine_similarity(reference_event.embedding, x[1].embedding), reverse=True)

        return sorted_pairs[: self._top_k]

    def select_temporally_relevant_events_for_invalidation(
        self,
        incoming_event: TemporalEvent,
        candidate_triplet_events: list[tuple[Triplet, TemporalEvent]],
    ) -&gt; list[tuple[Triplet, TemporalEvent]] | None:
        &quot;&quot;&quot;根据传入事件的时间范围选择时间相关的事件以进行无效化。&quot;&quot;&quot;
        temporal_bounds = self.get_incoming_temporal_bounds(event=incoming_event)
        if not temporal_bounds:
            return None

        # 首先应用时间过滤器 - 查找重叠事件
        selected_statics = self.select_events_temporally(
            triplet_events=candidate_triplet_events,
            temp_bounds=temporal_bounds,
        )
        selected_dynamics = self.select_events_temporally(
            triplet_events=candidate_triplet_events,
            temp_bounds=temporal_bounds,
            dynamic=True,
        )

        # 然后按语义相似度过滤
        similar_static = self.filter_by_embedding_similarity(reference_event=incoming_event, candidate_pairs=selected_statics)

        similar_dynamics = self.filter_by_embedding_similarity(reference_event=incoming_event, candidate_pairs=selected_dynamics)

        return similar_static + similar_dynamics


    @retry(wait=wait_random_exponential(multiplier=1, min=1, max=30), stop=stop_after_attempt(3))
    async def invalidation_step(
        self,
        primary_event: TemporalEvent,
        primary_triplet: Triplet,
        secondary_event: TemporalEvent,
        secondary_triplet: Triplet,
    ) -&gt; TemporalEvent:
        &quot;&quot;&quot;检查主要事件是否应被次要事件无效化。

        Args:
            primary_event: 可能被无效化的事件
            primary_triplet: 与主要事件关联的三元组
            secondary_event: 可能导致无效化的事件
            secondary_triplet: 与次要事件关联的三元组

        Returns:
            TemporalEvent: 更新后的主要事件（可能已设置 invalid_at 和 invalidated_by）
        &quot;&quot;&quot;
        template = self._env.get_template(&quot;event_invalidation.jinja&quot;)

        prompt = template.render(
            primary_event=primary_event.statement,
            primary_triplet=f&quot;({primary_triplet.subject_name}, {primary_triplet.predicate}, {primary_triplet.object_name})&quot;,
            primary_valid_at=primary_event.valid_at,
            primary_invalid_at=primary_event.invalid_at,
            secondary_event=secondary_event.statement,
            secondary_triplet=f&quot;({secondary_triplet.subject_name}, {secondary_triplet.predicate}, {secondary_triplet.object_name})&quot;,
            secondary_valid_at=secondary_event.valid_at,
            secondary_invalid_at=secondary_event.invalid_at,
        )

        response = await self._client.responses.parse(
                model=self._model,
                temperature=0,
                input=prompt,
            )

        # 解析布尔响应
        response_bool = str(response).strip().lower() == &quot;true&quot; if response else False

        if not response_bool:
            return primary_event

        # 创建带有无效化信息的更新事件
        updated_event = primary_event.model_copy(
            update={
                &quot;invalid_at&quot;: secondary_event.valid_at,
                &quot;expired_at&quot;: datetime.now(),
                &quot;invalidated_by&quot;: secondary_event.id,
            }
        )
        return updated_event

    async def bi_directional_event_invalidation(
        self,
        incoming_triplet: Triplet,
        incoming_event: TemporalEvent,
        existing_triplet_events: list[tuple[Triplet, TemporalEvent]],
    ) -&gt; tuple[TemporalEvent, list[TemporalEvent]]:
        &quot;&quot;&quot;使用完全双向无效化来验证和更新三元组事件的时间信息。

        Args:
            incoming_triplet: 要处理的新三元组
            incoming_event: 与三元组关联的新事件
            existing_triplet_events: 要验证的现有（三元组，事件）对列表

        Returns:
            tuple[TemporalEvent, list[TemporalEvent]]: (更新后的传入事件, 已更改的现有事件列表)
        &quot;&quot;&quot;
        changed_existing_events: list[TemporalEvent] = []
        updated_incoming_event = incoming_event

        # 过滤动态事件以进行无效化
        dynamic_events_to_check = [
            (triplet, event) for triplet, event in existing_triplet_events if event.temporal_type == TemporalType.DYNAMIC
        ]

        # 1. 检查传入事件是否无效化现有动态事件
        if dynamic_events_to_check:
            tasks = [
                self.invalidation_step(
                    primary_event=existing_event,
                    primary_triplet=existing_triplet,
                    secondary_event=incoming_event,
                    secondary_triplet=incoming_triplet,
                )
                for existing_triplet, existing_event in dynamic_events_to_check
            ]

            updated_events = await asyncio.gather(*tasks)

            for original_pair, updated_event in zip(dynamic_events_to_check, updated_events, strict=True):
                original_event = original_pair[1]
                if (updated_event.invalid_at != original_event.invalid_at) or (
                    updated_event.invalidated_by != original_event.invalidated_by
                ):
                    changed_existing_events.append(updated_event)

        # 2. 检查现有事件是否无效化传入动态事件
        if incoming_event.temporal_type == TemporalType.DYNAMIC and incoming_event.invalid_at is None:
            # 只检查发生在传入事件之后的事件
            invalidating_events = [
                (triplet, event)
                for triplet, event in existing_triplet_events
                if (incoming_event.valid_at and event.valid_at and incoming_event.valid_at &lt; event.valid_at)
            ]

            if invalidating_events:
                tasks = [
                    self.invalidation_step(
                        primary_event=incoming_event,
                        primary_triplet=incoming_triplet,
                        secondary_event=existing_event,
                        secondary_triplet=existing_triplet,
                    )
                    for existing_triplet, existing_event in invalidating_events
                ]

                updated_events = await asyncio.gather(*tasks)

                # 查找最早的无效化
                valid_invalidations = [(e.invalid_at, e.invalidated_by) for e in updated_events if e.invalid_at is not None]

                if valid_invalidations:
                    earliest_invalidation = min(valid_invalidations, key=lambda x: x[0])
                    updated_incoming_event = incoming_event.model_copy(
                        update={
                            &quot;invalid_at&quot;: earliest_invalidation[0],
                            &quot;invalidated_by&quot;: earliest_invalidation[1],
                            &quot;expired_at&quot;: datetime.now(),
                        }
                    )

        return updated_incoming_event, changed_existing_events

    @staticmethod
    def resolve_duplicate_invalidations(changed_events: list[TemporalEvent]) -&gt; list[TemporalEvent]:
        &quot;&quot;&quot;通过选择最严格（最早）的无效化来解决重复无效化。

        当多个传入事件无效化同一现有事件时，我们应应用
        导致最短有效范围（最早的 invalid_at）的无效化。

        Args:
            changed_events: 可能包含具有不同无效化信息的重复项的事件列表

        Returns:
            去重后的事件列表，应用了最严格的无效化
        &quot;&quot;&quot;
        if not changed_events:
            return []

        # 计算每个事件 ID 的出现次数
        id_counts = Counter(str(event.id) for event in changed_events)
        resolved_events = []
        # 仅对具有重复项的事件按 ID 进行分组
        events_by_id = defaultdict(list)
        for event in changed_events:
            event_id = str(event.id)
            if id_counts[event_id] == 1:
                resolved_events.append(event)
            else:
                events_by_id[event_id].append(event)

        # 仅对具有重复项的事件进行去重
        for _id, event_versions in events_by_id.items():
            invalidated_versions = [e for e in event_versions if e.invalid_at is not None]
            if not invalidated_versions:
                resolved_events.append(event_versions[0])
            else:
                most_restrictive = min(invalidated_versions, key=lambda e: (e.invalid_at if e.invalid_at is not None else datetime.max))
                resolved_events.append(most_restrictive)

        return resolved_events

    @staticmethod
    def batch_fetch_related_triplet_events(
        conn: sqlite3.Connection,
        incoming_triplets: list[Triplet],
    ) -&gt; tuple[list[Triplet], list[TemporalEvent]]:
        &quot;&quot;&quot;
        从数据库中批量获取所有与任何传入三元组相关的现有三元组及其事件。
        相关意味着：

          - 共享主语或宾语实体
          - 谓词属于同一组
          - 关联事件是 FACT
        返回两个列表：三元组和事件（通过 event_id 映射）。
        &quot;&quot;&quot;
        # 1. 构建所有相关实体 ID 和谓词组的集合
        entity_ids = set()
        predicate_to_group = {}
        for group in PREDICATE_GROUPS:
            group_list = list(group)
            for pred in group_list:
                predicate_to_group[pred] = group_list
        relevant_predicates = set()
        for triplet in incoming_triplets:
            entity_ids.add(str(triplet.subject_id))
            entity_ids.add(str(triplet.object_id))
            group = predicate_to_group.get(str(triplet.predicate), [])
            if group:
                relevant_predicates.update(group)

        # 2. 准备 SQL 查询
        entity_placeholders = &quot;,&quot;.join([&quot;?&quot;] * len(entity_ids))
        predicate_placeholders = &quot;,&quot;.join([&quot;?&quot;] * len(relevant_predicates))
        query = f&quot;&quot;&quot;
            SELECT
                t.id,
                t.subject_name,
                t.subject_id,
                t.predicate,
                t.object_name,
                t.object_id,
                t.value,
                t.event_id,
                e.chunk_id,
                e.statement,
                e.triplets,
                e.statement_type,
                e.temporal_type,
                e.valid_at,
                e.invalid_at,
                e.created_at,
                e.expired_at,
                e.invalidated_by,
                e.embedding
            FROM triplets t
            JOIN events e ON t.event_id = e.id
            WHERE
                (t.subject_id IN ({entity_placeholders}) OR t.object_id IN ({entity_placeholders}))
                AND t.predicate IN ({predicate_placeholders})
                AND e.statement_type = ?
        &quot;&quot;&quot;
        params = list(entity_ids) + list(entity_ids) + list(relevant_predicates) + [StatementType.FACT]
        cursor = conn.cursor()
        cursor.execute(query, params)
        rows = cursor.fetchall()

        triplets = []
        events = []
        events_by_id = {}
        for row in rows:
            triplet = Triplet(
                id=row[0],
                subject_name=row[1],
                subject_id=row[2],
                predicate=Predicate(row[3]),
                object_name=row[4],
                object_id=row[5],
                value=row[6],
                event_id=row[7],
            )
            event_id = row[7]
            triplets.append(triplet)
            if event_id not in events_by_id:
                events_by_id[event_id] = TemporalEvent(
                    id=row[7],
                    chunk_id=row[8],
                    statement=row[9],
                    triplets=TemporalEvent.parse_triplets_json(row[10]),
                    statement_type=row[11],
                    temporal_type=row[12],
                    valid_at=row[13],
                    invalid_at=row[14],
                    created_at=row[15],
                    expired_at=row[16],
                    invalidated_by=row[17],
                    embedding=pickle.loads(row[18]) if row[18] else [0] * 1536,
                )
        events = list(events_by_id.values())
        return triplets, events
</code></pre>

<p>我们可以创建一个用于无效化处理的批量处理函数，用于一组时间事件。在这里，我们过滤我们的语句为 FACT 类型，然后传递给无效化代理进行处理。</p>
<pre class="codehilite"><code class="language-python">async def batch_process_invalidation(
    conn: sqlite3.Connection, all_events: list[TemporalEvent], all_triplets: list[Triplet], invalidation_agent: InvalidationAgent
) -&gt; tuple[list[TemporalEvent], list[TemporalEvent]]:
    &quot;&quot;&quot;处理 FACT 事件的无效化，这些事件是时间性的。

    Args:
        conn: SQLite 数据库连接
        all_events: 所有提取的事件列表
        all_triplets: 所有提取的三元组列表
        invalidation_agent: 无效化代理实例

    Returns:
        tuple[list[TemporalEvent], list[TemporalEvent]]:

            - final_events: 所有事件（更新后的传入事件）
            - events_to_update: 需要数据库更新的现有事件
    &quot;&quot;&quot;
    def _get_fact_triplets(
        all_events: list[TemporalEvent],
        all_triplets: list[Triplet],
    ) -&gt; list[Triplet]:
        &quot;&quot;&quot;
        仅返回其关联事件为 FACT 类型且非 ATEMPORAL 的三元组。
        &quot;&quot;&quot;
        fact_event_ids = {
            event.id for event in all_events if (event.statement_type == StatementType.FACT) and (event.temporal_type != TemporalType.ATEMPORAL)
        }
        return [triplet for triplet in all_triplets if triplet.event_id in fact_event_ids]
    # 准备一个三元组列表，其关联事件是 FACT 且非 ATEMPORAL
    fact_triplets = _get_fact_triplets(all_events, all_triplets)
    if not fact_triplets:
        return all_events, []

    # 创建事件映射以快速查找
    all_events_map = {event.id: event for event in all_events}

    # 构建对齐的有效三元组及其对应事件的列表
    fact_events: list[TemporalEvent] = []
    valid_fact_triplets: list[Triplet] = []
    for triplet in fact_triplets:
        # 处理潜在的 None event_id 并确保类型安全
        if triplet.event_id is not None:
            event = all_events_map.get(triplet.event_id)
            if event:
                fact_events.append(event)
                valid_fact_triplets.append(triplet)
            else:
                print(f&quot;警告：找不到事件 {triplet.event_id} 对应的 fact_triplet&quot;)
        else:
            print(f&quot;警告：Fact 三元组 {triplet.id} 没有 event_id，跳过无效化&quot;)

    if not valid_fact_triplets:
        return all_events, []

    # 批量获取所有相关的现有三元组和事件
    existing_triplets, existing_events = invalidation_agent.batch_fetch_related_triplet_events(conn, valid_fact_triplets)

    # 并行处理所有无效化
    updated_incoming_fact_events, changed_existing_events = await invalidation_agent.process_invalidations_in_parallel(
        incoming_triplets=valid_fact_triplets,
        incoming_events=fact_events,
        existing_triplets=existing_triplets,
        existing_events=existing_events,
    )

    # 创建更新映射
    updated_incoming_event_map = {event.id: event for event in updated_incoming_fact_events}

    # 使用更新重建最终事件列表
    final_events = []
    for original_event in all_events:
        if original_event.id in updated_incoming_event_map:
            final_events.append(updated_incoming_event_map[original_event.id])
        else:
            final_events.append(original_event)

    return final_events, changed_existing_events
</code></pre>

<h3 id="3211">3.2.11. 整合所有内容</h3>
<p>现在我们已经构建了时间知识图谱工作流程的每个独立组件，我们可以将它们集成到一个连贯的工作流程中。</p>
<p>给定一个分块的转录稿，时间代理会依次处理每个块，最初提取相关的语句。然后，这些语句通过后续的提取阶段进行分类和丰富，从而产生时间事件、结构化三元组和已识别的实体。</p>
<p>提取的实体与数据库中的现有记录进行交叉引用，确保准确解析并避免冗余。在实体解析之后，动态事实会通过无效代理进行验证，以检查时间一致性和有效性。</p>
<p>在成功处理和验证之后，经过精炼的数据会被系统地存储到 SQLite 数据库的相应表中，从而维护一个组织良好且时间准确的知识图谱。</p>
<p>为了帮助直观地理解下面的代码，我们可以再次查看管道图：</p>
<!-- ![Screenshot 2025-06-23 at 11.45.46.png](temporal_agents_with_knowledge_graphs_files/826322ef-4eb8-4c3b-a1a1-f4c8b0d435e8.png) -->
<p><img
  src="../../../images/09_full_pipeline.png"
  alt="完整管道"
  style="width:791px; height:auto;"
/></p>
<pre class="codehilite"><code class="language-python">import sqlite3

from db_interface import (
    has_events,
    insert_chunk,
    insert_entity,
    insert_event,
    insert_transcript,
    insert_triplet,
    update_events_batch,
)
from utils import safe_iso


async def ingest_transcript(
        transcript: Transcript,
        conn: sqlite3.Connection,
        temporal_agent: TemporalAgent,
        invalidation_agent: InvalidationAgent,
        entity_resolver: EntityResolution) -&gt; None:
    &quot;&quot;&quot;
    将 Transcript 对象摄取到数据库中，提取并保存所有块、事件、三元组和实体。
    &quot;&quot;&quot;
    insert_transcript(
        conn,
        {
            &quot;id&quot;: str(transcript.id),
            &quot;text&quot;: transcript.text,
            &quot;company&quot;: transcript.company,
            &quot;date&quot;: transcript.date,
            &quot;quarter&quot;: transcript.quarter,
        },
    )

    transcript, all_events, all_triplets, all_entities = await temporal_agent.extract_transcript_events(transcript)
    entity_resolver.resolve_entities_batch(all_entities)
    name_to_canonical = {entity.name: entity.resolved_id for entity in all_entities if entity.resolved_id}

    # 使用解析后的实体 ID 更新三元组
    for triplet in all_triplets:
        if triplet.subject_name in name_to_canonical:
            triplet.subject_id = name_to_canonical[triplet.subject_name]
        if triplet.object_name in name_to_canonical:
            triplet.object_id = name_to_canonical[triplet.object_name]


    # 使用正确解析的三元组 ID 进行无效化处理
    events_to_update: list[TemporalEvent] = []
    if has_events(conn):
        all_events, events_to_update = await batch_process_invalidation(conn, all_events, all_triplets, invalidation_agent)

    # 所有数据库操作都在单个事务中进行
    with conn:
        # 首先更新现有事件（它们已在数据库中）
        if events_to_update:
            update_events_batch(conn, events_to_update)
            print(f&quot;已更新 {len(events_to_update)} 个现有事件&quot;)

        # 插入新数据
        for chunk in transcript.chunks or []:
            chunk_dict = chunk.model_dump()
            insert_chunk(
                conn,
                {
                    &quot;id&quot;: str(chunk_dict[&quot;id&quot;]),
                    &quot;transcript_id&quot;: str(transcript.id),
                    &quot;text&quot;: chunk_dict[&quot;text&quot;],
                    &quot;metadata&quot;: json.dumps(chunk_dict[&quot;metadata&quot;]),
                },
            )
        for event in all_events:
            event_dict = {
                &quot;id&quot;: str(event.id),
                &quot;chunk_id&quot;: str(event.chunk_id),
                &quot;statement&quot;: event.statement,
                &quot;embedding&quot;: pickle.dumps(event.embedding) if event.embedding is not None else None,
                &quot;triplets&quot;: event.triplets_json,
                &quot;statement_type&quot;: event.statement_type.value if hasattr(event.statement_type, &quot;value&quot;) else event.statement_type,
                &quot;temporal_type&quot;: event.temporal_type.value if hasattr(event.temporal_type, &quot;value&quot;) else event.temporal_type,
                &quot;created_at&quot;: safe_iso(event.created_at),
                &quot;valid_at&quot;: safe_iso(event.valid_at),
                &quot;expired_at&quot;: safe_iso(event.expired_at),
                &quot;invalid_at&quot;: safe_iso(event.invalid_at),
                &quot;invalidated_by&quot;: str(event.invalidated_by) if event.invalidated_by else None,
            }

            insert_event(conn, event_dict)
        for triplet in all_triplets:
            try:
                insert_triplet(
                    conn,
                    {
                        &quot;id&quot;: str(triplet.id),
                        &quot;event_id&quot;: str(triplet.event_id),
                        &quot;subject_name&quot;: triplet.subject_name,
                        &quot;subject_id&quot;: str(triplet.subject_id),
                        &quot;predicate&quot;: triplet.predicate,
                        &quot;object_name&quot;: triplet.object_name,
                        &quot;object_id&quot;: str(triplet.object_id),
                        &quot;value&quot;: triplet.value,
                    },
                )
            except KeyError as e:
                print(f&quot;KeyError: {triplet.subject_name} 或 {triplet.object_name} 在 name_to_canonical 中未找到&quot;)
                print(f&quot;跳过三元组：实体 '{e.args[0]}' 未解析。&quot;)
                continue
        # 在插入之前通过 id 对实体进行去重
        unique_entities = {}
        for entity in all_entities:
            unique_entities[str(entity.id)] = entity
        for entity in unique_entities.values():
            insert_entity(conn, {&quot;id&quot;: str(entity.id), &quot;name&quot;: entity.name, &quot;resolved_id&quot;: str(entity.resolved_id)})

    return None
</code></pre>

<pre class="codehilite"><code class="language-python"># 初始化核心组件
sqlite_conn = make_connection(memory=False, refresh=True)
temporal_agent = TemporalAgent()
invalidation_agent = InvalidationAgent()
entity_resolver = EntityResolution(sqlite_conn)
</code></pre>

<pre class="codehilite"><code class="language-python"># 摄取单个转录稿
await ingest_transcript(transcripts[0], sqlite_conn, temporal_agent, invalidation_agent, entity_resolver)
</code></pre>

<pre class="codehilite"><code class="language-python"># 查看已创建和填充的表
sqlite_conn.execute(&quot;SELECT name FROM sqlite_master WHERE type='table';&quot;).fetchall()
</code></pre>

<pre class="codehilite"><code class="language-python"># 查看三元组表
from db_interface import view_db_table

triplets_df = view_db_table(sqlite_conn, &quot;triplets&quot;, max_rows=10)
display(triplets_df)
</code></pre>

<p>然后我们可以摄取其余的转录稿。请注意，此代码尚未优化为生产就绪状态，平均每个转录稿需要 2-5 分钟。使用 /transcripts 中的数据进行批量摄取（约 30 个文件）将需要长达 2 小时才能运行。优化此过程是扩展到生产的关键步骤。我们在附录的<a href="./Appendix.ipynb">A.3“在摄取管道中实现并发”</a>中概述了一些您可以用来解决此问题的方法，包括批量分块、实体聚类等。</p>
<pre class="codehilite"><code class="language-python">import time

from tqdm import tqdm


async def bulk_transcript_ingestion(transcripts: list[Transcript], sqlite_conn: sqlite3.Connection) -&gt; None:
    &quot;&quot;&quot;处理转录稿摄取，包括重复检查、可选覆盖和进度跟踪。

    Args:
        transcripts (List[Transcript]): 要摄取的转录稿列表
        sqlite_conn (sqlite3.Connection): SQLite 数据库连接
        overwrite (bool, optional): 是否覆盖现有转录稿。默认为 False。
    &quot;&quot;&quot;
    temporal_agent = TemporalAgent()
    invalidation_agent = InvalidationAgent()
    entity_resolver = EntityResolution(sqlite_conn)

    pbar = tqdm(total=len(transcripts), desc=&quot;正在摄取转录稿&quot;)

    for transcript in transcripts:
        start_time = time.time()
        try:
            await ingest_transcript(transcript, sqlite_conn, temporal_agent, invalidation_agent, entity_resolver)
            # 计算并显示摄取时间
            end_time = time.time()
            ingestion_time = end_time - start_time

            # 使用完成消息更新进度条
            pbar.write(
                f&quot;已摄取转录稿 {transcript.id} &quot;
                f&quot;耗时 {ingestion_time:.2f} 秒&quot;
            )

        except Exception as e:
            pbar.write(f&quot;摄取转录稿 {transcript.id} 时出错：{str(e)}&quot;)

        finally:
            # 更新进度条
            pbar.update(1)

    pbar.close()
</code></pre>

<blockquote>
<p>注意：运行以下单元格处理此数据集中的所有转录稿可能需要大约 1 小时。</p>
</blockquote>
<pre class="codehilite"><code class="language-python"># 批量摄取（不推荐）
sqlite_conn = make_connection(memory=False, refresh=True, db_path=&quot;my_database.db&quot;)
transcripts = load_transcripts_from_pickle()
# await bulk_transcript_ingestion(transcripts, sqlite_conn)
</code></pre>

<p>我们建议从文件中加载预处理的 AMD 和 NVDA 数据，方法是使用以下代码创建一个新的 SQLite 连接。这将创建构建图谱和检索器所需的数据库。</p>
<p>您可以在 <a href="https://huggingface.co/datasets/TomoroAI/temporal_cookbook_db">HuggingFace</a> 上找到此数据。</p>
<pre class="codehilite"><code class="language-python">from cb_functions import load_db_from_hf
sqlite_conn = load_db_from_hf()
</code></pre>

<pre class="codehilite"><code>正在加载转录稿...
已加载转录稿...
正在加载块...
已加载块...
正在加载事件...
已加载事件...
正在加载三元组...
已加载三元组...
正在加载实体...
已加载实体...
✅ 所有表已写入 SQLite。
</code></pre>

<pre class="codehilite"><code class="language-python"># 查看转录稿表
from db_interface import view_db_table

transcript_df = view_db_table(sqlite_conn, &quot;transcripts&quot;, max_rows=None)
display(transcript_df)
</code></pre>

<h2 id="33">3.3. 知识图谱</h2>
<h3 id="331-networkx">3.3.1 使用 NetworkX 构建知识图谱</h3>
<p>在构建知识图谱时，来自三元组的规范实体标识符可确保实体名称的准确映射，从而允许将详细的时间元数据直接存储在边上。具体来说，该实现利用了以下属性：</p>
<ul>
<li><strong>valid_at</strong>、<strong>invalid_at</strong> 和 <strong>temporal_type</strong> 用于<strong>时间有效性</strong>，表示特定历史时刻的现实世界准确性——这对于历史事实的分析至关重要。</li>
<li>可选地，属性 <strong>created_at</strong> 和 <strong>expired_at</strong> 也可用于<strong>事务有效性</strong>，通过跟踪信息何时被记录、更新或更正，从而实现审计跟踪和来源归属。</li>
</ul>
<p>事务有效性在以下场景中尤其有益：</p>
<ul>
<li><strong>金融</strong>：确定在特定历史日期关于某公司资产负债表的公认财务事实，基于当时公认的知识。</li>
<li><strong>法律</strong>：识别在合同签署日期所理解的适用法律框架，或在过去日期所认识到的合规义务。</li>
<li><strong>新闻业</strong>：评估先前报道的信息是否已过时，确保新闻稿和报道随着时间的推移保持准确和可信。</li>
</ul>
<pre class="codehilite"><code class="language-python">import numpy
import pandas
import scipy

print(&quot;numpy :&quot;, numpy.__version__)
print(&quot;pandas:&quot;, pandas.__version__)
print(&quot;scipy :&quot;, scipy.__version__)
</code></pre>

<pre class="codehilite"><code class="language-python">import networkx as nx

# 打印图谱的描述性注释
print(f&quot;图谱有 {G.number_of_nodes()} 个节点和 {G.number_of_edges()} 条边&quot;)

# 获取一些基本的图谱统计信息
print(f&quot;图谱密度： {G.number_of_edges() / (G.number_of_nodes() * (G.number_of_nodes() - 1)):.4f}&quot;)

# 采样一些节点以查看其属性
sample_nodes = list(G.nodes(data=True))[:5]
print(&quot;\n示例节点（前 5 个）：&quot;)
for node_id, attrs in sample_nodes:
    print(f&quot;  {node_id}: {attrs}&quot;)

# 采样一些边以查看其属性
sample_edges = list(G.edges(data=True))[:5]
print(&quot;\n示例边（前 5 个）：&quot;)
for u, v, attrs in sample_edges:
    print(f&quot;  {u} -&gt; {v}: {attrs}&quot;)

# 获取度数统计信息
degrees = [d for _, d in G.degree()]
print(&quot;\n度数统计：&quot;)
print(f&quot;  最小度数： {min(degrees)}&quot;)
print(f&quot;  最大度数： {max(degrees)}&quot;)
print(f&quot;  平均度数： {sum(degrees) / len(degrees):.2f}&quot;)

# 检查图谱是否连通（考虑为无向图以进行连通性检查）
undirected_G = G.to_undirected()
print(&quot;\n连通性：&quot;)
print(f&quot;  连通分量数量： {len(list(nx.connected_components(undirected_G)))}&quot;)
print(f&quot;  是否弱连通： {nx.is_weakly_connected(G)}&quot;)
</code></pre>

<pre class="codehilite"><code class="language-python"># 创建知识图谱的可视化
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

# 创建一个较小的子图以进行可视化（减少数据以提高清晰度）
# 获取度数最高的节点以进行有意义的可视化
degrees = dict(G.degree())
top_nodes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)[:20]  # 从 30 减少到 20
visualization_nodes = [node for node, _ in top_nodes]

# 使用这些高连接度节点创建子图
graph = G.subgraph(visualization_nodes)
print(f&quot;可视化子图： {graph.number_of_nodes()} 个节点，{graph.number_of_edges()} 条边&quot;)

# 使用更好的样式创建绘图
fig, ax = plt.subplots(figsize=(18, 14))
fig.patch.set_facecolor(&quot;white&quot;)

# 使用分层布局以获得更好的结构
try:
    # 首先尝试分层布局
    pos = nx.nx_agraph.graphviz_layout(graph, prog=&quot;neato&quot;)
except (ImportError, nx.NetworkXException):
    # 回退到具有更好参数的弹簧布局
    pos = nx.spring_layout(graph, k=5, iterations=100, seed=42)

# 计算节点属性
node_degrees = [degrees[node] for node in graph.nodes()]
max_degree = max(node_degrees)
min_degree = min(node_degrees)

# 创建更好的颜色方案
colors = plt.cm.plasma(np.linspace(0.2, 0.9, len(node_degrees)))
node_colors = [colors[i] for i in range(len(node_degrees))]

# 使用改进的样式绘制节点
node_sizes = [max(200, min(2000, deg * 50)) for deg in node_degrees]  # 更好的尺寸缩放
nx.draw_networkx_nodes(graph, pos,
                      node_color=node_colors,
                      node_size=node_sizes,
                      alpha=0.9,
                      edgecolors=&quot;black&quot;,
                      linewidths=1.5,
                      ax=ax)

# 使用更好的样式绘制边
edge_weights = []
for _, _, _ in graph.edges(data=True):
    edge_weights.append(1)

nx.draw_networkx_edges(graph, pos,
                      alpha=0.4,
                      edge_color=&quot;#666666&quot;,
                      width=1.0,
                      arrows=True,
                      arrowsize=15,
                      arrowstyle=&quot;-&gt;&quot;,
                      ax=ax)

# 为所有节点添加标签，格式更好
labels = {}
for node in graph.nodes():
    node_name = graph.nodes[node].get(&quot;name&quot;, str(node))
    # 截断长名称
    if len(node_name) &gt; 15:
        node_name = node_name[:12] + &quot;...&quot;
    labels[node] = node_name

nx.draw_networkx_labels(graph, pos, labels,
                       font_size=9,
                       font_weight=&quot;bold&quot;,
                       font_color=&quot;black&quot;,  # 从“white”改为“black”
                       ax=ax)

# 改进标题和样式
ax.set_title(&quot;时间知识图谱可视化\n（前 20 个连接最多的实体）&quot;,
            fontsize=18, fontweight=&quot;bold&quot;, pad=20)
ax.axis(&quot;off&quot;)

# 添加更好的颜色条
sm = plt.cm.ScalarMappable(cmap=plt.cm.plasma,
                          norm=plt.Normalize(vmin=min_degree, vmax=max_degree))
sm.set_array([])
cbar = plt.colorbar(sm, ax=ax, shrink=0.6, aspect=30)
cbar.set_label(&quot;节点度数（连接数）&quot;, rotation=270, labelpad=25, fontsize=12)
cbar.ax.tick_params(labelsize=10)

# 在图谱周围添加边距
ax.margins(0.1)

plt.tight_layout()
plt.show()

# 打印可视化节点的一些信息
print(&quot;\n可视化中的顶级实体：&quot;)
for i, (node, degree) in enumerate(top_nodes[:10]):
    node_name = G.nodes[node].get(&quot;name&quot;, &quot;未知&quot;)
    print(f&quot;{i+1:2d}. {node_name} (连接数： {degree})&quot;)

# 创建一个改进的函数以方便图谱可视化
def visualise_graph(G, num_nodes=20, figsize=(16, 12)):
    &quot;&quot;&quot;
    使用改进的样式和减少的数据可视化 NetworkX 图。

    Args:
        G: NetworkX 图
        num_nodes: 可视化中包含的顶级节点数（默认：20）
        figsize: 图形尺寸元组
    &quot;&quot;&quot;
    degrees = dict(G.degree())
    top_nodes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)[:num_nodes]
    visualization_nodes = [node for node, _ in top_nodes]

    # 创建子图
    subgraph = G.subgraph(visualization_nodes)

    # 创建绘图
    fig, ax = plt.subplots(figsize=figsize)
    fig.patch.set_facecolor(&quot;white&quot;)

    # 使用更好的参数进行布局
    try:
        pos = nx.nx_agraph.graphviz_layout(subgraph, prog=&quot;neato&quot;)
    except (ImportError, nx.NetworkXException):
        pos = nx.spring_layout(subgraph, k=4, iterations=100, seed=42)

    # 节点属性
    node_degrees = [degrees[node] for node in subgraph.nodes()]
    max_degree = max(node_degrees)
    min_degree = min(node_degrees)

    # 更好的颜色方案
    colors = plt.cm.plasma(np.linspace(0.2, 0.9, len(node_degrees)))
    node_colors = list(colors)

    # 绘制节点
    node_sizes = [max(200, min(2000, deg * 50)) for deg in node_degrees]
    nx.draw_networkx_nodes(subgraph, pos,
                          node_color=node_colors,
                          node_size=node_sizes,
                          alpha=0.9,
                          edgecolors=&quot;black&quot;,
                          linewidths=1.5,
                          ax=ax)

    # 绘制边
    nx.draw_networkx_edges(subgraph, pos,
                          alpha=0.4,
                          edge_color=&quot;#666666&quot;,
                          width=1.0,
                          arrows=True,
                          arrowsize=15,
                          ax=ax)

    # 标签
    labels = {}
    for node in subgraph.nodes():
        node_name = subgraph.nodes[node].get(&quot;name&quot;, str(node))
        if len(node_name) &gt; 15:
            node_name = node_name[:12] + &quot;...&quot;
        labels[node] = node_name

    nx.draw_networkx_labels(subgraph, pos, labels,
                           font_size=9,
                           font_weight=&quot;bold&quot;,
                           font_color=&quot;black&quot;,  # 从“white”改为“black”
                           ax=ax)

    ax.set_title(f&quot;时间知识图谱\n（前 {num_nodes} 个连接最多的实体）&quot;,
                fontsize=16, fontweight=&quot;bold&quot;, pad=20)
    ax.axis(&quot;off&quot;)

    # 颜色条
    sm = plt.cm.ScalarMappable(cmap=plt.cm.plasma,
                              norm=plt.Normalize(vmin=min_degree, vmax=max_degree))
    sm.set_array([])
    cbar = plt.colorbar(sm, ax=ax, shrink=0.6)
    cbar.set_label(&quot;连接数&quot;, rotation=270, labelpad=20)

    ax.margins(0.1)
    plt.tight_layout()
    plt.show()

    return subgraph
</code></pre>

<pre class="codehilite"><code class="language-python"># 获取 NVIDIA 的节点信息，过滤以了解他们开发了什么

# 查找 NVIDIA 的节点键（名称不区分大小写匹配）
nvidia_node = None
for node, data in graph.nodes(data=True):
    if &quot;nvidia&quot; in str(data.get(&quot;name&quot;, &quot;&quot;)).lower():
        nvidia_node = node
        break

if nvidia_node is not None:
    print(f&quot;NVIDIA 的节点键： {nvidia_node}&quot;)
    print(&quot;节点属性：&quot;)
    for k, v in graph.nodes[nvidia_node].items():
        print(f&quot;  {k}: {v}&quot;)

    # 显示 NVIDIA 作为主体且谓词为“DEVELOPED”或“LAUNCHED”或类似谓词的所有边
    print(&quot;\nNVIDIA 开发或推出了某项内容的边：&quot;)
    for _, v, _, d in graph.out_edges(nvidia_node, data=True, keys=True):
        pred = d.get(&quot;predicate&quot;, &quot;&quot;).upper()
        if pred in {&quot;LAUNCHED&quot;}:#, &quot;LAUNCHED&quot;, &quot;PRODUCES&quot;, &quot;CREATED&quot;, &quot;INTRODUCED&quot;}:
            print(f&quot;  {nvidia_node} -[{pred}]-&gt; {v} | {d}&quot;)
            # 可选地，打印语句（如果可用）
            if &quot;statement&quot; in d:
                print(f&quot;    语句： {d['statement']}&quot;)
else:
    print(&quot;图中未找到 NVIDIA 节点。&quot;)
</code></pre>

<h3 id="332-networkx-neo4j">3.3.2 NetworkX 与 Neo4j 在生产中的对比</h3>
<p>为了有效地实现和利用知识图谱，我们在本手册中出于以下几个原因使用了 <a href="https://networkx.org/">NetworkX</a>。</p>
<ol>
<li><strong>Python 集成</strong>：NetworkX 与 Python 无缝集成，有助于快速原型设计和迭代开发</li>
<li><strong>易于设置</strong>：它只需要最少的初始设置，不需要像替代方案那样进行客户端-服务器设置。这使其成为希望自行运行本手册的用户的理想选择</li>
<li><strong>与内存数据库兼容</strong>：NetworkX 可以高效地管理少于约 100,000 个节点的图，这对于本手册的数据规模来说是合适的</li>
</ol>
<p>但是，应注意 NetworkX 缺少内置的数据持久性，因此通常不推荐用于生产构建。</p>
<p>对于生产构建，<a href="https://neo4j.com/">Neo4j</a> 因其更优越的生产中心功能而脱颖而出，包括：</p>
<ul>
<li><strong>原生图存储和处理</strong>：针对图数据进行了优化，具有高性能和高效处理能力</li>
<li><strong>优化查询引擎</strong>：利用 Cypher 查询语言，该语言专为高效图遍历而设计</li>
<li><strong>可扩展性和持久性</strong>：有效管理海量图数据集，确保数据持久性、可靠性和耐用性</li>
<li><strong>生产工具</strong>：提供集成的工具，如用于可视化的 Neo4j Bloom 和用于探索的 Neo4j Browser，增强用户交互和分析</li>
<li><strong>高级访问控制</strong>：提供细粒度的安全选项来控制数据访问。</li>
</ul>
<h2 id="34">3.4. 评估和建议的功能添加</h2>
<p>上述方法为构建用于知识图谱构建的时间代理提供了一个基础实现。但是，它并未完全解决现实世界应用中遇到的复杂性或所有可能的边缘情况。下面，我们概述了几项可以进一步提高此实现健壮性和适用性的增强功能。在后面的“原型到生产”部分中，我们将通过建议对于有效部署此类代理到生产环境至关重要的其他注意事项来扩展这些增强功能。有关扩展到生产的更多详细信息包含在<a href="./Appendix.ipynb">附录</a>中。</p>
<h3 id="341">3.4.1. 时间代理</h3>
<h4 id="_31">语句提取和时间事件</h4>
<h5 id="_32">重复的时间事件</h5>
<p>在本手册中，时间代理不识别或合并因引用同一事件的语句而产生的重复时间事件，尤其是在来自不同来源的情况下。这些事件被单独保存，而不是合并为一个统一的事件。</p>
<h5 id="_33">静态和动态表示</h5>
<p>通过一致地捕获事件的静态和动态表示（即使没有明确的语句）来丰富数据集，这是一个机会。</p>
<p>对于没有相应静态语句的动态事件，创建显式的静态条目来标记开始（<code>valid_at</code>）和结束（<code>invalid_at</code>）可以增强时间清晰度，特别是为了检索任务的目的。</p>
<p>反之，没有动态对应物的静态事件可以推断出动态关系，但这需要仔细检查语句队列中潜在的无效化。</p>
<h4 id="_34">日期提取</h4>
<p>本手册中的实现不明确记录在日期消歧期间所做的假设。</p>
<p>在没有明确发布日期的情况下，当前日期被隐式用作参考。对于某些工作流程，此假设可能需要更改以满足最终用户的需求。</p>
<p>抽象日期（例如，“直到明年”）被解析为显式日期，但存储的数据结构中并未表示这种模糊性。包含更精细的元数据可以捕获更抽象的日期范围：</p>
<pre class="codehilite"><code class="language-python">temporal_event = {
  &quot;summary&quot;: &quot;事件从四月持续到九月&quot;,
  &quot;label&quot;: &quot;dynamic&quot;,
  &quot;valid_at&quot;: {
      &quot;date&quot;: &quot;2025-04-01&quot;,
      &quot;literal&quot;: False,
      &quot;abstract_date&quot;: &quot;2025-04&quot;
  },
  &quot;invalid_at&quot;: {
      &quot;date&quot;: &quot;2025-09-30&quot;,
      &quot;literal&quot;: False,
      &quot;abstract_date&quot;: &quot;2025-09&quot;
  }
}
</code></pre>

<p>此结构允许显式表示字面和抽象日期解释。</p>
<h4 id="_35">三元组提取</h4>
<p>本手册中提出的三元组提取有几个可能的改进途径。这些包括：</p>
<ul>
<li>使用更大的模型并进一步优化提取提示</li>
<li>多次运行提取过程并通过例如池化机制来合并结果，以提高预测的准确性和置信度</li>
<li>结合实体提取工具（例如 <a href="https://spacy.io/">Spacy</a>）并利用针对特定用例预定义的本体，以提高一致性和可靠性</li>
</ul>
<h3 id="342">3.4.2. 无效代理</h3>
<p>提出的无效代理不精炼时间有效性范围，但可以扩展其功能以执行此类精炼以及进行队列内无效化检查以识别语句之间的时间冲突。</p>
<p>此外，还有几个提高效率的机会。</p>
<ul>
<li>从一对一（1:1）比较过渡到全向（1:多）无效化检查将减少所需的 LLM 调用次数</li>
<li>应用网络分析技术来聚类相关语句可以实现无效化检查的批处理。集群可以从多个属性派生，包括语义相似性、时间邻近性或更高级的技术。这将显著减少由顺序处理引起的瓶颈，这在摄取大量数据时尤其重要。</li>
</ul>
<h1 id="4">4. 使用知识图谱进行多步检索</h1>
<hr />
<p>简单的检索系统通常可以通过与向量存储或文档索引的单次搜索来处理简单的“查找”查询。然而，在实际环境中部署的代理通常需要更多。用户问题通常需要 LLM 从知识库的多个部分或多个端点综合信息。</p>
<p>前面介绍的时间知识图谱为此提供了一个自然的基础，它显式地编码了实体（节点）、关系（边）及其随时间的变化。</p>
<p>多步检索使我们能够充分利用这些图谱的功能。它涉及通过一系列有针对性的查询迭代地遍历图谱，使代理能够在形成响应之前收集所有必要的上下文。</p>
<p>我们可以在下面看到多步检索的强大功能：</p>
<!-- ![Screenshot 2025-06-23 at 11.46.52.png](temporal_agents_with_knowledge_graphs_files/55e196a3-2d42-469c-8b7d-938a56b47f38.png) -->
<p><img
  src="../../../images/10_multi_step_retrieval.png"
  alt="多检索代理"
  style="width:891px; height:auto;"
/></p>
<p>在这种情况下，对知识图谱的初始查询没有返回有关某些竞争对手研发活动的信息。系统没有静默失败，而是转向了替代来源——战略内容——并成功找到了缺失的信息。这种多步方法使其能够导航稀疏数据并为用户提供完整的响应。</p>
<h2 id="41">4.1. 构建检索代理</h2>
<p>高层来看，我们将构建以下结构：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>用户问题 → 规划器 → 协调器</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用 GPT 4.1 的规划器将用户的问题分解为一系列建议的图操作。然后将其传递给协调器执行
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>工具调用以从时间知识图谱检索信息</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      考虑到用户查询和计划，协调器（o4-mini）进行一系列初始工具调用以从知识图谱检索信息
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>循环直到完成 → 生成答案</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      工具调用的响应被反馈给协调器，然后协调器可以决定进行更多图查询还是回答用户的问题
    </p>
  </li>
</ol>

<!-- ![Screenshot 2025-06-23 at 11.47.19.png](temporal_agents_with_knowledge_graphs_files/7fe7cc38-3551-4914-af4e-bfed38648ef1.png) -->
<p><img
  src="../../../images/11_retrieval_agent.png"
  alt="检索代理"
  style="width:791px; height:auto;"
/></p>
<h3 id="411">4.1.1. 导入</h3>
<pre class="codehilite"><code class="language-python">%pip install --upgrade openai
</code></pre>

<h3 id="412-openai">4.1.2. （重新）初始化 OpenAI 客户端</h3>
<pre class="codehilite"><code class="language-python">from openai import AsyncOpenAI

client = AsyncOpenAI()
</code></pre>

<h3 id="413">4.1.3. （重新）加载我们的时间知识图谱</h3>
<pre class="codehilite"><code class="language-python">from cb_functions import build_graph, load_db_from_hf

conn = load_db_from_hf()
G = build_graph(conn)

print(G.number_of_nodes(), &quot;nodes,&quot;, G.number_of_edges(), &quot;edges&quot;)
</code></pre>

<h3 id="414">4.1.4. 规划器</h3>
<p>规划步骤已包含在许多现代 LLM 应用程序中。</p>
<p>明确包含规划步骤通过让系统在行动前考虑问题的全部范围来提高整体性能。</p>
<p>在此实现中，计划保持静态。然而，在更长期的代理管道中，随着系统的进展，通常会包含重新规划或更新计划的机制。</p>
<p>总的来说，规划器有两种形式：</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>面向任务（本手册中使用）</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      规划器概述了下游代理块应执行的具体子任务。任务的措辞是面向行动的，例如“1. 提取关于 XYZ 公司在 2018-2020 年间研发活动的信息。”这些规划器通常在目标主要是确定性的，并且主要风险是跳过或重复工作时使用。
    </p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      适合此方法的示例任务：
    </p>
    <ul style="margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1.2em;">
      <li><strong>法律</strong>：<em>“提取并制表 FY24 期间执行的每份主服务协议中的终止通知期”</em></li>
      <li><strong>金融</strong>：<em>“获取标准普尔 500 指数银行在 FY24 提交的所有 10-K 文件，提取一级资本和流动性覆盖率，并按资本充足率对机构进行排名表输出”</em></li>
      <li><strong>汽车</strong>：<em>“编译自新排放法规生效以来欧洲销售的 XYZ 型号电动汽车的组件保修索赔计数”</em></li>
      <li><strong>制造</strong>：<em>“分析 2025 年第一季度所有数控机床的停机日志，对根本原因代码进行分类，并生成前五名故障驱动因素的帕累托图”</em></li>
    </ul>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>面向假设</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      计划被构建为系统可以在响应用户问题时确认、拒绝或精炼的一组假设。每个步骤代表一个可测试的声明，可以选择性地配对建议的操作。这种方法在开放式研究任务中表现出色，在这些任务中，新信息可以显著重塑解决方案空间。
    </p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      适合此方法的示例任务：
    </p>
    <ul style="margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1.2em;">
      <li><strong>法律</strong>：<em>“提供的证据是否满足公平使用原则的所有四个要素？根据相关判例法评估每个要素”</em></li>
      <li><strong>制药</strong>：<em>“有哪些新兴的 mRNA 递送方法可用于靶向 IRS1 基因治疗肥胖症？”</em></li>
      <li><strong>金融</strong>：<em>“Alpha 银行是否面临流动性风险？比较其 LCR 趋势、银行间借贷成本、存款流出以及您发现的其他任何有趣内容”</em></li>
    </ul>
  </li>
</ol>

<h4 id="_36">提示我们的规划器</h4>
<p>我们将为初始规划器定义两个提示（一个 <code>system</code> 提示和一个 <code>user</code> 提示）。</p>
<p>我们系统提示最显著的特点是使用了“基于角色的”提示。我们通过赋予 LLM 公司内部专家角色来提示 LLM。这有助于将模型的响应语气塑造成我们想要的行为——一种直接、面向行动的任务列表，适合金融行业。</p>
<p>然后，在用户提示中，我们通过在 <code>user_question</code> 前面加上关于此特定情况以及规划器应如何处理它的信息来扩展它。</p>
<p>在生产环境中，您可以通过在每次调用之前动态丰富提示来增强此模板。您可以注入有关用户个人资料的信息——行业、角色、首选写作风格、先前的对话上下文——以便规划器根据他们的环境定制其操作。您还可以执行快速的“问题构建”循环：让助手提出澄清性问题，收集答案，然后将它们合并回提示中，以便规划器从一个范围明确、信息丰富的要求开始，而不是一个模糊的要求。</p>
<p>另一种效果很好的流程是允许用户在执行计划之前查看计划并选择性地编辑它。当您的 AI 系统更多地扮演助手角色时，这尤其有效。让领域专家（如律师或药学研究人员）能够引导并将他们的想法和研究方向更深入地融入系统，通常会带来提高系统性能和最终用户满意度的双重好处。</p>
<pre class="codehilite"><code class="language-python">async def initial_planner(user_question: str) -&gt; str:
    &quot;&quot;&quot;返回回答用户问题的初始计划。&quot;&quot;&quot;
    initial_planner_system_prompt = (
        &quot;您在领先的金融公司 ABC 公司工作，该公司是全球最大的金融公司之一。 &quot;
        &quot;由于您在公司任职时间长且享有盛誉，因此各种股票研究团队经常会就他们正在进行的研究任务向您寻求指导。 &quot;
        &quot;您的专业知识尤其在 ABC 公司专有的财报电话会议记录知识库领域非常强大。 &quot;
        &quot;该知识库包含从各公司财报电话会议记录中提取的详细信息，并对这些陈述的有效时间进行了标记。 &quot;
        &quot;您是为团队提供有关如何使用此知识图谱来回答其研究查询的指导的专家。\n&quot;
        &quot;团队将可以使用以下工具来帮助他们从知识图谱中检索信息：\n&quot;
        &quot;1. `factual_qa`：查询知识图谱，以获取涉及给定实体和谓词的时间限制事实关系。\n&quot;
        &quot;2. `trend_analysis`：包装 factual_qa 工具，并使用专门的代理程序进行深入的趋势分析。\n&quot;
        &quot;还应注意的是，trend_analysis 工具可以接受多个谓词参数作为列表。\n &quot;
        &quot;如果这样做有用，您可以建议多次调用工具，并使用不同的谓词（例如）。\n &quot;
        &quot;您的建议应向团队解释如何仅通过这些工具从数据库中检索信息。 &quot;
    )

    initial_planner_user_prompt = (
        &quot;您顶尖的股票研究团队向您提出了一个他们正在尝试回答的研究问题。 &quot;
        &quot;您应该运用您深厚的金融专业知识，简洁地详细说明一个分步计划，以从公司的财报电话会议记录提取知识库中检索此信息。 &quot;
        &quot;您应该生成一套简洁的个人研究任务，以彻底解决团队的查询。 &quot;
        &quot;这些任务应涵盖团队研究任务的所有关键点，而不会使其过于复杂。\n\n&quot;
        &quot;团队的问题是：\n\n&quot;
        f&quot;{user_question} \n\n&quot;
        &quot;在“研究任务”标题下返回您的答案，不要添加任何多余的语言，只需计划。&quot;
    )

    input_messages = [
        {&quot;role&quot;:&quot;system&quot;, &quot;content&quot;: initial_planner_system_prompt},
        {&quot;role&quot;:&quot;user&quot;, &quot;content&quot;: initial_planner_user_prompt}
    ]

    initial_plan = await client.responses.create(
        model=&quot;gpt-4.1&quot;,
        input=input_messages
    )

    return initial_plan.output_text
</code></pre>

<pre class="codehilite"><code class="language-python">plan = await initial_planner(&quot;How can we find out how AMD's research priorties have changed in the last 4 years?&quot;)
</code></pre>

<pre class="codehilite"><code class="language-python">print(plan)
</code></pre>

<h3 id="415">4.1.5. 函数调用</h3>
<p><a href="https://platform.openai.com/docs/guides/function-calling?api-mode=responses">OpenAI 函数调用</a>（也称为工具）使模型能够通过调用预定义的函数来执行特定的外部操作。OpenAI 平台提供的一些工具包括：</p>
<ul>
<li><strong>代码解释器</strong>：执行代码以进行数据分析、数学计算、绘图和文件操作</li>
<li><strong>网络搜索</strong>：在模型响应生成中包含来自互联网的数据</li>
<li><strong>文件搜索</strong>：搜索已上传文件的内容以获取上下文</li>
<li><strong>图像生成</strong>：使用 GPT 图像生成或编辑图像</li>
<li><strong>远程 MCP 服务器</strong>：通过模型上下文协议 (MCP) 服务器为模型提供新功能</li>
</ul>
<p>其他手册涵盖了如何构建 LLM 使用的工具。在此示例中，我们将开发几个旨在有效探索时间知识图谱并帮助回答用户问题的工具。</p>
<p>关于工具设计有几种思想流派，最佳选择取决于具体应用。</p>
<!-- ![Screenshot 2025-06-23 at 11.52.01.png](temporal_agents_with_knowledge_graphs_files/150d9cc4-9989-4e8e-bfcf-f1223a7959ee.png) -->
<p><img
  src="../../../images/12_spectrum_of_tools.png"
  alt="工具谱"
  style="width:891px; height:auto;"
/></p>
<h4 id="_37">固定工具</h4>
<p>在此上下文中，“固定”工具是指功能固定、定义明确的工具。通常，这些工具接受有限数量的特定参数并执行明确定义的任务。例如，固定工具可能会执行简单的查询，如“获取用户所在位置的今日天气”。由于其结构化性质，这些工具在执行结构化环境（如 ERP 系统、监管框架或仪表板）中的一致查找或值监控方面表现出色。然而，它们的僵化限制了灵活性，通常促使用户用更动态的传统数据管道替换它们，特别是对于连续数据流。</p>
<p>各种行业中的固定工具示例包括：</p>
<ul>
<li><strong>金融</strong>：“美元兑欧元当前汇率是多少？”</li>
<li><strong>制药</strong>：“检索药物 ABC 已知的副作用。”</li>
<li><strong>制造业</strong>：“第 42 批次的缺陷率是多少？”</li>
</ul>
<h4 id="_38">自由格式</h4>
<p>自由格式工具代表了工具谱中最灵活的一端。这些工具能够执行复杂、开放式的任务，并且对输入结构几乎没有限制。一个常见的例子是代码解释器，能够处理各种分析任务。尽管其灵活性提供了显著的优势，但它们也可能带来不可预测性，并且在保证一致的可靠性方面可能更具挑战性。</p>
<p>在行业应用中，自由格式工具可能看起来像：</p>
<ul>
<li><strong>金融</strong>：“使用过去 10 年的 ETF 价格数据对该动量交易策略进行回测，并绘制夏普比率分布图。”</li>
<li><strong>汽车</strong>：“给定此原始遥测日志，识别指示早期制动器故障的模式，并在各种地形条件下模拟结果。”</li>
<li><strong>制药</strong>：“创建一个管道，从该数据集中筛选出统计学上显著的基因上调，然后运行基因集富集分析并生成可用于发布的图形。”</li>
</ul>
<h4 id="_39">半结构化工具（本手册中使用）</h4>
<p>现代代理工作流程通常需要能够有效平衡结构和灵活性的工具。半结构化工具专门用于管理这一中间地带。它们接受中等复杂格式的输入——例如文本片段、类似 JSON 的参数或小型代码片段——并且通常嵌入基本的推理、检索或决策制定功能。当任务定义明确但并非完全统一时，这些工具非常有用，例如当所需的数据库或服务已知，但查询或预期输出有所不同时。</p>
<p>半结构化工具的两种常见范例是：</p>
<ul>
<li><strong>扩展功能</strong>：充当专业代理本身的工具，包含内部逻辑和分析例程</li>
<li><strong>灵活的参数接口</strong>：允许 LLM 传递表达性但结构化的参数，例如详细的查询、过滤器或嵌入式函数</li>
</ul>
<p>当：</p>
<ul>
<li>将特定但非平凡的任务（如搜索、转换或摘要）委托给专用工具时</li>
<li>已知源数据或 API，但返回的结果可能不可预测时</li>
</ul>
<p>在生产环境中，由于其增强的可靠性和性能，这些工具通常比自由格式工具（如代码解释器）更受青睐。例如，使用半结构化工具中模板化的优化 Cypher 查询来查询大型 Neo4j 知识图谱，比从头开始生成每个查询更可靠、更高效。</p>
<p>行业应用半结构化工具包括：</p>
<ul>
<li><strong>金融</strong>：“提取 2023 年第二季度公司申报文件中所有具有前瞻性的风险因素。”</li>
<li><strong>汽车</strong>：“识别 2020 年之后推出的电动汽车型号的维护日志中反复出现的电气故障。”</li>
<li><strong>制药</strong>：“定位支持特定 mRNA 治疗有效上调 IRS1 基因以治疗肥胖症的假设的组学数据。”</li>
</ul>
<h4 id="_40">为我们的检索器创建工具</h4>
<h5 id="_41">事实问答</h5>
<p><code>factual_qa</code> 工具为我们的代理提供了一种有效的方式，可以从我们的时间知识图谱中检索有关特定公司、主题和日期范围的信息。这将帮助代理回答诸如“AMD 在 2017 年第三季度的收益是多少？”之类的问题。</p>
<p>此工具位于我们之前介绍的固定工具和半结构化工具之间。这通常是一个非常严格的工具，因为它将代理限制在少数参数中。但是，输入的自由度很大，该工具在可以检索的信息方面仍然很灵活。这有助于避免核心代理每次查询都需要从头开始编写新的 networkx 查询，从而提高了准确性和延迟。</p>
<p>该工具有以下参数：</p>
<ul>
<li><code>entity</code>：工具应检索信息的实体（或三元组本体中的对象）</li>
<li><code>start_date_range</code>：工具应检索的日期范围的下限</li>
<li><code>end_date_range</code>：工具应检索的日期范围的上限</li>
<li><code>predicate</code>：工具将连接 <code>entity</code> 以执行检索的谓词名称</li>
</ul>
<p>我们首先加载谓词定义。我们将使用这些来提高工具中的错误容差，使用 GPT-4.1-nano 将参数中传递的谓词规范化为有效的谓词名称。</p>
<pre class="codehilite"><code class="language-python"># 重新定义谓词定义，因为我们在这里需要它们
PREDICATE_DEFINITIONS = {
    &quot;IS_A&quot;: &quot;表示两个实体之间的类别或类型关系（例如，“Model Y IS_A electric-SUV”）。包括“is”和“was”。&quot;,
    &quot;HAS_A&quot;: &quot;表示两个实体之间的部分-整体关系（例如，“Model Y HAS_A electric-engine”）。包括“has”和“had”。&quot;,
    &quot;LOCATED_IN&quot;: &quot;指定地理或组织包含或邻近性（例如，总部 LOCATED_IN Berlin）。&quot;,
    &quot;HOLDS_ROLE&quot;: &quot;将一个人与组织内的正式职位或头衔（CEO、主席、董事等）联系起来。&quot;,
    &quot;PRODUCES&quot;: &quot;表示实体制造、构建或创建产品、服务或基础设施（包括规模化和组件包含）。&quot;,
    &quot;SELLS&quot;: &quot;标记商业卖家与客户之间的产品或服务关系（市场、分销、销售）。&quot;,
    &quot;LAUNCHED&quot;: &quot;捕获产品、服务或计划的官方首次发布、发货或公开启动。&quot;,
    &quot;DEVELOPED&quot;: &quot;显示技术、产品或功能的设计、研发或创新来源。包括“研究”或“创建”。&quot;,
    &quot;ADOPTED_BY&quot;: &quot;表示技术或产品已被另一个实体采用、部署或实施。&quot;,
    &quot;INVESTS_IN&quot;: &quot;表示资本或资源从一个实体流向另一个实体（股权、融资轮次、战略投资）。&quot;,
    &quot;COLLABORATES_WITH&quot;: &quot;实体之间的通用合作伙伴关系、联盟、合资企业或许可关系。&quot;,
    &quot;SUPPLIES&quot;: &quot;捕获供应商-客户供应链链接或依赖关系（提供给、来源自）。&quot;,
    &quot;HAS_REVENUE&quot;: &quot;将实体与收入金额或指标相关联——实际的、报告的或预测的。&quot;,
    &quot;INCREASED&quot;: &quot;表示相对于先前时期或基线的指标（收入、市场份额、产出）的向上变化。&quot;,
    &quot;DECREASED&quot;: &quot;表示相对于先前时期或基线的指标的向下变化。&quot;,
    &quot;RESULTED_IN&quot;: &quot;捕获一个事件或因素导致特定结果（正面或负面）的因果关系。&quot;,
    &quot;TARGETS&quot;: &quot;表示实体寻求达到的战略目标、市场细分或客户群体。&quot;,
    &quot;PART_OF&quot;: &quot;表示层级成员资格或子集关系（部门、子公司、由...管理、属于）。&quot;,
    &quot;DISCONTINUED&quot;: &quot;表示产品、服务或关系的官方生命周期结束、关闭或终止。&quot;,
    &quot;SECURED&quot;: &quot;标记实体成功获得资金、合同、资产或权利。&quot;,
}
</code></pre>

<p>我们定义了几个用于事实问答工具的辅助函数。</p>
<p>首先是 <code>_as_datetime</code>。此工具用于将定义日期范围的参数强制转换为正确的 datetime 格式。</p>
<p>接下来，我们介绍两个新的数据模型：<code>PredicateMatching</code> 和 <code>PredicateMatchValidation</code>。<code>PredicateMatching</code> 定义了 GPT-4.1-nano 调用将谓词匹配到有效谓词名称的输出格式。<code>PredicateMatchValidation</code> 然后执行第二个验证步骤，以断言此来自 GPT-4.1-nano 的输出是有效的谓词名称，利用 Pydantic 字段验证器。此过程有助于确保工具顺利运行，并有助于消除导致图查询失败的某些罕见边缘情况。</p>
<pre class="codehilite"><code class="language-python"># 辅助函数和模型
from datetime import datetime

from pydantic import BaseModel, Field, ValidationError, field_validator


def _as_datetime(ts) -&gt; datetime | None:
    &quot;&quot;&quot;辅助函数，用于将可能的时戳格式强制转换为 `datetime`。&quot;&quot;&quot;  # noqa: D401
    if ts is None:
        return None
    if isinstance(ts, datetime):
        return ts
    for fmt in (&quot;%Y-%m-%d&quot;, &quot;%Y/%m/%d&quot;, &quot;%Y-%m-%dT%H:%M:%S&quot;):
        try:
            return datetime.strptime(ts, fmt)
        except ValueError:
            continue
    return None

class PredicateMatching(BaseModel):
    &quot;&quot;&quot;用于模型结构化输出的类，以将输入强制转换为正确的谓词格式。&quot;&quot;&quot;
    reasoning: str = Field(description=&quot;使用此空间推理正确的谓词以进行匹配。&quot;)
    predicate_match: str = Field(description=&quot;与字典匹配的谓词。&quot;)


class PredicateMatchValidation(BaseModel):
    &quot;&quot;&quot;用于验证模型输出的类，该模型尝试将谓词参数强制转换为实际谓词。&quot;&quot;&quot;
    predicate: str

    @field_validator(&quot;predicate&quot;)
    @classmethod
    def predicate_in_definitions(cls, v):
        &quot;&quot;&quot;如果谓词不在 PREDICATE_DEFINITIONS 中，则返回错误字符串。&quot;&quot;&quot;
        if v not in PREDICATE_DEFINITIONS:
            return f&quot;错误：“{v}”不是有效的谓词。必须是以下之一：{list(PREDICATE_DEFINITIONS.keys())}&quot;
        return v
</code></pre>

<p>我们的事实问答工具可以分解为四个步骤。</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">
  <li style="margin-bottom: 1.2em;">
    <strong>谓词强制转换</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      如果提供的谓词在 <code>PREDICATE_DEFINITIONS</code> 字典中找不到，此步骤将使用 GPT-4.1-nano 将其强制转换为有效的谓词。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>实体定位</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      执行模糊匹配以在 networkx 图中识别相应的实体节点。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>边收集</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      检索与已识别实体节点关联的入边和出边。
    </p>
  </li>

  <li style="margin-bottom: 1.2em;">
    <strong>响应格式化</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      将收集到的信息结构化为易于协调器使用的格式化响应。
    </p>
  </li>
</ol>

<pre class="codehilite"><code class="language-python">async def factual_qa(
    entity: str,
    start_date_range: datetime,
    end_date_range: datetime,
    predicate: str
) -&gt; str:
    &quot;&quot;&quot;
    查询知识图谱，以获取与*实体*相关的、与*谓词*匹配并在请求的时间窗口内的事实关系。

    响应的格式为：

        主语  –  谓词  –  宾语   [有效开始日期]
            语句：“...”
            类型：FACT   •   值：42

    如果没有找到匹配项（或发生错误），则返回人类可读的解释。
    &quot;&quot;&quot;
    # 检查传入的日期范围是否合乎逻辑
    if start_date_range &gt; end_date_range:
        return (
            &quot;您上次错误地使用了 `factual_qa` 工具。您提供的 &quot;
            &quot;`start_date_range` 比 `end_date_range` 更近。 &quot;
            &quot;`end_date_range` 必须大于或等于 `start_date_range`。&quot;
        )

    # ---- (1) 谓词强制转换/验证 -----------------------
    if predicate not in PREDICATE_DEFINITIONS:
        try:
            predicate_definitions_str = &quot;\n&quot;.join(
                f&quot;- {k}: {v}&quot; for k, v in PREDICATE_DEFINITIONS.items()
            )
            coercion_prompt = (
                &quot;您是一位乐于助人的助手，可以将谓词匹配到谓词定义字典。请返回最佳匹配的谓词**以及**您的推理。\n\n&quot;
                f&quot;字典：\n{predicate_definitions_str}\n\n&quot;
                f&quot;要匹配的谓词： {predicate}&quot;
            )

            completion = await client.beta.chat.completions.parse(
                model=&quot;gpt-4.1-nano&quot;,
                messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: coercion_prompt}],
                response_format=PredicateMatching,
            )
            coerced_predicate = completion.choices[0].message.parsed.predicate_match

            # 使用我们期望的枚举/模型进行验证
            _ = PredicateMatchValidation(predicate=coerced_predicate)
            predicate = coerced_predicate
        except ValidationError:
            return (
                &quot;您提供了一个无效的谓词。 &quot;
                f&quot;有效的谓词是： {list(PREDICATE_DEFINITIONS.keys())}&quot;
            )
        except Exception:
            # 强制转换失败 - 回退到原始谓词
            pass

    predicate_upper = predicate.upper()
    entity_lower = entity.lower()

    # ---- (2) 通过模糊匹配定位实体节点 -----------------
    try:
        target_node = None
        for node, data in G.nodes(data=True):
            node_name = data.get(&quot;name&quot;, str(node))
            if entity_lower in node_name.lower() or node_name.lower() in entity_lower:
                target_node = node
                break
        if target_node is None:
            return f&quot;在知识图谱中未找到实体“{entity}”。&quot;
    except Exception as e:
        return f&quot;定位实体“{entity}”时出错：{str(e)}&quot;

    # ---- (3) 收集匹配的边（出边 + 入边）----------
    matching_edges = []

    def _edge_ok(edge_data):
        &quot;&quot;&quot;如果边在请求的窗口内是时间有效的，则返回 True。&quot;&quot;&quot;
        valid_at = _as_datetime(edge_data.get(&quot;valid_at&quot;))
        invalid_at = _as_datetime(edge_data.get(&quot;invalid_at&quot;))
        if valid_at and end_date_range &lt; valid_at:
            return False
        if invalid_at and start_date_range &gt;= invalid_at:
            return False
        return True

    # 出边
    try:
        for _, tgt, _, ed in G.out_edges(target_node, data=True, keys=True):
            pred = ed.get(&quot;predicate&quot;, &quot;&quot;).upper()
            if predicate_upper in pred and _edge_ok(ed):
                matching_edges.append(
                    {
                        &quot;subject&quot;: G.nodes[target_node].get(&quot;name&quot;, str(target_node)),
                        &quot;predicate&quot;: pred,
                        &quot;object&quot;: G.nodes[tgt].get(&quot;name&quot;, str(tgt)),
                        **ed,
                    }
                )
    except Exception:
        pass

    # 入边
    try:
        for src, _, _, ed in G.in_edges(target_node, data=True, keys=True):
            pred = ed.get(&quot;predicate&quot;, &quot;&quot;).upper()
            if predicate_upper in pred and _edge_ok(ed):
                matching_edges.append(
                    {
                        &quot;subject&quot;: G.nodes[src].get(&quot;name&quot;, str(src)),
                        &quot;predicate&quot;: pred,
                        &quot;object&quot;: G.nodes[target_node].get(&quot;name&quot;, str(target_node)),
                        **ed,
                    }
                )
    except Exception:
        pass

    # ---- (4) 格式化响应 -----------------------------------
    if not matching_edges:
        s = start_date_range.strftime(&quot;%Y-%m-%d&quot;)
        e = end_date_range.strftime(&quot;%Y-%m-%d&quot;)
        return (
            f&quot;在指定的日期范围（{s} 到 {e}）内未找到与谓词“{predicate}”相关的“{entity}”的数据。&quot;
        )

    lines = [
        f&quot;为“{entity}”和谓词“{predicate}”找到了 {len(matching_edges)} 个关系&quot;
        f&quot;{'s' if len(matching_edges) != 1 else ''}：&quot;,
        &quot;&quot;
    ]

    for idx, edge in enumerate(matching_edges, 1):
        value        = edge.get(&quot;value&quot;)
        statement    = edge.get(&quot;statement&quot;)
        statement_tp = edge.get(&quot;statement_type&quot;)
        valid_from   = edge.get(&quot;valid_at&quot;)

        # 第一行：主语 – 谓词 – 宾语
        triplet = f&quot;{edge['subject']} – {edge['predicate']} – {edge['object']}&quot;
        if valid_from:
            triplet += f&quot;  [有效开始日期： {valid_from}]&quot;
        if value is not None:
            triplet += f&quot;  (值： {value})&quot;
        lines.append(f&quot;{idx}. {triplet}&quot;)

        # 第二行：语句（截断为 200 个字符）+ 类型
        if statement:
            snippet = statement if len(statement) &lt;= 200 else statement[:197] + &quot;…&quot;
            lines.append(f'   语句： &quot;{snippet}&quot;')
        if statement_tp:
            lines.append(f&quot;   类型： {statement_tp}&quot;)

        lines.append(&quot;&quot;)  # 间隔符

    return &quot;\n&quot;.join(lines)
</code></pre>

<pre class="codehilite"><code class="language-python">result = await factual_qa(
    entity=&quot;Amd&quot;,
    start_date_range=datetime(2016, 1, 1),
    end_date_range=datetime(2020, 1, 1),
    predicate=&quot;launched&quot;
)
print(result)
</code></pre>

<pre class="codehilite"><code class="language-python">factual_qa_schema = {
  &quot;type&quot;: &quot;function&quot;,
  &quot;name&quot;: &quot;factual_qa&quot;,
  &quot;description&quot;: &quot;查询知识图谱，以获取涉及给定实体和谓词的时间限制事实关系。&quot;,
  &quot;parameters&quot;: {
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
      &quot;entity&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;要检索其关系实体的名称（例如，公司或组织）。&quot;
      },
      &quot;start_date_range&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;format&quot;: &quot;date&quot;,
        &quot;description&quot;: &quot;过滤事实关系的日期范围的开始（含）。&quot;
      },
      &quot;end_date_range&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;format&quot;: &quot;date&quot;,
        &quot;description&quot;: &quot;过滤事实关系的日期范围的结束（含）。&quot;
      },
      &quot;predicate&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;要与知识图谱匹配的关系或主题的类型（例如，“invested_in”、“founded”）。&quot;
      }
    },
    &quot;required&quot;: [
      &quot;entity&quot;,
      &quot;start_date_range&quot;,
      &quot;end_date_range&quot;,
      &quot;predicate&quot;
    ],
    &quot;additionalProperties&quot;: False
  }
}
</code></pre>

<h5 id="_42">趋势分析</h5>
<p><code>trend_analysis</code> 工具旨在比较特定指标或信号随时间的变化情况——通常跨多个公司和/或主题。它公开了一个结构化接口，允许代理指定时间窗口、主题集和目标指标，然后将比较逻辑委托给专门处理此分析的代理。在此情况下，我们使用了 o4-mini 并进行了高推理工作量，因为这是一项“更难”的分析任务。</p>
<p>这使我们能够为处理比较类任务构建高度专注且优化的管道。虽然这可以内置到核心协调器本身，但将其拆分为专用工具通常更易于管理，以便以后可以轻松地替换或更新它们，而无需过多担心对整个系统的影响。</p>
<pre class="codehilite"><code class="language-python">import asyncio
from datetime import datetime


async def trend_analysis(
    question: str,
    companies: list[str],
    start_date_range: datetime,
    end_date_range: datetime,
    topic_filter: list[str],
) -&gt; str:
    &quot;&quot;&quot;
    聚合多个公司和主题的知识图谱事实。

    对于每个（公司、主题）对，它会调用 `factual_qa`，使用相同
    的时间窗口，并返回一个连接的、人类可读的字符串。

    各部分之间用空行分隔，并以以下内容为前缀：
        === &lt;公司&gt; · &lt;主题&gt; ===

    如果 `factual_qa` 引发异常，则在每个部分中包含一个带有错误消息的 ⚠️ 行。
    &quot;&quot;&quot;

    # -------- 助手 ------------------------------------------------------
    async def _fetch(company: str, predicate: str) -&gt; str:
        return await factual_qa(
            entity=company,
            start_date_range=start_date_range,
            end_date_range=end_date_range,
            predicate=predicate,
        )

    # -------- 安排所有调用（并发执行）--------------------------
    pairs = [(c, p) for c in companies for p in topic_filter]
    tasks = [asyncio.create_task(_fetch(c, p)) for c, p in pairs]

    # -------- 收集结果 ---------------------------------------------
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # -------- 组装最终字符串 --------------------------------------
    sections: list[str] = []
    for (company, predicate), res in zip(pairs, results, strict=True):
        header = f&quot;=== {company} · {predicate} ===&quot;
        if isinstance(res, Exception):
            sections.append(f&quot;{header}\n⚠️  {type(res).__name__}: {res}&quot;)
        else:
            sections.append(f&quot;{header}\n{res}&quot;)

    joined = &quot;\n\n&quot;.join(sections)

    analysis_user_prompt = (
        &quot;您是一位乐于助人的助手&quot;
        &quot;您擅长提供深入的财务数据分析。 &quot;
        &quot;您将获得来自知识图谱的详细数据转储，该知识图谱包含已从公司财报电话会议记录中提取的数据。 \n&quot;
        &quot;请详细总结其中的趋势，尽可能详细地比较数据随时间的变化。 &quot;
        &quot;您的答案应仅包含从提供的数据中得出的信息，请不要依赖您内部的知识。 &quot;
        &quot;知识图谱包含 2016-2020 年的数据。 &quot;
        &quot;提供的数据是： \n&quot;
        f&quot;{joined}\n\n&quot;
        f&quot;您正在为其进行总结的用户问题是： {question}&quot;
    )

    analysis = await client.responses.create(
        model=&quot;o4-mini&quot;,
        input=analysis_user_prompt,
        reasoning={
            &quot;effort&quot;: &quot;high&quot;,
            &quot;summary&quot;: &quot;auto&quot;
        }
    )

    return analysis.output_text
</code></pre>

<pre class="codehilite"><code class="language-python">result = await trend_analysis(
    question=&quot;How have AMD's research priorties changed over time?&quot;,
    companies=[&quot;AMD&quot;],
    start_date_range=datetime(2016, 1, 1),
    end_date_range=datetime(2020, 1, 1),
    topic_filter=[&quot;launched&quot;, &quot;researched&quot;, &quot;developed&quot;]
)
print(result)
</code></pre>

<pre class="codehilite"><code class="language-python">trend_analysis_schema = {
  &quot;type&quot;: &quot;function&quot;,
  &quot;name&quot;: &quot;trend_analysis&quot;,
  &quot;description&quot;: &quot;聚合和比较多个公司和主题在时间范围内的知识图谱事实，并返回趋势摘要。&quot;,
  &quot;parameters&quot;: {
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
      &quot;question&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;description&quot;: &quot;一个自由格式问题，用于指导趋势分析（例如，“公司之间的招聘趋势有何不同？”）。&quot;
      },
      &quot;companies&quot;: {
        &quot;type&quot;: &quot;array&quot;,
        &quot;items&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;description&quot;: &quot;要比较的公司列表（例如，“['Apple'，'Microsoft']”）。&quot;
      },
      &quot;start_date_range&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;format&quot;: &quot;date&quot;,
        &quot;description&quot;: &quot;过滤知识图谱事实的日期范围的开始（含）。&quot;
      },
      &quot;end_date_range&quot;: {
        &quot;type&quot;: &quot;string&quot;,
        &quot;format&quot;: &quot;date&quot;,
        &quot;description&quot;: &quot;过滤知识图谱事实的日期范围的结束（含）。&quot;
      },
      &quot;topic_filter&quot;: {
        &quot;type&quot;: &quot;array&quot;,
        &quot;items&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;description&quot;: &quot;要为每个公司查询的谓词（主题）列表（例如，“['hired_executive'，'launched_product']”）。&quot;
      }
    },
    &quot;required&quot;: [
      &quot;question&quot;,
      &quot;companies&quot;,
      &quot;start_date_range&quot;,
      &quot;end_date_range&quot;,
      &quot;topic_filter&quot;
    ],
    &quot;additionalProperties&quot;: False
  }
}
</code></pre>

<pre class="codehilite"><code class="language-python">tools = [
    factual_qa_schema,
    trend_analysis_schema
]
</code></pre>

<h3 id="416">4.1.6. 检索器</h3>
<p>我们设计了一个简单的检索器，仅包含一个 <code>run</code> 方法，该方法包含规划步骤和一个 while 循环，用于执行协调器进行的所有工具调用，然后返回最终答案。</p>
<pre class="codehilite"><code class="language-python">import json


class MultiStepRetriever:
    &quot;&quot;&quot;使用 OpenAI 客户端分步检索信息。&quot;&quot;&quot;
    def __init__(self, client: AsyncOpenAI):
        self.client = client
        # 这有助于我们简化 run() 中的工具调用功能
        self.function_map = {
            &quot;factual_qa&quot;: factual_qa,
            &quot;trend_analysis&quot;: trend_analysis
        }

    async def run(self, user_question: str) -&gt; tuple[str, dict]:
        &quot;&quot;&quot;为用户问题运行多步检索过程。&quot;&quot;&quot;
        # -------------------------------------------------------
        # 步骤 1：生成初始计划
        # -------------------------------------------------------

        initial_plan = await initial_planner(user_question=user_question)

        # -------------------------------------------------------
        # 步骤 2：进行初始模型调用
        # -------------------------------------------------------

        retriever_user_prompt = (
            &quot;您是一位乐于助人的助手。&quot;
            &quot;您将获得一个用户问题：\n\n&quot;
            f&quot;{user_question} \n\n&quot;
            &quot;您可以使用一组工具。您可以选择使用这些工具来检索信息，以帮助您回答用户的问题。 &quot;
            &quot;这些工具允许您查询包含从公司财报电话会议记录中提取的信息的知识图谱。 &quot;
            &quot;您不应使用自己对这些公司的记忆来回答问题。 &quot;
            &quot;在向用户返回答案时，您的所有内容都必须来自您通过所使用的工具检索到的内容。 &quot;
            &quot;这是为了确保其准确性，因为此知识图谱中的数据经过仔细检查以确保其准确性。 &quot;
            &quot;知识图谱包含 2016-2020 年的数据。\n\n&quot;
            &quot;您将获得以下行动计划： \n&quot;
            f&quot;{initial_plan} \n\n&quot;
            &quot;您通常应遵循此计划来帮助回答问题，但如果您认为合适，可以偏离计划。 &quot;
            &quot;您可以进行多次工具调用。&quot;
        )

        input_messages = [
            {&quot;role&quot;:&quot;user&quot;, &quot;content&quot;:retriever_user_prompt}
        ]

        response = await self.client.responses.create(
            model=&quot;gpt-4.1&quot;,
            input=input_messages,
            tools=tools,
            parallel_tool_calls=False,
        )

        # -------------------------------------------------------
        # 步骤 3：直到不再进行工具调用为止的循环
        # -------------------------------------------------------

        tools_used = {}

        while response.output[0].type == &quot;function_call&quot;:
            tool_call = response.output[0]
            args = json.loads(tool_call.arguments)
            name = tool_call.name

            if name in self.function_map:
                tool_func = self.function_map[name]
                tool_response_text = await tool_func(**args)

                input_messages.append(tool_call)
                input_messages.append({
                    &quot;type&quot;: &quot;function_call_output&quot;,
                    &quot;call_id&quot;: tool_call.call_id,
                    &quot;output&quot;: tool_response_text
                })

            tools_used[name] = [args, tool_response_text]

            response = await self.client.responses.create(
                model=&quot;gpt-4.1&quot;,
                input=input_messages,
                tools=tools,
                parallel_tool_calls=False
            )

        return response.output_text, tools_used
</code></pre>

<p>我们可以运行我们的 MultiStepRetriever。</p>
<p>我们观察到返回的答案很详细，并且包括了 AMD 的研发重点如何从 2016 年到 2020 年演变的详细演练，并引用了用于推导这些答案的底层引述。</p>
<pre class="codehilite"><code class="language-python">retriever = MultiStepRetriever(client=client)

answer, tools_used = await retriever.run(user_question=&quot;How have AMD's research &amp; development priorities changed over time?&quot;)

print(answer)
</code></pre>

<p>我们还可以检查 MultiStepRetriever 用于回答此查询的工具。</p>
<pre class="codehilite"><code class="language-python">for key, value in tools_used.items():
    if value:
        print(f&quot;{key}: {value[0]}&quot;)
    else:
        print(f&quot;{key}: [empty list]&quot;)
</code></pre>

<p><a href="Appendix.ipynb">附录 A.5。“扩展和生产化我们的检索代理”</a>概述了如何将我们构建的检索代理投入生产的一些指南。</p>
<h3 id="417">4.1.7. 为多步知识图谱检索选择合适的模型</h3>
<p>多步检索代理需要强大的推理能力来跨越实体和关系进行跳转、验证答案以及决定下一步操作。延迟仍然对用户很重要，但通常<em>不如</em>原始准确性重要。因此，这是 OpenAI 的 o3 和 o4-mini 推理模型表现出色的领域之一。</p>
<p>同样，对于开发，我们建议采用“先做大，再专业化”的阶梯：</p>
<ol>
<li><strong>从 o3 开始</strong>——确保您的检索逻辑（链接、重新排序、回退提示）是健全的。如果您的检索系统处理的数据特别复杂，例如制药或法律数据，o3 也可能是生产中的最佳选择。您可以通过观察使用较小模型时性能下降的严重程度来测试这一点。如果性能下降幅度很大，请考虑坚持使用 o3。</li>
<li><strong>迁移到 o4-mini</strong>
   * <strong>提示增强</strong> - 优化您的提示，使 o4-mini 系统的性能尽可能接近完整 o3 模型。
   * <strong>强化微调 (RFT)</strong> - <a href="https://platform.openai.com/docs/guides/reinforcement-fine-tuning">OpenAI 的强化微调</a> 功能使您能够微调 OpenAI 的 o 系列模型，以提高它们在困难推理任务上的性能。只需约 50 个黄金答案，您就可以利用强化学习的力量来微调 o4-mini，这可以帮助它在同一任务上接近甚至超越基础 o3 的性能。</li>
<li><strong>当延迟占主导地位时回退到 GPT 4.1</strong> - 对于延迟特别重要或您已充分调整提示以至于性能下降最小的情况，请考虑迁移到 GPT 4.1 系列。</li>
</ol>
<p>| 模型       | 相对成本 | 相对延迟 | 智能 | 工作流程中的理想角色                   |</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>相对成本</th>
<th>相对延迟</th>
<th>智能</th>
<th>工作流程中的理想角色</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>o3</em></td>
<td>★★★</td>
<td>★★</td>
<td>★★★ <em>(最高)</em></td>
<td>初始原型设计、处理复杂数据、黄金数据集生成</td>
</tr>
<tr>
<td><em>o4-mini</em></td>
<td>★★</td>
<td>★</td>
<td>★★</td>
<td>主要生产引擎，可通过 RFT 提升性能</td>
</tr>
<tr>
<td><em>GPT 4.1 系列</em></td>
<td>★ <em>(最低)</em></td>
<td>★ <em>(最快)</em></td>
<td>★</td>
<td>延迟关键或大规模后台评分</td>
</tr>
</tbody>
</table>
<h4 id="_43">为什么强化微调对于长周期、多步检索任务如此强大？</h4>
<p>与<a href="https://platform.openai.com/docs/guides/supervised-fine-tuning">监督微调</a>或<a href="https://platform.openai.com/docs/guides/direct-preference-optimization">直接偏好优化</a>相比，RFT 在此用例方面具有许多优势。</p>
<p>首先，强化微调可以使用少得多的示例进行，有时只需要大约 50 个训练示例。</p>
<p>此外，RFT 无需提供标记的逐步轨迹。只需提供最终的正确答案，系统即可隐式学习如何有效地遍历知识图谱。此功能在现实世界环境中特别有价值，因为最终用户通常时间紧迫，并且可能难以整理传统 SFT 方法所需的（通常是数百或数千个）标记示例集。</p>
<h2 id="42">4.2 评估检索系统</h2>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">

  <!-- 1. 人工注释的“黄金答案” -->
  <li style="margin-bottom: 1.2em;">
    <strong>人工注释的“黄金答案”</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      检索评估的传统基准：一套由领域专家审核的*查询 → 黄金答案*对。
      通过将检索到的段落与这些黄金跨度进行匹配来计算 precision@k 或 recall@k 等指标。
    </p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      <strong>优点： </strong>最高可靠性，清晰的通过/失败阈值，非常适合回归测试<br />
      <strong>缺点： </strong>创建成本高，更新慢，覆盖范围窄（当知识库发展时很快就会过时）
    </p>
  </li>

  <!-- 2. 合成生成的答案 -->
  <li style="margin-bottom: 1.2em;">
    <strong>合成生成的答案</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      使用 LLM 生成参考答案或判断，从而实现快速、低成本的评估集扩展。
      三种常见途径：
    </p>
    <ul style="list-style: disc; padding-left: 1em; margin-top: 0.25em; margin-bottom: 0.5em;">
      <li><strong>LLM 作为裁判</strong>：将查询、检索到的段落和候选答案输入到裁判模型，该模型输出评分或例如“是/部分/否”</li>
      <li><strong>工具使用路径</strong>：对于不同的问题类型，您可以手动或合成地生成“正确”的工具使用路径，并根据此路径对响应进行评分</li>
    </ul>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      <strong>优点： </strong>快速、无限可扩展、更容易跟上动态应用程序规范<br />
      <strong>缺点： </strong>判断质量通常低于专家人工注释的解决方案
    </p>
  </li>

  <!-- 3. 人工反馈 -->
  <li style="margin-bottom: 1.2em;">
    <strong>人工反馈</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      直接从最终用户或领域审阅者那里收集评分（点赞/踩、五星评分、成对比较）。可以<em>在循环中</em>（模型持续训练实时反馈）或<em>离线</em>（定期评估轮次）。
    </p>
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
      <strong>优点： </strong>捕捉实际效用，揭示合成测试遗漏的边缘情况<br />
      <strong>缺点： </strong>嘈杂且主观；需要周到的聚合（例如，ELO 评分），用户偏见可能被纳入模型的风险
    </p>
  </li>

</ol>

<h3 id="_44">哪种评估方法最好？</h3>
<p>没有唯一最好的方法。但是，我们发现一个在项目中效果很好的工作流程是：</p>
<ol>
<li>开始构建并迭代合成评估</li>
<li>在部署前使用黄金人工评估集进行测试</li>
<li>让最终用户轻松注释好答案和坏答案，并利用这些反馈继续发展您的应用程序</li>
</ol>
<h1 id="5">5. 原型到生产</h1>
<hr />
<p>将知识图谱系统从概念验证过渡到健壮的、生产级的管道需要您解决几个关键问题：</p>
<ul>
<li><strong>存储和检索高容量图数据</strong></li>
<li><strong>管理和修剪数据集</strong></li>
<li><strong>在摄取管道中实现并发</strong></li>
<li><strong>最小化令牌成本</strong></li>
<li><strong>扩展检索代理</strong></li>
<li><strong>安全措施</strong></li>
</ul>
<p>本节将引导您了解关键的考虑因素和最佳实践，以确保您的时间感知知识图谱能够在实际环境中可靠运行。您可以在本手册的存储库中找到更详细的<a href="./Appendix.ipynb">原型到生产附录部分</a>。</p>
<ol style="margin-left: 1em; line-height: 1.6; padding-left: 0.5em;">

<li style="margin-bottom: 1.2em;">
  <strong>存储和检索高容量图数据</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.1.2。“存储和检索高容量图数据”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    通过周到的模式设计、分片和分区来管理可扩展性。清晰地定义实体、关系，并确保模式的灵活性以适应未来的演变。使用时间戳等高基数字段进行高效数据分区。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>时间有效性和版本控制</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.1.2。“时间有效性和版本控制”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    为每个语句包含时间标记（valid_from、valid_to）。通过将过时的事实标记为非活动状态并索引时间字段以进行高效查询来非破坏性地维护历史记录。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>索引和语义搜索</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.1.3。“索引和语义搜索”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    利用 B 树索引进行高效的时间查询。利用 PostgreSQL 的 pgvector 扩展通过近似最近邻算法（如 ivfflat、ivfpq 和 hnsw）进行语义搜索，以优化查询速度和内存使用。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>管理和修剪数据集</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.2。“管理和修剪数据集”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    根据来源可靠性和相关性建立数据保留的 TTL 和归档策略。实施自动归档任务和具有相关性评分的智能修剪以优化图谱大小。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>并发摄取管道</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.3。“在摄取管道中实现并发”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    为分块、提取、无效化和实体解析实现具有独立、可扩展管道阶段的批处理。优化吞吐量和并行性以管理摄取瓶颈。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>最小化令牌成本</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.4。“最小化令牌成本”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    使用缓存策略避免冗余的 API 调用。采用 OpenAI 的 flex 选项等服务层来降低成本，并用高效的嵌入和最近邻搜索替换昂贵的模型查询。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>扩展检索代理</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.5。“扩展和生产化我们的检索代理”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    使用控制器和遍历工作程序架构来处理多跳查询。实现并行子图提取、具有链式推理的动态遍历、缓存和自动缩放以实现高性能。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>安全措施和验证</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.6。“安全措施”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    部署多层输出验证、结构化日志记录和监控，以确保数据完整性和操作可靠性。跟踪关键指标并执行定期审计。
  </p>
</li>

<li style="margin-bottom: 1.2em;">
  <strong>提示优化</strong><br />
    <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    <a href="./Appendix.ipynb">附录 A.7。“提示优化”</a>
  </p>
  <p style="margin-top: 0.5em; margin-bottom: 0.5em;">
    通过角色扮演、少量提示、思维链方法、动态上下文管理和提示变体的自动 A/B 测试来优化 LLM 交互，以实现持续的性能改进。
  </p>
</li>

</ol>

<h2 id="_45">结束语</h2>
<p>本手册为您提供了构建和部署时间感知知识图谱以及强大的多跳检索功能的基础技术和具体工作流程。</p>
<p>无论您是从原型开始还是在完善生产系统，利用结构化图数据和 OpenAI 模型都可以解锁更丰富、更细致的数据交互。随着这些技术的快速发展，请关注 OpenAI 模型阵容的更新，并继续试验索引方法和检索策略，以持续改进您的知识中心 AI 解决方案。</p>
<p>通过自定义提供的本体和优化提取提示，您可以轻松地将本手册中提出的框架改编到您各自的领域。将 Neo4j 作为图数据库进行替换，可以使您朝着 MVP 级应用程序迈出坚实的一步，从而开箱即用地提供数据持久性。它还为将检索器的工具升级为 Cypher 查询打开了大门。</p>
<p>通过利用合成评估进行迭代开发，然后针对“黄金”专家人工注释解决方案测试您的解决方案。一旦投入生产，您就可以从用户反馈中快速迭代，将您的应用程序推向新的高度。</p>
<h2 id="_46">贡献者</h2>
<p>本手册是 OpenAI 和 <a href="https://tomoro.ai/">Tomoro</a> 的合作成果。</p>
<ul>
<li><a href="https://www.linkedin.com/in/alexandra-heald/">Alex Heald</a></li>
<li><a href="https://www.linkedin.com/in/douglas-adams99/">Douglas Adams</a></li>
<li><a href="https://www.linkedin.com/in/rish-sagar/">Rishabh Sagar</a></li>
<li><a href="https://www.linkedin.com/in/dannywigg/">Danny Wigg</a></li>
<li><a href="https://www.linkedin.com/in/shikharkwatra/">Shikhar Kwatra</a></li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="articles/techniques_to_improve_reliability_zh.html" class="nav-link prev">← 提高可靠性的技术</a><a href="articles/text_comparison_examples_zh.html" class="nav-link next">文本比较示例 →</a></nav>
        </main>
    </div>
</body>
</html>
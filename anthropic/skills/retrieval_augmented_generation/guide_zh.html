<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="../../">
    <title>Retrieval Augmented Generation (RAG)</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">extended_thinking</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="extended_thinking/extended_thinking_with_tool_use_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">扩展思考与工具使用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="extended_thinking/extended_thinking_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">扩展思考</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">finetuning</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="finetuning/finetuning_on_bedrock_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">在 Bedrock 上微调 Claude 3 Haiku</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">misc</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/batch_processing_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">批量处理消息批次API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/building_evals_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">建立评估</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/building_moderation_filter_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">建立一个带有 Claude 的审核过滤器</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/generate_test_cases_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">首先，我们有 `extract_variables` 函数，</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/how_to_enable_json_mode_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">提示 Claude 获取“JSON 模式”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/how_to_make_sql_queries_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 Claude 进行 SQL 查询</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/illustrated_responses_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 的图示化响应</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/mc_qa_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">实验性测试 Claude 的长上下文问答能力</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/metaprompt_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Metaprompt</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/pdf_upload_summarization_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">“上传”PDF 到 Claude API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/prompt_caching_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">缓存提示（Prompt caching）通过 Anthropic API</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/read_web_pages_with_haiku_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Claude 3 Haiku 总结网页内容</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/sampling_past_max_tokens_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 从 Claude 之外的采样响应，超出最大令牌限制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/speculative_prompt_caching_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">投机性提示缓存</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="misc/using_citations_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">引言</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">multimodal</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="multimodal/best_practices_for_vision_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="multimodal/getting_started_with_vision_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">开始上手 - 如何将图像传递给 Claude</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="multimodal/how_to_transcribe_text_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 Claude 转录文档</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="multimodal/reading_charts_graphs_powerpoints_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用图表和幻灯片放映</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="multimodal/using_sub_agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Haiku 作为子代理</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">patterns</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">agents</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="patterns/agents/basic_workflows_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">首先使用具有思维链的LLM确定适当的路由</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="patterns/agents/evaluator_optimizer_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="patterns/agents/orchestrator_workers_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">步骤1：获取协调器响应</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="patterns/agents/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">构建高效代理的食谱</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">prompts</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="patterns/agents/prompts/citations_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="patterns/agents/prompts/research_lead_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="patterns/agents/prompts/research_subagent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </div></div></div></div></div></div>
                    <div class="tree-folder expanded" data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">skills</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="skills/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 技能</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">classification</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/classification/guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">设置我们的环境</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/classification/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 分类指南</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">evaluation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="skills/classification/evaluation/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Promptfoo 进行评估</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">contextual-embeddings</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/contextual-embeddings/guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">增强检索的RAG与上下文检索</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/contextual-embeddings/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">结合上下文嵌入的检索增强生成</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder expanded" data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">retrieval_augmented_generation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item active" style="padding-left: 40px;">
                        <a href="skills/retrieval_augmented_generation/guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Retrieval Augmented Generation (RAG)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/retrieval_augmented_generation/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">evaluation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="skills/retrieval_augmented_generation/evaluation/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Promptfoo 进行评估</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">summarization</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/summarization/guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">摘要与 Claude</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/summarization/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 摘要</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">evaluation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="skills/summarization/evaluation/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Promptfoo 评估</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">text_to_sql</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/text_to_sql/guide_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Set your Anthropic API key</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="skills/text_to_sql/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Claude 的文本到 SQL</span>
                        </a>
                    </div>
                
                    <div class="tree-folder " data-level="2" style="padding-left: 40px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">evaluation</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 60px;">
                        <a href="skills/text_to_sql/evaluation/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Promptfoo 评估</span>
                        </a>
                    </div>
                </div></div></div></div></div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">third_party</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">Deepgram</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/Deepgram/prerecorded_audio_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">转录深蓝音频文件并使用 Anthropic 准备面试问题！</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/Deepgram/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Deepgram <> Anthropic Cookbooks</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">LlamaIndex</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/Basic_RAG_With_LlamaIndex_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">RAG 管道与 LlamaIndex</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/Multi_Document_Agents_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">多文档代理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/Multi_Modal_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">多模态</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/ReAct_Agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">ReAct Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/README_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">LlamaIndex <> Anthropic Cookbooks</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/Router_Query_Engine_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">注意：这仅在 jupyter notebook 中是必需的。</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/LlamaIndex/SubQuestion_Query_Engine_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">SubQuestionQueryEngine</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">MongoDB</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/MongoDB/rag_using_mongodb_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">如何使用 Claude 3 和 MongoDB 构建 RAG 系统</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">Pinecone</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/Pinecone/claude_3_rag_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">检查 Python 版本</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/Pinecone/rag_using_pinecone_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Pinecone 进行检索增强生成</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">VoyageAI</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/VoyageAI/how_to_create_embeddings_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">这将自动使用环境变量VOYAGE_API_KEY。</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">Wikipedia</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/Wikipedia/wikipedia-search-cookbook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">迭代搜索维基百科与 Claude</span>
                        </a>
                    </div>
                </div></div>
                    <div class="tree-folder " data-level="1" style="padding-left: 20px;">
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">WolframAlpha</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 40px;">
                        <a href="third_party/WolframAlpha/using_llm_api_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Wolfram Alpha LLM API 作为 Claude 的工具</span>
                        </a>
                    </div>
                </div></div></div></div>
                    <div class="tree-folder " data-level="0" >
                        <div class="tree-folder-header">
                            <span class="tree-arrow">▶</span>
                            <span class="tree-icon"></span>
                            <span class="tree-title">tool_use</span>
                        </div>
                        <div class="tree-folder-content">
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/calculator_tool_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用计算器工具与 Claude</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/customer_service_agent_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用客户端工具创建客服代理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/extracting_structured_json_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Claude 和工具使用功能提取结构化 JSON</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/memory_cookbook_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">安装依赖</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/parallel_tools_claude_3_7_sonnet_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">在 Claude 3.7 Sonnet 上并行调用工具</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/tool_choice_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">选择工具</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/tool_use_with_pydantic_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">记事工具，支持 Pydantic 和 Anthropic 工具使用</span>
                        </a>
                    </div>
                
                    <div class="tree-item " style="padding-left: 20px;">
                        <a href="tool_use/vision_with_tools_zh.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">使用 Vision 与工具</span>
                        </a>
                    </div>
                </div></div></nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="retrieval-augmented-generation-rag">Retrieval Augmented Generation (RAG)</h1>
<p>Claude excels at a wide range of tasks, but it may struggle with queries specific to your unique business context. This is where Retrieval Augmented Generation (RAG) becomes invaluable. RAG enables Claude to leverage your internal knowledge bases or customer support documents, significantly enhancing its ability to answer domain-specific questions. Enterprises are increasingly building RAG applications to improve workflows in customer support, Q&amp;A over internal company documents, financial &amp; legal analysis, and much more.</p>
<p>In this guide, we'll demonstrate how to build and optimize a RAG system using the Anthropic documentation as our knowledge base. We'll walk you through:</p>
<p>1) Setting up a basic RAG system using an in-memory vector database and embeddings from <a href="https://www.voyageai.com/">Voyage AI</a>.</p>
<p>2) Building a robust evaluation suite. We'll go beyond 'vibes' based evals and show you how to measure the retrieval pipeine &amp; end to end performance independently.</p>
<p>3) Implementing advanced techniques to improve RAG including summary indexing and re-ranking with Claude.</p>
<p>Through a series of targeted improvements, we achieved significant performance gains on the following metrics compared to a basic RAG pipeline (we'll explain what all these metrics <em>mean</em> in a bit)</p>
<ul>
<li>Avg Precision: 0.43 --&gt; 0.44</li>
<li>Avg Recall: 0.66 --&gt; 0.69</li>
<li>Avg F1 Score: 0.52 --&gt; 0.54</li>
<li>Avg Mean Reciprocal Rank (MRR): 0.74 --&gt; 0.87</li>
<li>End-to-End Accuracy: 71% --&gt; 81%</li>
</ul>
<h4 id="note">Note:</h4>
<p>The evaluations in this cookbook are meant to mirror a production evaluation system, and you should keep in mind that they can take a while to run. Also of note: if you run the evaluations in full, you may come up against rate limits unless you are in <a href="https://docs.anthropic.com/en/api/rate-limits">Tier 2 and above</a>. Consider skipping the full end to end eval if you're trying to conserve token usage.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<p>1) Setup</p>
<p>2) Level 1 - Basic RAG</p>
<p>3) Building an Evaluation System</p>
<p>4) Level 2 - Summary Indexing</p>
<p>5) Level 3 - Summary Indexing and Re-Ranking</p>
<h2 id="setup">Setup</h2>
<p>We'll need a few libraries, including:</p>
<p>1) <code>anthropic</code> - to interact with Claude</p>
<p>2) <code>voyageai</code> - to generate high quality embeddings</p>
<p>3) <code>pandas</code>, <code>numpy</code>, <code>matplotlib</code>, and <code>scikit-learn</code> for data manipulation and visualization</p>
<p>You'll also need API keys from <a href="https://www.anthropic.com/">Anthropic</a> and <a href="https://www.voyageai.com/">Voyage AI</a></p>
<pre class="codehilite"><code class="language-python">## setup
!pip install anthropic
!pip install voyageai
!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install seaborn
!pip install -U scikit-learn
</code></pre>

<pre class="codehilite"><code>Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: anthropic in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (0.34.1)
Requirement already satisfied: anyio&lt;5,&gt;=3.5.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (3.7.1)
Requirement already satisfied: distro&lt;2,&gt;=1.7.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (1.8.0)
Requirement already satisfied: httpx&lt;1,&gt;=0.23.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (0.25.2)
Requirement already satisfied: jiter&lt;1,&gt;=0.4.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (0.4.0)
Requirement already satisfied: pydantic&lt;3,&gt;=1.9.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (2.7.2)
Requirement already satisfied: sniffio in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (1.3.0)
Requirement already satisfied: tokenizers&gt;=0.13.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (0.13.3)
Requirement already satisfied: typing-extensions&lt;5,&gt;=4.7 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anthropic) (4.11.0)
Requirement already satisfied: idna&gt;=2.8 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from anyio&lt;5,&gt;=3.5.0-&gt;anthropic) (3.4)
Requirement already satisfied: certifi in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from httpx&lt;1,&gt;=0.23.0-&gt;anthropic) (2023.11.17)
Requirement already satisfied: httpcore==1.* in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from httpx&lt;1,&gt;=0.23.0-&gt;anthropic) (1.0.2)
Requirement already satisfied: h11&lt;0.15,&gt;=0.13 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from httpcore==1.*-&gt;httpx&lt;1,&gt;=0.23.0-&gt;anthropic) (0.14.0)
Requirement already satisfied: annotated-types&gt;=0.4.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pydantic&lt;3,&gt;=1.9.0-&gt;anthropic) (0.6.0)
Requirement already satisfied: pydantic-core==2.18.3 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pydantic&lt;3,&gt;=1.9.0-&gt;anthropic) (2.18.3)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: voyageai in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (0.2.2)
Requirement already satisfied: aiohttp&lt;4.0,&gt;=3.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from voyageai) (3.9.3)
Requirement already satisfied: aiolimiter&lt;2.0.0,&gt;=1.1.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from voyageai) (1.1.0)
Requirement already satisfied: numpy&gt;=1.11 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from voyageai) (1.24.4)
Requirement already satisfied: requests&lt;3.0,&gt;=2.20 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from voyageai) (2.31.0)
Requirement already satisfied: tenacity&gt;=8.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from voyageai) (8.4.1)
Requirement already satisfied: aiosignal&gt;=1.1.2 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from aiohttp&lt;4.0,&gt;=3.5-&gt;voyageai) (1.3.1)
Requirement already satisfied: attrs&gt;=17.3.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from aiohttp&lt;4.0,&gt;=3.5-&gt;voyageai) (22.1.0)
Requirement already satisfied: frozenlist&gt;=1.1.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from aiohttp&lt;4.0,&gt;=3.5-&gt;voyageai) (1.4.0)
Requirement already satisfied: multidict&lt;7.0,&gt;=4.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from aiohttp&lt;4.0,&gt;=3.5-&gt;voyageai) (6.0.4)
Requirement already satisfied: yarl&lt;2.0,&gt;=1.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from aiohttp&lt;4.0,&gt;=3.5-&gt;voyageai) (1.9.2)
Requirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from requests&lt;3.0,&gt;=2.20-&gt;voyageai) (3.3.2)
Requirement already satisfied: idna&lt;4,&gt;=2.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from requests&lt;3.0,&gt;=2.20-&gt;voyageai) (3.4)
Requirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from requests&lt;3.0,&gt;=2.20-&gt;voyageai) (1.26.18)
Requirement already satisfied: certifi&gt;=2017.4.17 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from requests&lt;3.0,&gt;=2.20-&gt;voyageai) (2023.11.17)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: pandas in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (2.0.3)
Requirement already satisfied: python-dateutil&gt;=2.8.2 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas) (2.8.2)
Requirement already satisfied: pytz&gt;=2020.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas) (2023.3)
Requirement already satisfied: tzdata&gt;=2022.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas) (2023.3)
Requirement already satisfied: numpy&gt;=1.21.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas) (1.24.4)
Requirement already satisfied: six&gt;=1.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas) (1.16.0)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: numpy in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (1.24.4)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: matplotlib in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (3.7.2)
Requirement already satisfied: contourpy&gt;=1.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (1.2.1)
Requirement already satisfied: cycler&gt;=0.10 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (0.11.0)
Requirement already satisfied: fonttools&gt;=4.22.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (4.41.1)
Requirement already satisfied: kiwisolver&gt;=1.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (1.4.4)
Requirement already satisfied: numpy&gt;=1.20 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (1.24.4)
Requirement already satisfied: packaging&gt;=20.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (23.2)
Requirement already satisfied: pillow&gt;=6.2.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (10.3.0)
Requirement already satisfied: pyparsing&lt;3.1,&gt;=2.3.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (3.0.9)
Requirement already satisfied: python-dateutil&gt;=2.7 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib) (2.8.2)
Requirement already satisfied: six&gt;=1.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.16.0)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: seaborn in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (0.12.2)
Requirement already satisfied: numpy!=1.24.0,&gt;=1.17 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from seaborn) (1.24.4)
Requirement already satisfied: pandas&gt;=0.25 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from seaborn) (2.0.3)
Requirement already satisfied: matplotlib!=3.6.1,&gt;=3.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from seaborn) (3.7.2)
Requirement already satisfied: contourpy&gt;=1.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (1.2.1)
Requirement already satisfied: cycler&gt;=0.10 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (0.11.0)
Requirement already satisfied: fonttools&gt;=4.22.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (4.41.1)
Requirement already satisfied: kiwisolver&gt;=1.0.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (1.4.4)
Requirement already satisfied: packaging&gt;=20.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (23.2)
Requirement already satisfied: pillow&gt;=6.2.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (10.3.0)
Requirement already satisfied: pyparsing&lt;3.1,&gt;=2.3.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (3.0.9)
Requirement already satisfied: python-dateutil&gt;=2.7 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (2.8.2)
Requirement already satisfied: pytz&gt;=2020.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas&gt;=0.25-&gt;seaborn) (2023.3)
Requirement already satisfied: tzdata&gt;=2022.1 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from pandas&gt;=0.25-&gt;seaborn) (2023.3)
Requirement already satisfied: six&gt;=1.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib!=3.6.1,&gt;=3.1-&gt;seaborn) (1.16.0)
Looking in indexes: https://reader2:****@artifactory.infra.ant.dev/artifactory/api/pypi/pypi-all/simple
Requirement already satisfied: scikit-learn in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (1.5.1)
Requirement already satisfied: numpy&gt;=1.19.5 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from scikit-learn) (1.24.4)
Requirement already satisfied: scipy&gt;=1.6.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from scikit-learn) (1.11.1)
Requirement already satisfied: joblib&gt;=1.2.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from scikit-learn) (1.3.1)
Requirement already satisfied: threadpoolctl&gt;=3.1.0 in /opt/homebrew/Caskroom/miniforge/base/envs/py311/lib/python3.11/site-packages (from scikit-learn) (3.2.0)
</code></pre>

<pre class="codehilite"><code>```python
import os

os.environ['VOYAGE_API_KEY'] = &quot;VOYAGE KEY HERE&quot;
os.environ['ANTHROPIC_API_KEY'] = &quot;ANTHROPIC KEY HERE&quot;
</code></pre>

<pre class="codehilite"><code class="language-python">import anthropic
import os

client = anthropic.Anthropic(
    # This is the default and can be omitted
    api_key=os.getenv(&quot;ANTHROPIC_API_KEY&quot;),
)
</code></pre>

<h3 id="initialize-a-vector-db-class">Initialize a Vector DB Class</h3>
<p>In this example, we're using an in-memory vector DB, but for a production application, you may want to use a hosted solution. </p>
<pre class="codehilite"><code class="language-python">import os
import pickle
import json
import numpy as np
import voyageai

class VectorDB:
    def __init__(self, name, api_key=None):
        if api_key is None:
            api_key = os.getenv(&quot;VOYAGE_API_KEY&quot;)
        self.client = voyageai.Client(api_key=api_key)
        self.name = name
        self.embeddings = []
        self.metadata = []
        self.query_cache = {}
        self.db_path = f&quot;./data/{name}/vector_db.pkl&quot;

    def load_data(self, data):
        if self.embeddings and self.metadata:
            print(&quot;Vector database is already loaded. Skipping data loading.&quot;)
            return
        if os.path.exists(self.db_path):
            print(&quot;Loading vector database from disk.&quot;)
            self.load_db()
            return

        texts = [f&quot;Heading: {item['chunk_heading']}\n\n Chunk Text:{item['text']}&quot; for item in data]
        self._embed_and_store(texts, data)
        self.save_db()
        print(&quot;Vector database loaded and saved.&quot;)

    def _embed_and_store(self, texts, data):
        batch_size = 128
        result = [
            self.client.embed(
                texts[i : i + batch_size],
                model=&quot;voyage-2&quot;
            ).embeddings
            for i in range(0, len(texts), batch_size)
        ]
        self.embeddings = [embedding for batch in result for embedding in batch]
        self.metadata = data

    def search(self, query, k=5, similarity_threshold=0.75):
        if query in self.query_cache:
            query_embedding = self.query_cache[query]
        else:
            query_embedding = self.client.embed([query], model=&quot;voyage-2&quot;).embeddings[0]
            self.query_cache[query] = query_embedding

        if not self.embeddings:
            raise ValueError(&quot;No data loaded in the vector database.&quot;)

        similarities = np.dot(self.embeddings, query_embedding)
        top_indices = np.argsort(similarities)[::-1]
        top_examples = []

        for idx in top_indices:
            if similarities[idx] &gt;= similarity_threshold:
                example = {
                    &quot;metadata&quot;: self.metadata[idx],
                    &quot;similarity&quot;: similarities[idx],
                }
                top_examples.append(example)

                if len(top_examples) &gt;= k:
                    break
        self.save_db()
        return top_examples

    def save_db(self):
        data = {
            &quot;embeddings&quot;: self.embeddings,
            &quot;metadata&quot;: self.metadata,
            &quot;query_cache&quot;: json.dumps(self.query_cache),
        }
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        with open(self.db_path, &quot;wb&quot;) as file:
            pickle.dump(data, file)

    def load_db(self):
        if not os.path.exists(self.db_path):
            raise ValueError(&quot;Vector database file not found. Use load_data to create a new database.&quot;)
        with open(self.db_path, &quot;rb&quot;) as file:
            data = pickle.load(file)
        self.embeddings = data[&quot;embeddings&quot;]
        self.metadata = data[&quot;metadata&quot;]
        self.query_cache = json.loads(data[&quot;query_cache&quot;])
</code></pre>

<h2 id="level-1-basic-rag">Level 1 - Basic RAG</h2>
<p>To get started, we'll set up a basic RAG pipeline using a bare bones approach. This is sometimes called 'Naive RAG' by many in the industry. A basic RAG pipeline includes the following 3 steps:</p>
<p>1) Chunk documents by heading - containing only the content from each subheading</p>
<p>2) Embed each document</p>
<p>3) Use Cosine similarity to retrieve documents in order to answer query</p>
<pre class="codehilite"><code class="language-python">import json
import matplotlib.pyplot as plt
import xml.etree.ElementTree as ET
from tqdm import tqdm
import logging
from typing import Callable, List, Dict, Any, Tuple, Set

# Load the evaluation dataset
with open('evaluation/docs_evaluation_dataset.json', 'r') as f:
    eval_data = json.load(f)

# Load the Anthropic documentation
with open('data/anthropic_docs.json', 'r') as f:
    anthropic_docs = json.load(f)

# Initialize the VectorDB
db = VectorDB(&quot;anthropic_docs&quot;)
db.load_data(anthropic_docs)

def retrieve_base(query, db):
    results = db.search(query, k=3)
    context = &quot;&quot;
    for result in results:
        chunk = result['metadata']
        context += f&quot;\n{chunk['text']}\n&quot;
    return results, context

def answer_query_base(query, db):
    documents, context = retrieve_base(query, db)
    prompt = f&quot;&quot;&quot;
    You have been tasked with helping us to answer the following query: 
    &lt;query&gt;
    {query}
    &lt;/query&gt;
    You have access to the following documents which are meant to provide context as you answer the query:
    &lt;documents&gt;
    {context}
    &lt;/documents&gt;
    Please remain faithful to the underlying context, and only deviate from it if you are 100% sure that you know the answer already. 
    Answer the question now, and avoid providing preamble such as 'Here is the answer', etc
    &quot;&quot;&quot;
    response = client.messages.create(
        model=&quot;claude-3-haiku-20240307&quot;,
        max_tokens=2500,
        messages=[
            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}
        ],
        temperature=0
    )
    return response.content[0].text
</code></pre>

<pre class="codehilite"><code>Loading vector database from disk.
</code></pre>

<h2 id="eval-setup">Eval Setup</h2>
<p>When evaluating RAG applications, it's critical to evaluate the performance of the retrieval system and end to end system separately.</p>
<p>We synthetically generated an evaluation dataset consisting of 100 samples which include the following:</p>
<ul>
<li>A question</li>
<li>Chunks from our docs which are relevant to that question. This is what we expect our retrieval system to retrieve when the question is asked</li>
<li>A correct answer to the question.</li>
</ul>
<p>This is a relatively challenging dataset. Some of our questions require synthesis between more than one chunk in order to be answered correctly, so it's important that our system can load in more than one chunk at a time. You can inspect the dataset by opening <code>evaluation/docs_evaluation_dataset.json</code></p>
<p>Run the next cell to see a preview of the dataset</p>
<pre class="codehilite"><code class="language-python">#previewing our eval dataset
import json

def preview_json(file_path, num_items=3):
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)

        if isinstance(data, list):
            preview_data = data[:num_items]
        elif isinstance(data, dict):
            preview_data = dict(list(data.items())[:num_items])
        else:
            print(f&quot;Unexpected data type: {type(data)}. Cannot preview.&quot;)
            return

        print(f&quot;Preview of the first {num_items} items from {file_path}:&quot;)
        print(json. செறிவு(preview_data, indent=2))
        print(f&quot;\nTotal number of items: {len(data)}&quot;)

    except FileNotFoundError:
        print(f&quot;File not found: {file_path}&quot;)
    except json.JSONDecodeError:
        print(f&quot;Invalid JSON in file: {file_path}&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {str(e)}&quot;)

preview_json('evaluation/docs_evaluation_dataset.json')
</code></pre>

<pre class="codehilite"><code>Preview of the first 3 items from evaluation/docs_evaluation_dataset.json:
[
  {
    &quot;id&quot;: &quot;efc09699&quot;,
    &quot;question&quot;: &quot;How can you create multiple test cases for an evaluation in the Anthropic Evaluation tool?&quot;,
    &quot;correct_chunks&quot;: [
      &quot;https://docs.anthropic.com/en/docs/test-and-evaluate/eval-tool#creating-test-cases&quot;,
      &quot;https://docs.anthropic.com/en/docs/build-with-claude/develop-tests#building-evals-and-test-cases&quot;
    ],
    &quot;correct_answer&quot;: &quot;To create multiple test cases in the Anthropic Evaluation tool, click the 'Add Test Case' button, fill in values for each variable in your prompt, and repeat the process to create additional test case scenarios.&quot;
  },
  {
    &quot;id&quot;: &quot;1305ea00&quot;,
    &quot;question&quot;: &quot;What embeddings provider does Anthropic recommend for customized domain-specific models, and what capabilities does this provider offer?&quot;,
    &quot;correct_chunks&quot;: [
      &quot;https://docs.anthropic.com/en/docs/build-with-claude/embeddings#before-implementing-embeddings&quot;,
      &quot;https://docs.anthropic.com/en/docs/build-with-claude/embeddings#how-to-get-embeddings-with-anthropic&quot;
    ],
    &quot;correct_answer&quot;: &quot;Anthropic recommends Voyage AI for embedding models. Voyage AI offers customized models for specific industry domains like finance and healthcare, as well as bespoke fine-tuned models for individual customers. They have a wide variety of options and capabilities.&quot;
  },
  {
    &quot;id&quot;: &quot;1811c10d&quot;,
    &quot;question&quot;: &quot;What are some key success metrics to consider when evaluating Claude's performance on a classification task, and how do they relate to choosing the right model to reduce latency?&quot;,
    &quot;correct_chunks&quot;: [
      &quot;https://docs.anthropic.com/en/docs/about-claude/use-cases/classification#evaluation-metrics&quot;,
      &quot;https://docs.anthropic.com/en/docs/test-and-evaluate/strengthen-guardrails/reduce-latency#1-choose-the-right-model&quot;
    ],
    &quot;correct_answer&quot;: &quot;When evaluating Claude's performance on a classification task, some key success metrics to consider include accuracy, F1 score, consistency, structure, speed, bias and fairness. Choosing the right model that fits your specific requirements in terms of speed and output quality is a straightforward way to reduce latency and meet the acceptable response time for your use case.&quot;
  }
]

Total number of items: 100
</code></pre>

<h1 id="metric-definitions">Metric Definitions</h1>
<p>We'll evaluate our system based on 5 key metrics: Precision, Recall, F1 Score, Mean Reciprocal Rank (MRR), and End-to-End Accuracy.</p>
<h2 id="retrieval-metrics">Retrieval Metrics:</h2>
<h3 id="precision">Precision</h3>
<p>Precision represents the proportion of retrieved chunks that are actually relevant. It answers the question: "Of the chunks we retrieved, how many were correct?"</p>
<p>Key points:</p>
<ul>
<li>High precision indicates an efficient system with few false positives.</li>
<li>Low precision suggests many irrelevant chunks are being retrieved.</li>
<li>Our system retrieves a minimum of 3 chunks per query, which may affect precision scores.</li>
</ul>
<p>Formula:
$$
\text{Precision} = \frac{\text{True Positives}}{\text{Total Retrieved}} = \frac{|\text{Retrieved} \cap \text{Correct}|}{|\text{Retrieved}|}
$$</p>
<h3 id="recall">Recall</h3>
<p>Recall measures the completeness of our retrieval system. It answers the question: "Of all the correct chunks that exist, how many did we manage to retrieve?"</p>
<p>Key points:</p>
<ul>
<li>High recall indicates comprehensive coverage of necessary information.</li>
<li>Low recall suggests important chunks are being missed.</li>
<li>Recall is crucial for ensuring the LLM has access to all needed information.</li>
</ul>
<p>Formula:
$$
\text{Recall} = \frac{\text{True Positives}}{\text{Total Correct}} = \frac{|\text{Retrieved} \cap \text{Correct}|}{|\text{Correct}|}
$$</p>
<h3 id="f1-score">F1 Score</h3>
<p>The F1 score provides a balanced measure between precision and recall. It's particularly useful when you need a single metric to evaluate system performance, especially with uneven class distributions.</p>
<p>Key points:</p>
<ul>
<li>F1 score ranges from 0 to 1, with 1 representing perfect precision and recall.</li>
<li>It's the harmonic mean of precision and recall, tending towards the lower of the two values.</li>
<li>Useful in scenarios where both false positives and false negatives are important.</li>
</ul>
<p>Formula:
$$
\text{F1 Score} = 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}
$$</p>
<p>Interpreting F1 score:</p>
<ul>
<li>An F1 score of 1.0 indicates perfect precision and recall.</li>
<li>An F1 score of 0.0 indicates the worst performance.</li>
<li>Generally, the higher the F1 score, the better the overall performance.</li>
</ul>
<h3 id="balancing-precision-recall-and-f1-score">Balancing Precision, Recall, and F1 Score:</h3>
<ul>
<li>There's often a trade-off between precision and recall.</li>
<li>Our system's minimum chunk retrieval favors recall over precision.</li>
<li>The optimal balance depends on the specific use case.</li>
<li>In many RAG systems, high recall is often prioritized, as LLMs can filter out less relevant information during generation.</li>
</ul>
<h3 id="mean-reciprocal-rank-mrr-k">Mean Reciprocal Rank (MRR) @k</h3>
<p>MRR measures how well our system ranks relevant information. It helps us understand how quickly a user would find what they're looking for if they started from the top of our retrieved results.</p>
<p>Key points:</p>
<ul>
<li>MRR ranges from 0 to 1, where 1 is perfect (correct answer always first).</li>
<li>It only considers the rank of the first correct result for each query.</li>
<li>Higher MRR indicates better ranking of relevant information.</li>
</ul>
<p>Formula:
$$
\text{MRR} = \frac{1}{|Q|} \sum_{i=1}^{|Q|} \frac{1}{\text{rank}_i}
$$</p>
<p>Where:</p>
<ul>
<li>|Q| is the total number of queries</li>
<li>rank_i is the position of the first relevant item for the i-th query</li>
</ul>
<h2 id="end-to-end-metrics">End to End Metrics:</h2>
<h3 id="end-to-end-accuracy">End to End Accuracy</h3>
<p>We use an LLM-as-judge (Claude 3.5 Sonnet) to evaluate whether the generated answer is correct based on the question and ground truth answer.</p>
<p>Formula:
$$
\text{End to End Accuracy} = \frac{\text{Number of Correct Answers}}{\text{Total Number of Questions}}
$$</p>
<p>This metric evaluates the entire pipeline, from retrieval to answer generation.</p>
<h2 id="defining-our-metric-calculation-functions">Defining Our Metric Calculation Functions</h2>
<pre class="codehilite"><code class="language-python">def calculate_mrr(retrieved_links: List[str], correct_links: Set[str]) -&gt; float:
    for i, link in enumerate(retrieved_links, 1):
        if link in correct_links:
            return 1 / i
    return 0

def evaluate_retrieval(retrieval_function: Callable, evaluation_data: List[Dict[str, Any]], db: Any) -&gt; Tuple[float, float, float, float, List[float], List[float], List[float]]:
    precisions = []
    recalls = []
    mrrs = []

    for i, item in enumerate(tqdm(evaluation_data, desc=&quot;Evaluating Retrieval&quot;)):
        try:
            retrieved_chunks, _ = retrieval_function(item['question'], db)
            retrieved_links = [chunk['metadata'].get('chunk_link', chunk['metadata'].get('url', '')) for chunk in retrieved_chunks]
        except Exception as e:
            logging.error(f&quot;Error in retrieval function: {e}&quot;)
            continue

        correct_links = set(item['correct_chunks'])

        true_positives = len(set(retrieved_links) &amp; correct_links)
        precision = true_positives / len(retrieved_links) if retrieved_links else 0
        recall = true_positives / len(correct_links) if correct_links else 0
        mrr = calculate_mrr(retrieved_links, correct_links)

        precisions.append(precision)
        recalls.append(recall)
        mrrs.append(mrr)

        if (i + 1) % 10 == 0:
            print(f&quot;Processed {i + 1}/{len(evaluation_data)} items. Current Avg Precision: {sum(precisions) / len(precisions):.4f}, Avg Recall: {sum(recalls) / len(recalls):.4f}, Avg MRR: {sum(mrrs) / len(mrrs):.4f}&quot;)

    avg_precision = sum(precisions) / len(precisions) if precisions else 0
    avg_recall = sum(recalls) / len(recalls) if recalls else 0
    avg_mrr = sum(mrrs) / len(mrrs) if mrrs else 0
    f1 = 2 * (avg_precision * avg_recall) / (avg_precision + avg_recall) if (avg_precision + avg_recall) &gt; 0 else 0

    return avg_precision, avg_recall, avg_mrr, f1, precisions, recalls, mrrs

def evaluate_end_to_end(answer_query_function, db, eval_data):
    correct_answers = 0
    results = []
    total_questions = len(eval_data)

    for i, item in enumerate(tqdm(eval_data, desc=&quot;Evaluating End-to-End&quot;)):
        query = item['question']
        correct_answer = item['correct_answer']
        generated_answer = answer_query_function(query, db)

        prompt = f&quot;&quot;&quot;
        You are an AI assistant tasked with evaluating the correctness of answers to questions about Anthropic's documentation.

        Question: {query}

        Correct Answer: {correct_answer}

        Generated Answer: {generated_answer}

        Is the Generated Answer correct based on the Correct Answer? You should pay attention to the substance of the answer, and ignore minute details that may differ. 

        Small differences or changes in wording don't matter. If the generated answer and correct answer are saying essentially the same thing then that generated answer should be marked correct. 

        However, if there is any critical piece of information which is missing from the generated answer in comparison to the correct answer, then we should deem the generated answer to be incorrect.

        Finally, if there are any direct contradictions between the correect answer and generated answer, we should deem the generated answer to be incorrect.

        Respond in the following XML format:
        &lt;evaluation&gt;
        &lt;content&gt;
        &lt;explanation&gt;Your explanation here&lt;/explanation&gt;
        &lt;is_correct&gt;true/false&lt;/is_correct&gt;
        &lt;/content&gt;
        &lt;/evaluation&gt;
        &quot;&quot;&quot;

        try:
            response = client.messages.create(
                model=&quot;claude-3-5-sonnet-20241022&quot;,
                max_tokens=1500,
                messages=[
                    {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt},
                    {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;&lt;evaluation&gt;&quot;}
                ],
                temperature=0,
                stop_sequences=[&quot;&lt;/evaluation&gt;&quot;]
            )

            response_text = response.content[0].text
            print(response_text)
            evaluation = ET.fromstring(response_text)
            is_correct = evaluation.find('is_correct').text.lower() == 'true'

            if is_correct:
                correct_answers += 1
            results.append(is_correct)

            logging.info(f&quot;Question {i + 1}/{total_questions}: {query}&quot;)
            logging.info(f&quot;Correct: {is_correct}&quot;)
            logging.info(&quot;---&quot;)

        except ET.ParseError as e:
            logging.error(f&quot;XML parsing error: {e}&quot;)
            is_correct = 'true' in response_text.lower()
            results.append(is_correct)
        except Exception as e:
            logging.error(f&quot;Unexpected error: {e}&quot;)
            results.append(False)

        if (i + 1) % 10 == 0:
            current_accuracy = correct_answers / (i + 1)
            print(f&quot;Processed {i + 1}/{total_questions} questions. Current Accuracy: {current_accuracy:.4f}&quot;)
        # time.sleep(2)
    accuracy = correct_answers / total_questions
    return accuracy, results
</code></pre>

<h2 id="helper-function-to-plot-performance">Helper Function to Plot Performance</h2>
<pre class="codehilite"><code class="language-python">import os
import json
import matplotlib.pyplot as plt
import seaborn as sns

def plot_performance(results_folder='evaluation/json_results', include_methods=None, colors=None):
    # Set default colors
    default_colors = ['skyblue', 'lightgreen', 'salmon']
    if colors is None:
        colors = default_colors

    # Load JSON files
    results = []
    for filename in os.listdir(results_folder):
        if filename.endswith('.json'):
            file_path = os.path.join(results_folder, filename)
            with open(file_path, 'r') as f:
                try:
                    data = json.load(f)
                    if 'name' not in data:
                        print(f&quot;Warning: {filename} does not contain a 'name' field. Skipping.&quot;)
                        continue
                    if include_methods is None or data['name'] in include_methods:
                        results.append(data)
                except json.JSONDecodeError:
                    print(f&quot;Warning: {filename} is not a valid JSON file. Skipping.&quot;)

    if not results:
        print(&quot;No JSON files found with matching 'name' fields.&quot;)
        return

    # Validate data
    required_metrics = [&quot;average_precision&quot;, &quot;average_recall&quot;, &quot;average_f1&quot;, &quot;average_mrr&quot;, &quot;end_to_end_accuracy&quot;]
    for result in results.copy():
        if not all(metric in result for metric in required_metrics):
            print(f&quot;Warning: {result['name']} is missing some required metrics. Skipping.&quot;)
            results.remove(result)

    if not results:
        print(&quot;No valid results remaining after validation.&quot;)
        return

    # Sort results based on end-to-end accuracy
    results.sort(key=lambda x: x['end_to_end_accuracy'])

    # Prepare data for plotting
    methods = [result['name'] for result in results]
    metrics = required_metrics

    # Set up the plot
    plt.figure(figsize=(14, 6))
    sns.set_style(&quot;whitegrid&quot;)

    x = range(len(metrics))
    width = 0.8 / len(results)

    # Create color palette
    num_methods = len(results)
    color_palette = colors[:num_methods] + sns.color_palette(&quot;husl&quot;, num_methods - len(colors))

    # Plot bars for each method
    for i, (result, color) in enumerate(zip(results, color_palette)):
        values = [result[metric] for metric in metrics]
        offset = (i - len(results)/2 + 0.5) * width
        bars = plt.bar([xi + offset for xi in x], values, width, label=result['name'], color=color)

        # Add value labels on the bars
        for bar in bars:
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2., height,
                     f'{height:.2f}', ha='center', va='bottom', fontsize=8)

    # Customize the plot
    plt.xlabel('Metrics', fontsize=12)
    plt.ylabel('Values', fontsize=12)
    plt.title('RAG Performance Metrics (Sorted by End-to-End Accuracy)', fontsize=16)
    plt.xticks(x, metrics, rotation=45, ha='right')
    plt.legend(title='Methods', bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.ylim(0, 1)

    plt.tight_layout()
    plt.show()
</code></pre>

<h2 id="evaluating-our-base-case">Evaluating Our Base Case</h2>
<pre class="codehilite"><code class="language-python">import pandas as pd

avg_precision, avg_recall, avg_mrr, f1, precisions, recalls, mrrs = evaluate_retrieval(retrieve_base, eval_data, db)
e2e_accuracy, e2e_results = evaluate_end_to_end(answer_query_base, db, eval_data)

# Create a DataFrame
df = pd.DataFrame({
    'question': [item['question'] for item in eval_data],
    'retrieval_precision': precisions,
    'retrieval_recall': recalls,
    'retrieval_mrr': mrrs,
    'e2e_correct': e2e_results
})

# Save to CSV
df.to_csv('evaluation/csvs/evaluation_results_detailed.csv', index=False)
print(&quot;Detailed results saved to evaluation/csvs/evaluation_results_one.csv&quot;)

# Print the results
print(f&quot;Average Precision: {avg_precision:.4f}&quot;)
print(f&quot;Average Recall: {avg_recall:.4f}&quot;)
print(f&quot;Average MRR: {avg_mrr:.4f}&quot;)
print(f&quot;Average F1: {f1:.4f}&quot;)
print(f&quot;End-to-End Accuracy: {e2e_accuracy:.4f}&quot;)

# Save the results to a file
with open('evaluation/json_results/evaluation_results_one.json', 'w') as f:
    json.dump({
        &quot;name&quot;: &quot;Basic RAG&quot;,
        &quot;average_precision&quot;: avg_precision,
        &quot;average_recall&quot;: avg_recall,
        &quot;average_f1&quot;: f1,
        &quot;average_mrr&quot;: avg_mrr,
        &quot;end_to_end_accuracy&quot;: e2e_accuracy
    }, f, indent=2)

print(&quot;Evaluation complete. Results saved to evaluation_results_one.json, evaluation_results_one.csv&quot;)
</code></pre>

<pre class="codehilite"><code>Evaluating Retrieval:  13%|█▎        | 13/100 [00:00&lt;00:04, 17.92it/s]
Processed 10/100 items. Current Avg Precision: 0.5000, Avg Recall: 0.8000, Avg MRR: 0.8333
Evaluating Retrieval:  23%|██▎       | 23/100 [00:01&lt;00:04, 15.81it/s]
Processed 20/100 items. Current Avg Precision: 0.3833, Avg Recall: 0.6500, Avg MRR: 0.6333
Evaluating Retrieval:  33%|███▎      | 33/100 [00:01&lt;00:04, 16.36it/s]
Processed 30/100 items. Current Avg Precision: 0.4000, Avg Recall: 0.6556, Avg MRR: 0.6667
Evaluating Retrieval:  43%|████▎     | 43/100 [00:02&lt;00:03, 16.35it/s]
Processed 40/100 items. Current Avg Precision: 0.4500, Avg Recall: 0.6917, Avg MRR: 0.7250
Evaluating Retrieval:  53%|█████▎    | 53/100 [00:03&lt;00:02, 16.13it/s]
Processed 50/100 items. Current Avg Precision: 0.4333, Avg Recall: 0.6733, Avg MRR: 0.7200
Evaluating Retrieval:  63%|██████▎   | 63/100 [00:03&lt;00:02, 16.34it/s]
Processed 60/100 items. Current Avg Precision: 0.4278, Avg Recall: 0.6722, Avg MRR: 0.7333
Evaluating Retrieval:  73%|███████▎  | 73/100 [00:04&lt;00:01, 16.44it/s]
Processed 70/100 items. Current Avg Precision: 0.4167, Avg Recall: 0.6440, Avg MRR: 0.7048
Evaluating Retrieval:  83%|████████▎ | 83/100 [00:05&lt;00:01, 16.29it/s]
Processed 80/100 items. Current Avg Precision: 0.4396, Avg Recall: 0.6823, Avg MRR: 0.7354
Evaluating Retrieval:  93%|█████████▎| 93/100 [00:05&lt;00:00, 16.72it/s]
Processed 90/100 items. Current Avg Precision: 0.4352, Avg Recall: 0.6750, Avg MRR: 0.7333
Evaluating Retrieval: 100%|██████████| 100/100 [00:06&lt;00:00, 16.47it/s]

Evaluating End-to-End:   1%|          | 1/100 [00:05&lt;08:35,  5.21s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect. While it provides general guidance about test case creation, it misses the specific, critical information about HOW to actually create multiple test cases in the Anthropic Evaluation tool. The correct answer clearly states that you need to click the 'Add Test Case' button and fill in values for variables in your prompt. The generated answer instead talks about theoretical steps like organizing test cases in spreadsheets or JSON files, which isn't mentioned in the correct answer and may not be accurate. The generated answer seems to be providing general testing best practices rather than the specific mechanics of creating multiple test cases in the Anthropic Evaluation tool.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   2%|▏         | 2/100 [00:10&lt;08:21,  5.12s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct in substance compared to the Correct Answer. Both answers identify Voyage AI as Anthropic's recommended embeddings provider and both mention that Voyage AI offers customized/fine-tuned models for specific domains and individual customers. While the Generated Answer provides more specific details about Voyage AI's model offerings that aren't mentioned in the Correct Answer, this additional information doesn't contradict the Correct Answer - it merely elaborates on it. The core claims about Voyage AI's capabilities for domain-specific customization and bespoke fine-tuning are consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   3%|▎         | 3/100 [00:16&lt;08:45,  5.41s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it covers all the key points mentioned in the Correct Answer and even provides additional helpful details. Both answers mention the same key success metrics: accuracy, F1 score, consistency, structure, speed, and bias/fairness. Both answers also discuss how choosing the right model affects latency and performance. While the Generated Answer goes into more specific details about model choices (mentioning claude-3-haiku and Sonnet specifically), this additional detail doesn't contradict the Correct Answer - it simply elaborates on it. The core message about balancing speed and output quality is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   4%|▍         | 4/100 [00:20&lt;08:18,  5.19s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but misses a key element from the correct answer. While both answers correctly identify parallel evaluation/testing as one advantage, the second point differs significantly. The correct answer specifically mentions Claude for Sheets' excellence at office tasks like survey analysis and online data processing, while the generated answer instead talks about an integrated workflow and centralized environment. This represents a substantial difference in the functionality being described. Since one of the two key advantages is missing from the generated answer, it cannot be considered fully correct.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   5%|▌         | 5/100 [00:24&lt;07:44,  4.89s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core information - that missing the &quot;\n\nHuman:&quot; and &quot;\n\nAssistant:&quot; turns in the prompt will result in an API error. The Generated Answer actually provides slightly more context by explaining that these turns are expected to indicate the start of human input and assistant response, but this additional detail doesn't change the fundamental correctness of the answer. There are no contradictions between the two answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   6%|▌         | 6/100 [00:30&lt;08:33,  5.46s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer:

1. It correctly states that tool use requests are priced the same way as regular API requests
2. It accurately lists all the additional token sources that contribute to the total cost:
   - Tools parameter
   - Tool use content blocks
   - Tool result content blocks
   - Special system prompt
3. It explains that these additional tokens are added to the normal input/output tokens to calculate the total cost

The Generated Answer actually provides slightly more detail than the Correct Answer, but doesn't contradict it in any way. The core message that tool use requests follow the same pricing structure but include additional tokens that affect the total cost is preserved in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   7%|▋         | 7/100 [00:35&lt;07:37,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the essential information from the Correct Answer - specifically the release date (June 27th, 2024) and what features will be available (API usage, billing details, and rate limits). While the Correct Answer provides slightly more detail by mentioning the specific tabs (Usage, Cost, and Rate Limits), this is a minor detail that doesn't change the core meaning. Both answers convey the same fundamental information about what will be available and when.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   8%|▊         | 8/100 [00:40&lt;07:43,  5.03s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it misses a critical element from the Correct Answer. While both answers discuss latency implications of CoT, the Generated Answer fails to mention one of the key decision factors - whether the task requires in-depth thinking that a human would need to work through. The Generated Answer focuses heavily on performance and latency considerations, essentially repeating the same point twice, but doesn't address the fundamental question of whether the task's complexity actually warrants using CoT in the first place. This is a significant omission since it's one of the two key factors mentioned in the Correct Answer for determining when CoT is appropriate.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   9%|▉         | 9/100 [00:46&lt;07:51,  5.18s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that Claude can be used to summarize PDF documents, making it easier to understand long documents without reading everything. While the Generated Answer provides additional details about text analysis capabilities and mentions the Anthropic Cookbook, these are supplementary details that don't contradict the core message. The essential functionality - uploading PDFs and getting summaries to more easily digest long documents - is accurately captured in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  10%|█         | 10/100 [00:49&lt;06:57,  4.64s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers indicate that you can view the API rate limits in a Rate Limits tab within Anthropic's console interface. The only difference is minor wording variation (&quot;Developer Console&quot; vs &quot;Anthropic Console&quot;) and the Generated Answer's inclusion of the word &quot;new,&quot; but these don't change the core substance of the answer. Both answers convey the same essential information about where to find the rate limits.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 10/100 questions. Current Accuracy: 0.7000
Evaluating End-to-End:  11%|█         | 11/100 [00:56&lt;07:54,  5.33s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect when compared to the correct answer. While the generated answer provides several reasonable metrics for evaluating a ticket classification system, it misses the specific key metrics mentioned in the correct answer: the 95th percentile response time and average cost per classification. The generated answer discusses cost and speed in more general terms, but doesn't mention these specific metrics that were identified in the correct answer. While the additional metrics suggested in the generated answer (like robustness, explainability, adaptability, etc.) might be useful, they don't align with the specific metrics outlined in the correct answer. Since the generated answer is missing these critical pieces of information from the correct answer, it should be marked as incorrect.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  12%|█▏        | 12/100 [01:02&lt;08:05,  5.52s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately describes both methods of specifying system prompts:

1. For Text Completions API: Both answers indicate that the system prompt goes before the first &quot;\n\nHuman:&quot; turn in the prompt text.

2. For Messages API: Both answers specify that the system prompt is provided using the &quot;system&quot; parameter in the API request.

The Generated Answer actually provides helpful concrete code examples to illustrate these concepts, which goes beyond but doesn't contradict the Correct Answer. The substance and core information about how to specify system prompts in both APIs is consistent between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 9, column 2
Evaluating End-to-End:  13%|█▎        | 13/100 [01:10&lt;09:09,  6.32s/it]
&lt;content&gt;
&lt;explanation&gt;
The generated answer, while detailed and structured, misses a key element from the correct answer. The correct answer specifically mentions using tags like &lt;thinking&gt; and &lt;answer&gt; in combination with chain of thought reasoning where Claude explains its step-by-step thinking process. While the generated answer does discuss using XML tags and breaking down tasks into steps, it doesn't explicitly mention the core concept of using &lt;thinking&gt; tags to prompt Claude to show its reasoning process.

The generated answer focuses more on a general methodology of breaking down tasks and using XML tags for structure, rather than the specific combination of XML tags with chain of thought reasoning that the correct answer describes. The correct answer provides a more focused and specific approach about using tags to explicitly prompt Claude's reasoning process.

Additionally, the correct answer provides a specific example of how to prompt Claude (&quot;Before answering, explain your reasoning step-by-step in &lt;thinking&gt; tags&quot;), which is a crucial piece of information missing from the generated answer.
&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  14%|█▍        | 14/100 [01:16&lt;08:59,  6.27s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect for several reasons:

1. While it correctly identifies that accuracy, cost, and response time are measured, it fails to provide the specific values that were given in the correct answer (89.01% accuracy, 1.61 seconds for 95th percentile response time, $0.0004 for average cost per request).

2. The response time metric is described differently - the correct answer specifically mentions &quot;95th percentile response time&quot; while the generated answer refers to &quot;average latency&quot;

3. The cost metric is described differently - the correct answer specifies &quot;cost per request routing&quot; while the generated answer refers to &quot;total cost&quot;

4. The generated answer includes placeholder text ([RESULT_ACCURACY], [RESULT_COST], [RESULT_RESPONSE_TIME]) instead of actual values.

These differences and omissions make the generated answer incomplete and partially incorrect compared to the correct answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  15%|█▌        | 15/100 [01:22&lt;08:40,  6.12s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the key elements from the Correct Answer:

1. Having clear success criteria
2. Having ways to empirically test against those criteria
3. Having a first draft prompt to improve

The Generated Answer actually provides slightly more detail by mentioning specific documentation sections, but the core substance perfectly matches the Correct Answer. There are no contradictions or missing critical pieces of information. The minor differences in phrasing (like listing the items with numbers vs. combining them in a sentence) don't affect the correctness of the answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  16%|█▌        | 16/100 [01:28&lt;08:12,  5.87s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key distinction between how mid-response prompting works in both APIs:

1. For the Text Completions API, it mentions that you can pre-fill part of the response in the prompt
2. For the Messages API, it explains that you can continue a response by setting the last message to have the assistant role

The Generated Answer essentially communicates the same information as the Correct Answer, just with slightly more detailed wording. There are no contradictions or missing critical pieces of information between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  17%|█▋        | 17/100 [01:34&lt;08:27,  6.11s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the key point made in the Correct Answer - that Claude's response with a role-based system prompt produces a more detailed, structured, and actionable financial analysis compared to not having a specific role. In fact, the Generated Answer goes into even more specific detail about how the analysis differs, breaking down concrete examples of the improvements (like flagging CAC concerns and providing strategic recommendations). While it provides more granular details than the Correct Answer, it does not contradict anything in the Correct Answer and maintains the same core message about the role-based prompt leading to more insightful and structured analysis. The key comparison point about the quality difference between role-based and non-role-based responses is preserved in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  18%|█▊        | 18/100 [01:42&lt;08:56,  6.55s/it]
&lt;content&gt;
&lt;explanation&gt;
The Generated Answer is correct as it captures the key elements from the Correct Answer:

1. It mentions important quantitative metrics, including F1 score, accuracy, and other relevant metrics, which aligns with the Correct Answer's mention of &quot;F1 score, accuracy, precision, and recall.&quot;

2. It discusses how targets should be determined, mentioning industry benchmarks and prior experiments, which directly matches the Correct Answer's statement about basing targets on &quot;industry benchmarks, prior experiments, AI research, or expert knowledge.&quot;

While the Generated Answer provides more specific examples and additional metrics (like response time and toxicity), this additional detail doesn't contradict the Correct Answer - it merely expands upon it. The core substance of both answers is aligned: they both emphasize the importance of quantitative metrics and describe how targets should be determined based on industry standards and prior work.

There are no critical omissions or contradictions between the two answers.
&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 9, column 182
Evaluating End-to-End:  19%|█▉        | 19/100 [01:46&lt;07:49,  5.80s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key elements from the Correct Answer:

1. The core concept of combining XML tags with other prompt engineering techniques
2. Specifically mentions multishot prompting using &lt;examples&gt; tags
3. Mentions chain of thought using &lt;thinking&gt; and &lt;answer&gt; tags
4. Notes that this creates &quot;super-structured, high-performance prompts&quot;

While the wording is slightly different, the substance and meaning are identical. There are no missing critical pieces of information and no contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  20%|██        | 20/100 [01:53&lt;08:16,  6.20s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the essential elements from the Correct Answer and even provides additional helpful implementation details. Both answers emphasize:

1. The need to provide a detailed rubric
2. Having the LLM evaluate the output against the rubric
3. Getting a &quot;correct&quot; or &quot;incorrect&quot; result as the final output

The Generated Answer goes into more specific implementation details about functions and steps, but this additional information doesn't contradict the core concept presented in the Correct Answer. The substance of how to use an LLM for grading (providing it with both the rubric and content to grade, then getting a binary evaluation) is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 20/100 questions. Current Accuracy: 0.6000
Evaluating End-to-End:  21%|██        | 21/100 [01:58&lt;07:52,  5.99s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it contains all the essential steps and information present in the Correct Answer. Both answers outline the same key process:

1. Accessing/subscribing to the model on AWS Marketplace
2. Selecting the model and agreeing to terms
3. Obtaining the Product ARN for the region
4. Creating a JupyterLab space in SageMaker Studio
5. Using Voyage's notebook to deploy the model with the ARN

The Generated Answer actually provides slightly more detail in its step-by-step breakdown, but the core substance matches the Correct Answer completely. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  22%|██▏       | 22/100 [02:04&lt;07:43,  5.94s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect because it misses several key points from the correct answer and provides different guidance. Specifically:

1. The correct answer emphasizes using a SINGLE tool, while the generated answer talks about tools in plural without this key specification.

2. The correct answer mentions explicitly setting tool_choice to instruct the model to use the tool, which is completely missing from the generated answer.

3. The correct answer mentions that tool names and descriptions should be written from the model's perspective since it will pass the input to the tool - this important perspective consideration is missing from the generated answer.

Instead, the generated answer focuses more on the general process of tool usage and implementation details that weren't part of the core guidance in the correct answer. While some of the implementation details provided might be useful, it misses the specific key points that were identified as critical for getting JSON output using tools.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  23%|██▎       | 23/100 [02:12&lt;08:17,  6.46s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides more detailed information than the Correct Answer while maintaining all the key points. Both answers agree on the fundamental differences:

1. Both mention that Claude 3 Haiku has vision capabilities
2. Both indicate that Claude 3 Haiku is faster and more performant
3. Both note that Claude 3 Haiku has more recent/up-to-date training data

The Generated Answer expands on these points with additional details about context windows, pricing, and language capabilities, but these additions don't contradict the Correct Answer - they simply provide more specific information. The core message about Claude 3 Haiku being more capable, faster, and more up-to-date is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  24%|██▍       | 24/100 [02:16&lt;07:10,  5.67s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers emphasize the same key point - that using examples helps reduce misinterpretation of instructions and leads to more accurate outputs from Claude. While the Generated Answer adds some additional detail about enforcing uniform structure and style, this doesn't contradict the core message, and the fundamental benefit of reducing misinterpretation is clearly stated in both answers. The Generated Answer effectively captures the essential concept presented in the Correct Answer, just with slightly different wording and additional context.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  25%|██▌       | 25/100 [02:21&lt;06:45,  5.40s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer, while providing additional details about resource efficiency and other benefits, does not directly address the key advantage mentioned in the Correct Answer - which is the ability to adapt models to new domains by providing domain-specific context in prompts without retraining. While the Generated Answer may state valid benefits of prompt engineering, it misses this critical piece of information about domain adaptation through context provision that is central to the Correct Answer. The Generated Answer focuses more on operational benefits (resource efficiency, speed, etc.) rather than the core functional advantage of domain adaptation through contextual prompting that was specified in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  26%|██▌       | 26/100 [02:24&lt;06:03,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core information - that users can get started quickly by making a copy of Anthropic's provided Claude for Sheets template workbook. While the Generated Answer provides additional details about next steps after copying the template, the fundamental starting point matches the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes the key piece of information about making a copy of the template.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  27%|██▋       | 27/100 [02:30&lt;06:15,  5.15s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the essential meaning of the Correct Answer. Both answers explain that:

1. The &quot;index&quot; field identifies which specific content block the text delta applies to
2. The field is used to track/update content for specific blocks in the response
3. Both imply the relationship between the index and the streaming of text content

While they use slightly different wording and structure, the fundamental explanation of how the index field relates to text streaming and content blocks is consistent between both answers. The Generated Answer may be more technical in its explanation about &quot;cumulative results&quot; and &quot;Message content array,&quot; but it doesn't contradict or miss any critical information from the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  28%|██▊       | 28/100 [02:36&lt;06:32,  5.46s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides additional helpful details beyond the Correct Answer. Both answers agree on the key points:

1. Images must be base64-encoded
2. The supported formats are JPEG, PNG, GIF, and WebP
3. Images are included as part of the message content

The Generated Answer provides extra information about file size limits and maximum number of images per request, but this additional information doesn't contradict the Correct Answer - it simply provides more detail. The slight differences in how they describe the technical implementation (e.g., &quot;image content block&quot; vs &quot;content field with type set to image&quot;) are minor variations in wording that describe the same fundamental concept.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  29%|██▉       | 29/100 [02:42&lt;06:37,  5.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that TTFT is a specific component of overall latency, measuring specifically the time to generate the first token of a response. The Generated Answer actually provides additional relevant context about factors affecting TTFT and latency, but this extra information doesn't contradict the Correct Answer - it merely elaborates on it. The key relationship between TTFT and latency is accurately captured in both answers, with both emphasizing that TTFT is a component of overall latency that specifically measures the time to first token generation. The Generated Answer maintains the same essential meaning as the Correct Answer, just expressed with slightly different wording.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  30%|███       | 30/100 [02:49&lt;07:01,  6.03s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that providing examples of edge cases to Claude can improve its performance in routing support tickets. The Generated Answer actually goes into more detail by breaking down specific types of edge cases (implicit requests, emotional prioritization, intent vs. routing, and issue prioritization) and explaining how each type of example can help improve Claude's performance. While it provides more detail than the Correct Answer, it doesn't contradict it and maintains the same fundamental point about examples improving Claude's ability to handle edge cases in ticket routing. The substance and main message are aligned between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 30/100 questions. Current Accuracy: 0.6000
Evaluating End-to-End:  31%|███       | 31/100 [02:55&lt;07:00,  6.10s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures all the essential elements of the Correct Answer. Both answers describe:

1. That Claude determines when a tool is needed and generates a tool use request
2. That this results in a stop_reason of &quot;tool_use&quot;
3. That the user needs to extract the tool input from Claude's request
4. That the tool execution happens client-side
5. That the results need to be sent back to Claude

The Generated Answer actually provides slightly more detail in some areas, but doesn't contradict anything in the Correct Answer. The core workflow and relationship between the stop_reason=&quot;tool_use&quot; and the overall tool integration process is accurately represented in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  32%|███▏      | 32/100 [03:00&lt;06:29,  5.72s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the key elements from the Correct Answer:

1. It correctly identifies the error event as &quot;overloaded_error&quot;
2. It specifies that this occurs during periods of high usage
3. It correctly states that this corresponds to HTTP 529 error code in non-streaming contexts
4. It properly contextualizes this within streaming responses

The Generated Answer simply rephrases the same information in a slightly different way, but maintains all the critical substance and technical details. There are no contradictions or missing pieces of information between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  33%|███▎      | 33/100 [03:04&lt;05:51,  5.24s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It identifies both types of deltas that can be contained in a content_block_delta event: text_delta and input_json_delta. While the formatting and presentation are slightly different (using a numbered list instead of prose), the substance and key information are exactly the same as the Correct Answer. Both answers convey the same two specific delta types without any omissions or contradictions.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  34%|███▍      | 34/100 [03:09&lt;05:25,  4.94s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. According to the Correct Answer, Claude 3.5 Sonnet and tool use became generally available on different dates:

- Claude 3.5 Sonnet: June 20th, 2024
- Tool use: May 30th, 2024

The Generated Answer incorrectly states that both became available on the same date (June 20th, 2024). This is a critical factual error as it misses the key distinction that these were separate releases with different availability dates. The difference in timing between these releases is an important piece of information that is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  35%|███▌      | 35/100 [03:13&lt;05:08,  4.75s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct in substance. While it doesn't include the specific timing (May 2024 for Europe and June 2024 for Canada), it accurately captures the key information about the order of launches - that Anthropic launched Claude.ai and the Claude iOS app in Europe first, followed by Canada. The omission of specific months doesn't change the fundamental accuracy of the sequence of events described.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  36%|███▌      | 36/100 [03:18&lt;05:14,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the essential elements from the Correct Answer:

1. It correctly identifies that &quot;tool_use&quot; indicates Claude has decided to use a tool
2. It outlines the same key steps that need to be taken:
   - Extracting the tool name and input
   - Executing the tool code client-side
   - Sending back results in a tool_result content block

While the wording is slightly different, the substance and technical accuracy are completely aligned with the Correct Answer. There are no missing critical pieces of information and no contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  37%|███▋      | 37/100 [03:22&lt;04:52,  4.64s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same essential information as the Correct Answer. Both answers indicate that the anthropic library is used to interact with Claude/Anthropic's AI capabilities. While the Generated Answer provides slightly more detail by explaining what the anthropic library does, the core substance - that the anthropic library is the Python library used in the example - is consistent between both answers. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  38%|███▊      | 38/100 [03:27&lt;04:49,  4.67s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both main authentication methods described in the Correct Answer:

1. Direct provision of AWS credentials (access key, secret key, and optional session token)
2. Using default AWS credential providers (including both the ~/.aws/credentials file and environment variables)

The Generated Answer conveys the same essential information as the Correct Answer, just with slightly different wording. There are no missing critical pieces of information and no contradictions between the two answers. The substance and meaning are equivalent.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  39%|███▉      | 39/100 [03:33&lt;05:03,  4.98s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the same two key factors mentioned in the Correct Answer:

1. The risk/potential of prompt leaks (protecting sensitive information)
2. The impact on model performance due to added complexity

While the Generated Answer elaborates more on each factor with additional examples and details, the core substance and trade-off described is identical to the Correct Answer. Both answers emphasize the need to balance protecting against leaks with maintaining model performance. There are no contradictions between the two answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  40%|████      | 40/100 [03:39&lt;05:25,  5.42s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that:

1. Anthropic offers different Claude models with varying capabilities and performance characteristics
2. Selecting the right model that matches your specific needs helps optimize for speed and performance
3. The choice of model affects the balance of performance and output quality

While the Generated Answer provides additional details about model families and the model overview page, these don't contradict the Correct Answer but rather expand upon it. The fundamental point about choosing the appropriate model to reduce latency is preserved in both answers. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 40/100 questions. Current Accuracy: 0.6750
Evaluating End-to-End:  41%|████      | 41/100 [03:44&lt;05:18,  5.40s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the essential information from the Correct Answer and even provides more detailed implementation examples. Both answers highlight the key points that:

1. You use the client.messages.stream() method
2. You iterate over the stream.text_stream attribute in a for loop

The Generated Answer expands on this with a practical code example and additional context, but the core information matches perfectly with the Correct Answer. There are no contradictions or missing critical pieces between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  42%|████▏     | 42/100 [03:50&lt;05:15,  5.44s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both key points from the Correct Answer:

1. It explains that you can guide Claude's response by pre-filling part of it in the messages list (though it specifically mentions the &quot;assistant&quot; message, which is just a more detailed explanation of the same concept)

2. It correctly identifies that the &quot;max_tokens&quot; parameter is used to generate short responses by limiting the length of the output

The substance and main concepts are the same between both answers, even though the exact wording differs slightly. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  43%|████▎     | 43/100 [03:55&lt;04:56,  5.20s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core message: that when building an eval set, it's better to have a larger number of test cases with automated grading rather than fewer test cases with high-quality human grading. The Generated Answer expands on this with additional details about automated grading methods, but the fundamental point matches exactly with the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes all critical information from the Correct Answer. While the Generated Answer provides more detail, this additional context doesn't change or contradict the main point.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  44%|████▍     | 44/100 [03:59&lt;04:36,  4.94s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. According to the Correct Answer, the two required fields are &quot;index&quot; and &quot;delta&quot; (where &quot;delta&quot; contains the type and text). The Generated Answer instead lists &quot;type&quot; and &quot;text&quot; as the required fields, which is not accurate according to the Correct Answer. This is a substantive difference, not just a wording variation, as it misidentifies the top-level required fields in the event structure. The Generated Answer is missing the critical &quot;index&quot; field requirement and incorrectly elevates &quot;type&quot; and &quot;text&quot; (which are actually nested within the &quot;delta&quot; field) to be the main required fields.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  45%|████▌     | 45/100 [04:03&lt;04:23,  4.79s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it misses a critical piece of information from the Correct Answer. While it correctly mentions the Anthropic Cookbook as one interactive way to learn Claude's capabilities, it completely fails to mention the Developer Console and its prompt generator tool, which is the second key interactive learning method specified in the Correct Answer. Instead, it incorrectly references &quot;Claude for Sheets usage examples&quot; as the second method, which wasn't mentioned in the Correct Answer at all. The omission of the Developer Console and the inclusion of incorrect information makes this answer incomplete and partially inaccurate.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  46%|████▌     | 46/100 [04:08&lt;04:20,  4.82s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. The core concept from the Correct Answer - that breaking tasks into subtasks improves accuracy because each subtask gets Claude's full attention and reduces errors compared to handling everything at once - is fully captured in the Generated Answer's first point about accuracy. While the Generated Answer goes on to provide additional points about clarity and traceability, these are supplementary details that don't contradict the core concept. The essential reasoning about improved accuracy through focused attention on subtasks is present and aligned between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  47%|████▋     | 47/100 [04:13&lt;04:17,  4.85s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key distinction mentioned in the Correct Answer - that Messages streaming responses can contain multiple content blocks of varying types, making them more complex than Text Completions streaming. While the Generated Answer provides additional details about the specific implementation differences, its core message aligns with the Correct Answer's main point about the fundamental difference in complexity and structure between the two streaming formats. There are no contradictions between the answers, and the Generated Answer includes all critical information from the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  48%|████▊     | 48/100 [04:17&lt;04:00,  4.62s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is partially incorrect. While it correctly mentions claude.ai and the web Console as one way to experiment with Claude, it incorrectly lists the Quickstart guide/API call as the second method instead of just the web Console. The Correct Answer specifically states that the two ways are claude.ai and Anthropic's web Console, which are essentially referring to the same interface. The Generated Answer introduces a different method (API calls) that wasn't mentioned in the Correct Answer. This represents a substantive difference in the information provided, not just a difference in wording.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  49%|████▉     | 49/100 [04:23&lt;04:12,  4.96s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that chain prompts help reduce errors and inconsistencies by breaking complex tasks into smaller, more manageable subtasks that Claude can focus on individually. While the Generated Answer provides more detailed explanations and additional benefits (like traceability and debugging), it doesn't contradict the Correct Answer. The fundamental principle - that breaking tasks into smaller pieces helps reduce errors and maintain consistency - is preserved in both answers. The additional details in the Generated Answer simply elaborate on the basic concept without changing its essential meaning.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  50%|█████     | 50/100 [04:27&lt;03:47,  4.54s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers state that an overloaded_error event corresponds to HTTP status code 529 in a non-streaming context for the Anthropic API. While the Correct Answer uses slightly more formal language (&quot;would normally correspond to&quot;), the core information - the 529 status code - is identical in both answers. The difference in phrasing does not change the fundamental meaning or accuracy of the response.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 50/100 questions. Current Accuracy: 0.6800
Evaluating End-to-End:  51%|█████     | 51/100 [04:31&lt;03:36,  4.42s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the exact same two ways to specify the embedding format as mentioned in the Correct Answer:

1. Both answers indicate that leaving the format unspecified will return embeddings as lists of floating-point numbers
2. Both answers state that setting the format to &quot;base64&quot; will return the embeddings as Base64 encodings

The Generated Answer simply presents the information in a more structured bullet-point format, but conveys the same essential information as the Correct Answer. There are no missing critical details or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  52%|█████▏    | 52/100 [04:37&lt;03:57,  4.96s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same essential information as the Correct Answer. Both answers explain that:

1. Tool use content blocks are sent as partial JSON strings in content_block_delta events
2. The client needs to accumulate these partial JSON strings
3. The complete JSON can be parsed once a content_block_stop event is received
4. Parsing can be done using Pydantic or SDK helpers

The Generated Answer actually provides additional helpful detail by showing an example of the delta structure, but this doesn't contradict anything in the Correct Answer. The core concepts and process are described accurately and consistently between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  53%|█████▎    | 53/100 [04:41&lt;03:42,  4.73s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately identifies and describes both tutorials that Anthropic offers:

1. The GitHub tutorial which covers prompt engineering concepts with examples
2. The Google Sheets tutorial which is described as a lighter-weight version

The Generated Answer captures the key distinctions between the two tutorials and their delivery methods. While the exact wording differs slightly from the Correct Answer, the substance and meaning are essentially identical. The Generated Answer doesn't miss any critical information or make any contradictory claims compared to the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  54%|█████▍    | 54/100 [04:50&lt;04:35,  5.98s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides more comprehensive detail than the Correct Answer. It covers all the key points mentioned in the Correct Answer:

1. The 200K token context window
2. Tool use capabilities for integration with specialized applications
3. Multimodal input capabilities
4. Enterprise-grade security and data handling for sensitive information

The Generated Answer then goes beyond these points to provide additional relevant details about enterprise capabilities, such as HIPAA compliance, SOC II certification, reliability features, and global language support. While it contains more information than the Correct Answer, it doesn't contradict any points and includes all the critical elements specified in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  55%|█████▌    | 55/100 [04:53&lt;03:53,  5.19s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it omits a key region where Claude.ai API and iOS app are available - the United States. While the Generated Answer correctly mentions Canada and Europe, leaving out the United States represents a significant omission of information. The availability in all three regions (United States, Canada, and Europe) is a critical part of the complete and accurate answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  56%|█████▌    | 56/100 [04:59&lt;03:56,  5.37s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer and even provides additional helpful detail while maintaining the same core information:

1. It correctly identifies the two main approaches (push-based with webhooks and pull-based)
2. It accurately describes that push-based is more scalable but has security implications due to requiring a public endpoint
3. It correctly states that pull-based is easier to implement but has the drawback of making unnecessary calls to the support ticket system

The Generated Answer expands on these points with more detail, but does not contradict or omit any critical information from the Correct Answer. The substance and main distinctions between the two approaches are preserved.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  57%|█████▋    | 57/100 [05:03&lt;03:29,  4.86s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is completely correct. It contains all the key information from the Correct Answer: the release date (May 10th, 2024), what was released (a prompt generator tool), and where it's available (through the Developer Console). The wording is slightly different but conveys exactly the same information and meaning. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  58%|█████▊    | 58/100 [05:09&lt;03:36,  5.16s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers identify the Claude 3 Sonnet model as providing the best balance of intelligence and speed for high-throughput tasks like sales forecasting and targeted marketing. While the Generated Answer provides additional details and comparisons with other models, its core conclusion matches exactly with the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes all critical information present in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  59%|█████▉    | 59/100 [05:13&lt;03:25,  5.01s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information:

1. They both state that you can use either dot product or cosine similarity to calculate the similarity between Voyage embedding vectors
2. They both explain that these methods are equivalent because Voyage embeddings are normalized to length 1
3. The Generated Answer actually provides slightly more explanation about why this equivalence exists, but this additional detail doesn't change the core correctness

While the Generated Answer presents the information in a slightly different order and with different phrasing, the fundamental technical content and meaning is identical to the Correct Answer. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  60%|██████    | 60/100 [05:19&lt;03:31,  5.28s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer and even expands on them in a complementary way. Both answers emphasize that examples help:

1. Reduce misinterpretation of instructions
2. Enforce consistent structure and style
3. Guide Claude toward desired output/performance

The Generated Answer provides additional details and examples, but these don't contradict the core message of the Correct Answer - they simply elaborate on it. The substance of both answers is fundamentally the same, even though they're worded differently. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 60/100 questions. Current Accuracy: 0.6833
Evaluating End-to-End:  61%|██████    | 61/100 [05:25&lt;03:29,  5.38s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately identifies and describes the two types of content block deltas:

1. It correctly explains that input JSON deltas contain partial JSON strings for tool use inputs
2. It correctly identifies text deltas as containing text content updates

While the wording is slightly different from the Correct Answer, the substance and key information is the same. The Generated Answer effectively communicates that these deltas represent partial/incremental updates to their respective content types (text and JSON input). There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  62%|██████▏   | 62/100 [05:30&lt;03:20,  5.27s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it focuses on different capabilities than those mentioned in the Correct Answer. The Correct Answer specifically highlights question answering and text analysis as key capabilities that enable interactive systems and personalization. In contrast, the Generated Answer discusses text/code generation and tool use capabilities. While these are valid capabilities of Claude, they are not the specific ones identified in the Correct Answer as enabling interactive systems and personalized experiences. Additionally, the Correct Answer emphasizes understanding sentiment and preferences as part of personalization, which is not mentioned in the Generated Answer. The answers are discussing different aspects of Claude's capabilities without substantial overlap in their core points.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  63%|██████▎   | 63/100 [05:35&lt;03:15,  5.28s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key elements from the Correct Answer and presents them in essentially the same order:

1. Both answers mention the message_start event coming first
2. Both describe the content blocks structure with start, delta, and stop events
3. Both mention message_delta events
4. Both include the final message_stop event
5. Both note that ping events may be dispersed throughout

The Generated Answer actually provides slightly more detail by explicitly mentioning that the message_start contains a Message object with empty content, but this additional detail doesn't contradict the Correct Answer. The core sequence and components are identical between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  64%|██████▍   | 64/100 [05:39&lt;02:56,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that the Anthropic API allows up to 20 images per request while the claude.ai interface has a 5 image limit. While the Correct Answer provides slightly more context by mentioning &quot;Messages API&quot; and &quot;per turn,&quot; the core numerical limits are identical and accurately stated in the Generated Answer. The substance and critical information about the image limits are preserved, even if expressed more concisely.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  65%|██████▌   | 65/100 [05:45&lt;03:03,  5.24s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key substance of the Correct Answer, which is that when Claude's response contains an incomplete tool use block due to hitting the max_tokens limit, you should retry with a higher max_tokens value. The Generated Answer conveys the same essential instruction and solution as the Correct Answer, just with slightly different wording. There are no missing critical pieces of information or contradictions between the two answers. Both answers communicate the same core concept and recommended action.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  66%|██████▌   | 66/100 [05:50&lt;02:48,  4.95s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While both answers agree on the first step (developing test cases), they differ on the second step. The Correct Answer states that the second step is to &quot;take a look at Anthropic's guide to developing test cases&quot;, while the Generated Answer states it is to &quot;build a strong input prompt&quot;. These are substantively different steps. The Generated Answer misses the critical guidance about consulting Anthropic's documentation on test case development, which is specified in the Correct Answer. This represents a meaningful difference in the substance of what needs to be done before running a classification evaluation.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  67%|██████▋   | 67/100 [05:54&lt;02:38,  4.82s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but includes additional information that goes beyond what is specified in the correct answer and may not be accurate according to Anthropic's documentation. While it correctly mentions that you can pre-fill Claude's response using the &quot;Assistant&quot; role in messages, it adds several other claims about system prompts, simulating conversations, and max_tokens that aren't mentioned in the correct answer and may not be accurate implementations of the content parameter specifically. The core functionality - using the content parameter with assistant role to pre-fill responses - is present in the generated answer, but it's mixed with other unverified claims. Since we want to be strict about accuracy when dealing with documentation, and the answer includes potential misinformation alongside the correct information, it should be marked as incorrect.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  68%|██████▊   | 68/100 [06:00&lt;02:40,  5.03s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both key advantages mentioned in the Correct Answer:

1. It correctly states that prompt engineering preserves general knowledge while fine-tuning risks catastrophic forgetting
2. It accurately notes that prompt engineering is more effective at helping models understand and utilize external content/retrieved documents

The Generated Answer essentially restates the same two main points from the Correct Answer, just with slightly different wording. There are no missing critical pieces of information and no contradictions between the two answers. The substance and meaning are identical.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  69%|██████▉   | 69/100 [06:05&lt;02:34,  4.99s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While it describes some technical aspects of using the API, it misses one of the key initial setup steps specified in the Correct Answer - installing and configuring the AWS CLI. The Generated Answer jumps straight into authentication and client creation details, but skips over the fundamental prerequisite of having the AWS CLI installed and configured. Additionally, the Correct Answer mentions the need to install an SDK for accessing Bedrock, which is not explicitly mentioned in the Generated Answer. These are important initial setup steps that are materially different from the authentication and client creation steps described in the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 3, column 601
Evaluating End-to-End:  70%|███████   | 70/100 [06:09&lt;02:27,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It provides the exact same command structure and functionality as the Correct Answer, including:

1. The correct AWS CLI command `aws bedrock list-foundation-models`
2. The correct use of the `--region` parameter
3. The correct use of `--by-provider anthropic`
4. The correct query parameter to get model IDs
5. A specific example using `us-west-2` region

The Generated Answer conveys the same essential information and instructions as the Correct Answer, just with slightly different wording in the explanatory text. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 70/100 questions. Current Accuracy: 0.6429
Evaluating End-to-End:  71%|███████   | 71/100 [06:14&lt;02:19,  4.80s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that the `input_type` argument can be passed to specify whether the input text is a &quot;query&quot; or &quot;document&quot;. The Generated Answer actually provides additional detail about how the input_type affects processing, but this extra information doesn't contradict the Correct Answer. The essential point about the existence and purpose of the `input_type` parameter is accurately conveyed in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  72%|███████▏  | 72/100 [06:19&lt;02:15,  4.86s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is missing a critical piece of information that is present in the Correct Answer. While it correctly describes the basic difference between tool_use deltas (partial JSON strings for input field) and text deltas (simple text updates), it fails to mention that tool_use deltas may have delays between streaming events as the model emits one complete key-value pair at a time. This timing/delay characteristic is an important distinction mentioned in the Correct Answer that is completely absent from the Generated Answer. Since this represents a meaningful omission of a key technical detail about how the streaming works, the Generated Answer cannot be considered fully correct.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  73%|███████▎  | 73/100 [06:23&lt;02:07,  4.72s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It provides the exact same file size limits as the Correct Answer - 5MB for API uploads and 10MB for claude.ai uploads. The Generated Answer simply presents this information in a slightly different format (bullet points) and adds a minor detail about error messages, but the core information about the file size limits matches perfectly with the Correct Answer. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  74%|███████▍  | 74/100 [06:28&lt;02:05,  4.81s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers emphasize the key point of choosing a model that appropriately balances requirements for the specific use case. The Generated Answer actually provides more detail by mentioning Claude 3 Haiku as a specific example, but the core message about selecting a model based on the balance of speed/latency and output quality is present in both answers. There are no contradictions between the two answers, and the Generated Answer captures the essential consideration mentioned in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  75%|███████▌  | 75/100 [06:33&lt;01:58,  4.75s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the key points from the Correct Answer:

1. It correctly identifies voyage-code-2 as the recommended embedding model
2. It correctly states that according to Voyage AI, the model offers 17% better performance compared to alternatives

The only minor difference is that the Generated Answer doesn't mention that the model achieves state-of-the-art results on general-purpose corpora. However, this is a supplementary detail rather than a critical piece of information about the core recommendation and performance comparison. The essential substance about the model recommendation and its 17% performance improvement is accurately conveyed.

Since the Generated Answer maintains the core accuracy of the information without any contradictions, just omitting a non-critical detail, it should be considered correct.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  76%|███████▌  | 76/100 [06:37&lt;01:48,  4.52s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is essentially correct. Both answers highlight that the Anthropic Cookbook provides interactive Jupyter notebooks that demonstrate API functionality, specifically mentioning PDF uploads and embeddings. While the Generated Answer splits this into two points and adds some additional context about hands-on learning, the core information matches the Correct Answer. There are no contradictions or missing critical pieces of information between the two answers - they're conveying the same fundamental message about how the Cookbook helps developers learn through interactive notebooks and demonstrations.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  77%|███████▋  | 77/100 [06:43&lt;01:56,  5.08s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the core concept presented in the Correct Answer - that a larger context window allows the model to incorporate more retrieved information during RAG, which improves the quality of the generated output. Both answers emphasize that larger context windows allow for better utilization of retrieved information, leading to improved performance. While the Generated Answer provides additional details about latency considerations and trade-offs, these additions don't contradict the Correct Answer - they simply provide more context and depth. The fundamental relationship between context window size and RAG effectiveness is consistently presented in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  78%|███████▊  | 78/100 [06:50&lt;02:00,  5.49s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures all the key points from the Correct Answer and even expands on them in a helpful way. Both answers emphasize:

1. The tool's ability to identify edge cases where prompts might not perform well
2. The capability to rate individual results to assess prompt performance
3. The importance of ensuring consistent performance across different inputs
4. The ability to review results and spot patterns for making improvements
5. The ultimate goal of creating more robust and reliable AI applications

The Generated Answer adds some additional context about the beta status and feedback process, but this doesn't contradict the Correct Answer - it just provides extra information. The core substance and main points about how the Evaluation tool helps improve prompts are consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  79%|███████▉  | 79/100 [06:54&lt;01:46,  5.05s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers state that Claude 3 Haiku has the fastest comparative latency. The Generated Answer simply adds a bit more context by specifying &quot;among the Claude models&quot; but the core information - that Claude 3 Haiku is the fastest - is identical. There are no contradictions between the answers, and no critical information is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  80%|████████  | 80/100 [07:01&lt;01:51,  5.58s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It conveys the same core concept as the Correct Answer - that to have a multi-turn conversation using the Anthropic Messages API, you need to send the full conversation history with each request because the API is stateless. The Generated Answer actually provides more detail and a concrete code example, but the fundamental principle matches the Correct Answer. Both answers emphasize the importance of maintaining and sending the complete conversation history for each API call. There are no contradictions between the answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 80/100 questions. Current Accuracy: 0.6750
Evaluating End-to-End:  81%|████████  | 81/100 [07:08&lt;01:56,  6.14s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the core message of the Correct Answer. Both answers emphasize that using XML tags to provide a specific role context (like General Counsel) helps Claude catch critical legal issues and risks in contract analysis that might otherwise be missed. While the Generated Answer provides more detail and additional benefits (like improved focus and parseability), it doesn't contradict the Correct Answer and includes the key point about helping to identify critical legal issues that could save the company from significant risks. The essence of both answers is the same - role prompting with XML tags improves Claude's ability to analyze legal contracts by providing important context that leads to better identification of crucial legal issues.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  82%|████████▏ | 82/100 [07:12&lt;01:39,  5.55s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is essentially correct. Both answers convey the same core distinction between how the two models handle missing information in tool calls: Claude 3 Opus is more likely to ask for clarification when information is missing, while Claude 3 Sonnet is more likely to try to infer or fill in missing information on its own. While the Generated Answer uses slightly different wording and adds some additional context about the models' general capabilities, the fundamental comparison regarding how they handle missing information matches the Correct Answer. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  83%|████████▎ | 83/100 [07:20&lt;01:47,  6.30s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it covers all the key points mentioned in the Correct Answer and even provides additional helpful detail. Both answers emphasize:

1. Implementing retry logic for error handling
2. Conducting thorough staging/testing
3. Load testing
4. Error handling and logging setup
5. Gradual rollout process
6. Documentation and training
7. Monitoring and alerting

The Generated Answer expands on these points with more specific implementation details, but the core recommendations align perfectly with the Correct Answer. There are no contradictions between the two answers, and no critical pieces of information from the Correct Answer are missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  84%|████████▍ | 84/100 [07:26&lt;01:40,  6.26s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It covers all three key evaluation metrics mentioned in the Correct Answer:

1. Accuracy (&quot;Accuracy: The percentage of correct predictions...&quot;)
2. Cost (&quot;Average Cost per Classification...&quot;)
3. Speed (&quot;95th Percentile Response Time...&quot;)

While the Generated Answer provides additional details and context beyond what's in the Correct Answer, it fully encompasses the core evaluation criteria specified in the Correct Answer. The extra information doesn't contradict the Correct Answer, it merely elaborates on it. Since all three essential components (accuracy, cost, and speed) are present and there are no contradictions, the Generated Answer should be considered correct.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  85%|████████▌ | 85/100 [07:31&lt;01:24,  5.63s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers identify the same two recommended methods for learning prompt engineering with Claude:

1. The GitHub prompting tutorial
2. The Google Sheets prompting tutorial

The Generated Answer provides slightly more detail by mentioning that the GitHub tutorial is &quot;example-filled&quot; and that the Google Sheets version is a &quot;lighter weight version,&quot; but these are just additional descriptive details that don't change the core substance. The fundamental information about the two recommended learning methods matches between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  86%|████████▌ | 86/100 [07:37&lt;01:23,  5.94s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the key substantive differences outlined in the Correct Answer. Both answers emphasize that:

1. Pretrained LLMs are initially trained on unlabeled text data
2. These base models are not inherently good at following instructions/answering questions
3. Claude has undergone additional training/fine-tuning (including RLHF) to make it more capable at various tasks

While the Generated Answer includes additional details about interpretability and adaptability that aren't mentioned in the Correct Answer, these additions don't contradict the core message. The Generated Answer maintains the essential contrast between basic pretrained models and Claude's enhanced capabilities through additional training.

The substance and main points align between both answers, even though they are worded differently.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  87%|████████▋ | 87/100 [07:45&lt;01:23,  6.40s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides a more detailed expansion of the key points mentioned in the Correct Answer. It covers all the main advantages mentioned in the Correct Answer:

1. Cost and resource efficiency (points 1 and 2)
2. Speed and time efficiency (point 4)
3. Less data requirements (point 5)
4. Flexibility and rapid iteration (point 6)
5. Preservation of general knowledge (point 9)
6. Transparency (point 10)

The Generated Answer not only includes all the core concepts from the Correct Answer but also provides additional relevant details and examples. There are no contradictions between the two answers, and the Generated Answer doesn't miss any critical information from the Correct Answer. While the Generated Answer is more verbose and detailed, the substance and main points align perfectly with the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  88%|████████▊ | 88/100 [07:49&lt;01:08,  5.75s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that you need to run the command `gcloud auth application-default login` to authenticate with GCP before accessing Claude models on Vertex AI. The Generated Answer adds a bit more context about why this authentication is needed (to access resources), but this additional detail doesn't change or contradict the core instruction. The substance and critical information is identical between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  89%|████████▉ | 89/100 [07:54&lt;00:59,  5.43s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the core information about the Prompt Generator tool being introduced on May 10th, 2024, and its main purpose of helping users create tailored prompts for specific tasks. While the Correct Answer provides additional context about the Claude iOS app and Claude Team plan, these are supplementary details rather than critical pieces of information about the Prompt Generator capabilities themselves. The Generated Answer accurately conveys the essential functionality and purpose of the new tool, even if it's more concise. There are no contradictions between the two answers, and the key functionality of helping users create customized prompts is preserved in both versions.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  90%|█████████ | 90/100 [07:57&lt;00:49,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It conveys exactly the same information as the Correct Answer - that both Claude 3.5 Sonnet and the Artifacts feature became available on June 20th, 2024. While the wording is slightly different (omitting &quot;both&quot; and having a slightly different sentence structure), the core information and meaning are identical. There are no missing critical details or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 90/100 questions. Current Accuracy: 0.7000
Evaluating End-to-End:  91%|█████████ | 91/100 [08:02&lt;00:42,  4.71s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that to limit Claude's response to a single token, you should use the &quot;max_tokens&quot; parameter set to 1 in the request. The Generated Answer uses slightly different wording but communicates the same essential concept. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  92%|█████████▏| 92/100 [08:05&lt;00:35,  4.48s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that temperature controls randomness in the model's output generation. The Generated Answer simply provides more detail and elaboration about what higher and lower temperatures do specifically, but the fundamental meaning matches the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes all critical information from the Correct Answer while expanding on it.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  93%|█████████▎| 93/100 [08:10&lt;00:31,  4.54s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While it correctly identifies one way to specify API parameters (adding them as additional arguments after the prompt and model), it misses the second key method mentioned in the Correct Answer - the ability to pass in an API key for a specific cell. Instead, it incorrectly states that CLAUDEMESSAGES is the second method. The CLAUDEMESSAGES function is not mentioned in the Correct Answer at all, making this a significant deviation from the correct information. Since one of the two main methods is completely different from what's specified in the Correct Answer, this constitutes a critical error.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  94%|█████████▍| 94/100 [08:14&lt;00:26,  4.35s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the key points from the Correct Answer:

1. Prefilling with { causes Claude to skip the preamble
2. Results in direct JSON object output
3. Makes the response more concise
4. Makes it easier for programs to parse

While the wording is slightly different, the substance and meaning are essentially identical. The Generated Answer effectively communicates the same information about how prefilling with a curly brace affects Claude's output behavior. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  95%|█████████▌| 95/100 [08:19&lt;00:22,  4.58s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but contains extra information that is not verified by the correct answer. The first two points about the multimodal cookbook and API reference documentation match the correct answer's substance. However, the third point about the developer community is not mentioned in the correct answer and appears to be additional unverified information. Since this addition doesn't contradict the correct information but rather adds to it, and the core resources (cookbook and API reference) are accurately captured, the generated answer can be considered substantially correct in terms of the key information provided.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  96%|█████████▌| 96/100 [08:22&lt;00:13,  4.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same essential information as the Correct Answer. Both answers indicate that:

1. You can specify the API key as a parameter when creating a new Anthropic client
2. If not provided explicitly, the SDK will default to using the ANTHROPIC_API_KEY environment variable

The Generated Answer actually provides more detail by showing code examples in both Python and TypeScript, but the core information matches the Correct Answer. There are no contradictions between the two answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  97%|█████████▋| 97/100 [08:26&lt;00:13,  4.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the same two key benefits mentioned in the Correct Answer:

1. Both answers mention identifying edge cases where prompts might fail/falter
2. Both answers emphasize ensuring consistent performance across test inputs/cases

The Generated Answer breaks these points out more explicitly with numbering, but the core substance is identical to the Correct Answer. The slight differences in wording (e.g., &quot;rate individual results&quot; vs &quot;test case inputs&quot;) don't change the fundamental meaning. Both answers emphasize the tool's ability to help identify problems and ensure reliability across different scenarios.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  98%|█████████▊| 98/100 [08:30&lt;00:10,  5.48s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key points from the Correct Answer:

1. It acknowledges that the pretrained model is not inherently good at answering questions or following instructions (matching the Correct Answer)

2. It explains that the final version of Claude went through fine-tuning and RLHF to become more helpful and capable (matching the Correct Answer)

While the Generated Answer provides additional details about biases and capabilities, these don't contradict the Correct Answer - they merely expand upon it. The core message about the transformation from pretrained model to final API version through fine-tuning and RLHF is consistent between both answers.

There are no critical pieces of information from the Correct Answer that are missing from the Generated Answer, nor are there any contradictions between the two.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  99%|█████████▉| 99/100 [08:33&lt;00:04,  4.67s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is exactly identical to the Correct Answer, stating that Anthropic's IPv6 address range is 2607:6bc0::/48. There are no differences in wording or substance, and all critical information is present.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End: 100%|██████████| 100/100 [08:37&lt;00:00,  5.18s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It identifies the same two methods for specifying the API key as mentioned in the Correct Answer:

1. Using the ANTHROPIC_API_KEY environment variable
2. Passing the API key directly when initializing the client

While the Generated Answer is more concise, it contains the same essential information as the Correct Answer. The additional details in the Correct Answer (like mentioning that the environment variable is used &quot;by default&quot;) are supplementary and don't change the core correctness of the Generated Answer. There are no contradictions between the two answers, and no critical information is missing.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 100/100 questions. Current Accuracy: 0.7100
Detailed results saved to evaluation/csvs/evaluation_results_one.csv
Average Precision: 0.4283
Average Recall: 0.6592
Average MRR: 0.7367
Average F1: 0.5193
End-to-End Accuracy: 0.7100
Evaluation complete. Results saved to evaluation_results_one.json, evaluation_results_one.csv
</code></pre>

<pre class="codehilite"><code class="language-python">#let's visualize our performance
plot_performance('evaluation/json_results', ['Basic RAG'], colors=['skyblue'])
</code></pre>

<p><img alt="png" src="guide_files/guide_18_0.png" /></p>
<h1 id="level-2-document-summarization-for-enhanced-retrieval">Level 2: Document Summarization for Enhanced Retrieval</h1>
<p>In this section, we'll implement an improved approach to our retrieval system by incorporating document summaries. Instead of embedding chunks directly from the documents, we'll create a concise summary for each chunk and use this summary along with the original content in our embedding process.</p>
<p>This approach aims to capture the essence of each document chunk more effectively, potentially leading to improved retrieval performance.</p>
<p>Key steps in this process:</p>
<ol>
<li>We load the original document chunks.</li>
<li>For each chunk, we generate a 2-3 sentence summary using Claude.</li>
<li>We store both the original content and the summary for each chunk in a new json file: <code>data/anthropic_summary_indexed_docs.json</code></li>
</ol>
<p>This summary-enhanced approach is designed to provide more context during the embedding and retrieval phases, potentially improving the system's ability to understand and match the most relevant documents to user queries.</p>
<h2 id="generating-the-summaries-and-storing-them">Generating the Summaries and Storing Them</h2>
<pre class="codehilite"><code class="language-python">import json
from anthropic import Anthropic
from tqdm import tqdm

def generate_summaries(input_file, output_file):

    # Load the original documents
    with open(input_file, 'r') as f:
        docs = json.load(f)

    # Prepare the context about the overall knowledge base
    knowledge_base_context = &quot;This is documentation for Anthropic's, a frontier AI lab building Claude, an LLM that excels at a variety of general purpose tasks. These docs contain model details and documentation on Anthropic's APIs.&quot;

    summarized_docs = []

    for doc in tqdm(docs, desc=&quot;Generating summaries&quot;):
        prompt = f&quot;&quot;&quot;
        You are tasked with creating a short summary of the following content from Anthropic's documentation. 

        Context about the knowledge base:
        {knowledge_base_context}

        Content to summarize:
        Heading: {doc['chunk_heading']}
        {doc['text']}

        Please provide a brief summary of the above content in 2-3 sentences. The summary should capture the key points and be concise. We will be using it as a key part of our search pipeline when answering user queries about this content. 

        Avoid using any preamble whatsoever in your response. Statements such as 'here is the summary' or 'the summary is as follows' are prohibited. You should get straight into the summary itself and be concise. Every word matters.
        &quot;&quot;&quot;

        response = client.messages.create(
            model=&quot;claude-3-haiku-20240307&quot;,
            max_tokens=150,
            messages=[
                {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}
            ],
            temperature=0
        )

        summary = response.content[0].text.strip()

        summarized_doc = {
            &quot;chunk_link&quot;: doc[&quot;chunk_link&quot;],
            &quot;chunk_heading&quot;: doc[&quot;chunk_heading&quot;],
            &quot;text&quot;: doc[&quot;text&quot;],
            &quot;summary&quot;: summary
        }
        summarized_docs.append(summarized_doc)

    # Save the summarized documents to a new JSON file
    with open(output_file, 'w') as f:
        json.dump(summarized_docs, f, indent=2)

    print(f&quot;Summaries generated and saved to {output_file}&quot;)

# generate_summaries('data/anthropic_docs.json', 'data/anthropic_summary_indexed_docs.json')
</code></pre>

<h1 id="summary-indexed-vector-database-creation">Summary-Indexed Vector Database Creation</h1>
<p>Here, we're creating a new vector database that incorporates our summary-enhanced document chunks. This approach combines the original text, the chunk heading, and the newly generated summary into a single text for embedding.</p>
<p>Key features of this process:</p>
<ol>
<li>We create embeddings for the combined text (heading + summary + original content) using the Voyage AI API.</li>
<li>The embeddings and full metadata (including summaries) are stored in our vector database.</li>
<li>We implement caching mechanisms to improve efficiency in repeated queries.</li>
<li>The database is saved to disk for persistence and quick loading in future sessions.</li>
</ol>
<p>This summary-indexed approach aims to create more informative embeddings, potentially leading to more accurate and contextually relevant document retrieval.</p>
<pre class="codehilite"><code class="language-python">import os
import numpy as np
import pickle
import json
import voyageai

class SummaryIndexedVectorDB:
    def __init__(self, name, api_key=None):
        if api_key is None:
            api_key = os.getenv(&quot;VOYAGE_API_KEY&quot;)
        self.client = voyageai.Client(api_key=api_key)
        self.name = name
        self.embeddings = []
        self.metadata = []
        self.query_cache = {}
        self.db_path = f&quot;./data/{name}/summary_indexed_vector_db.pkl&quot;

    def load_data(self, data_file):
        # Check if the vector database is already loaded
        if self.embeddings and self.metadata:
            print(&quot;Vector database is already loaded. Skipping data loading.&quot;)
            return
        # Check if vector_db.pkl exists
        if os.path.exists(self.db_path):
            print(&quot;Loading vector database from disk.&quot;)
            self.load_db()
            return

        with open(data_file, 'r') as f:
            data = json.load(f)

        texts = [f&quot;{item['chunk_heading']}\n\n{item['text']}\n\n{item['summary']}&quot; for item in data]  # Embed Chunk Heading + Text + Summary Together
        # Embed more than 128 documents with a for loop
        batch_size = 128
        result = [
            self.client.embed(
                texts[i : i + batch_size],
                model=&quot;voyage-2&quot;
            ).embeddings
            for i in range(0, len(texts), batch_size)
        ]

        # Flatten the embeddings
        self.embeddings = [embedding for batch in result for embedding in batch]
        self.metadata = data  # Store the entire item as metadata
        self.save_db()
        # Save the vector database to disk
        print(&quot;Vector database loaded and saved.&quot;)

    def search(self, query, k=3, similarity_threshold=0.75):
        query_embedding = None
        if query in self.query_cache:
            query_embedding = self.query_cache[query]
        else:
            query_embedding = self.client.embed([query], model=&quot;voyage-2&quot;).embeddings[0]
            self.query_cache[query] = query_embedding

        if not self.embeddings:
            raise ValueError(&quot;No data loaded in the vector database.&quot;)

        similarities = np.dot(self.embeddings, query_embedding)
        top_indices = np.argsort(similarities)[::-1]
        top_examples = []

        for idx in top_indices:
            if similarities[idx] &gt;= similarity_threshold:
                example = {
                    &quot;metadata&quot;: self.metadata[idx],
                    &quot;similarity&quot;: similarities[idx],
                }
                top_examples.append(example)

                if len(top_examples) &gt;= k:
                    break
        self.save_db()
        return top_examples

    def save_db(self):
        data = {
            &quot;embeddings&quot;: self.embeddings,
            &quot;metadata&quot;: self.metadata,
            &quot;query_cache&quot;: json.dumps(self.query_cache),
        }

        # Ensure the directory exists
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)

        with open(self.db_path, &quot;wb&quot;) as file:
            pickle.dump(data, file)

    def load_db(self):
        if not os.path.exists(self.db_path):
            raise ValueError(&quot;Vector database file not found. Use load_data to create a new database.&quot;)

        with open(self.db_path, &quot;rb&quot;) as file:
            data = pickle.load(file)

        self.embeddings = data[&quot;embeddings&quot;]
        self.metadata = data[&quot;metadata&quot;]
        self.query_cache = json.loads(data[&quot;query_cache&quot;])
</code></pre>

<h1 id="enhanced-retrieval-using-summary-indexed-embeddings">Enhanced Retrieval Using Summary-Indexed Embeddings</h1>
<p>In this section, we implement the retrieval process using our new summary-indexed vector database. This approach leverages the enhanced embeddings we created, which incorporate document summaries along with the original content.</p>
<p>Key aspects of this updated retrieval process:</p>
<ol>
<li>We search the vector database using the query embedding, retrieving the top k most similar documents.</li>
<li>For each retrieved document, we include the chunk heading, summary, and full text in the context provided to the LLM.</li>
<li>This enriched context is then used to generate an answer to the user's query.</li>
</ol>
<p>By including summaries in both the embedding and retrieval phases, we aim to provide the LLM with a more comprehensive and focused context. This could potentially lead to more accurate and relevant answers, as the LLM has access to both a concise overview (the summary) and the detailed information (the full text) for each relevant document chunk.</p>
<pre class="codehilite"><code class="language-python">def retrieve_level_two(query, db):
    results = db.search(query, k=3)
    context = &quot;&quot;
    for result in results:
        chunk = result['metadata']
        context += f&quot;\n &lt;document&gt; \n {chunk['chunk_heading']}\n\nText\n {chunk['text']} \n\nSummary: \n {chunk['summary']} \n &lt;/document&gt; \n&quot; #show model all 3 items
    return results, context

def answer_query_level_two(query, db):
    documents, context = retrieve_base(query, db)
    prompt = f&quot;&quot;&quot;
    You have been tasked with helping us to answer the following query: 
    &lt;query&gt;
    {query}
    &lt;/query&gt;
    You have access to the following documents which are meant to provide context as you answer the query:
    &lt;documents&gt;
    {context}
    &lt;/documents&gt;
    Please remain faithful to the underlying context, and only deviate from it if you are 100% sure that you know the answer already. 
    Answer the question now, and avoid providing preamble such as 'Here is the answer', etc
    &quot;&quot;&quot;
    response = client.messages.create(
        model=&quot;claude-3-haiku-20240307&quot;,
        max_tokens=2500,
        messages=[
            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}
        ],
        temperature=0
    )
    return response.content[0].text
</code></pre>

<pre class="codehilite"><code class="language-python"># Initialize the SummaryIndexedVectorDB
level_two_db = SummaryIndexedVectorDB(&quot;anthropic_docs_v2&quot;)
level_two_db.load_data('data/anthropic_summary_indexed_docs.json')

import pandas as pd

# Run the evaluations
avg_precision, avg_recall, avg_mrr, f1, precisions, recalls, mrrs  = evaluate_retrieval(retrieve_level_two, eval_data, level_two_db)
e2e_accuracy, e2e_results = evaluate_end_to_end(answer_query_level_two, level_two_db, eval_data)

# Create a DataFrame
df = pd.DataFrame({
    'question': [item['question'] for item in eval_data],
    'retrieval_precision': precisions,
    'retrieval_recall': recalls,
    'retrieval_mrr': mrrs,
    'e2e_correct': e2e_results
})

# Save to CSV
df.to_csv('evaluation/csvs/evaluation_results_detailed_level_two.csv', index=False)
print(&quot;Detailed results saved to evaluation_results_detailed.csv&quot;)

# Print the results
print(f&quot;Average Precision: {avg_precision:.4f}&quot;)
print(f&quot;Average Recall: {avg_recall:.4f}&quot;)
print(f&quot;Average MRR: {avg_mrr:.4f}&quot;)
print(f&quot;Average F1: {f1:.4f}&quot;)
print(f&quot;End-to-End Accuracy: {e2e_accuracy:.4f}&quot;)

# Save the results to a file
with open('evaluation/json_results/evaluation_results_level_two.json', 'w') as f:
    json.dump({
        &quot;name&quot;: &quot;Summary Indexing&quot;,
        &quot;average_precision&quot;: avg_precision,
        &quot;average_recall&quot;: avg_recall,
        &quot;average_f1&quot;: f1,
        &quot;average_mrr&quot;: avg_mrr,
        &quot;end_to_end_accuracy&quot;: e2e_accuracy
    }, f, indent=2)

print(&quot;Evaluation complete. Results saved to evaluation_results_level_two.json, evaluation_results_detailed_level_two.csv&quot;)
</code></pre>

<pre class="codehilite"><code>Loading vector database from disk.
Evaluating Retrieval:  12%|█▏        | 12/100 [00:00&lt;00:05, 16.06it/s]
Processed 10/100 items. Current Avg Precision: 0.5000, Avg Recall: 0.8000, Avg MRR: 0.8500
Evaluating Retrieval:  22%|██▏       | 22/100 [00:01&lt;00:04, 15.74it/s]
Processed 20/100 items. Current Avg Precision: 0.4000, Avg Recall: 0.6750, Avg MRR: 0.6667
Evaluating Retrieval:  32%|███▏      | 32/100 [00:01&lt;00:04, 16.51it/s]
Processed 30/100 items. Current Avg Precision: 0.4333, Avg Recall: 0.7000, Avg MRR: 0.7222
Evaluating Retrieval:  42%|████▏     | 42/100 [00:02&lt;00:03, 17.05it/s]
Processed 40/100 items. Current Avg Precision: 0.4667, Avg Recall: 0.7125, Avg MRR: 0.7667
Evaluating Retrieval:  52%|█████▏    | 52/100 [00:03&lt;00:02, 16.18it/s]
Processed 50/100 items. Current Avg Precision: 0.4600, Avg Recall: 0.7200, Avg MRR: 0.7700
Evaluating Retrieval:  62%|██████▏   | 62/100 [00:03&lt;00:02, 17.23it/s]
Processed 60/100 items. Current Avg Precision: 0.4611, Avg Recall: 0.7361, Avg MRR: 0.8000
Evaluating Retrieval:  72%|███████▏  | 72/100 [00:04&lt;00:01, 17.01it/s]
Processed 70/100 items. Current Avg Precision: 0.4429, Avg Recall: 0.7060, Avg MRR: 0.7595
Evaluating Retrieval:  82%|████████▏ | 82/100 [00:05&lt;00:01, 15.70it/s]
Processed 80/100 items. Current Avg Precision: 0.4583, Avg Recall: 0.7302, Avg MRR: 0.7896
Evaluating Retrieval:  92%|█████████▏| 92/100 [00:05&lt;00:00, 15.71it/s]
Processed 90/100 items. Current Avg Precision: 0.4593, Avg Recall: 0.7287, Avg MRR: 0.7889
Evaluating Retrieval: 100%|██████████| 100/100 [00:06&lt;00:00, 16.18it/s]

Evaluating End-to-End:   1%|          | 1/100 [00:04&lt;07:26,  4.51s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key elements from the Correct Answer - namely that you can create multiple test cases by clicking the 'Add Test Case' button and filling in values for variables in your prompt, then repeating this process for additional test cases. The Generated Answer actually provides more detail than the Correct Answer by mentioning you can re-run the evaluation suite, but this additional information doesn't contradict the core information. The essential steps and process described are the same in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   2%|▏         | 2/100 [00:10&lt;08:26,  5.17s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key points from the Correct Answer:

1. It correctly identifies Voyage AI as Anthropic's recommended embeddings provider
2. It mentions that Voyage AI offers customized/domain-specific models (including specific examples for finance and healthcare)
3. It notes that Voyage AI provides bespoke fine-tuned models for individual customers

While the Generated Answer provides more specific details about Voyage AI's model offerings that aren't mentioned in the Correct Answer, this additional information doesn't contradict the Correct Answer - it simply elaborates further. The core substance and main points are aligned between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   3%|▎         | 3/100 [00:15&lt;08:43,  5.40s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it covers all the key points mentioned in the Correct Answer and even provides additional helpful details. Both answers mention the same key success metrics: accuracy, F1 score, consistency, structure, speed, and bias/fairness. Both answers also address the relationship between model choice and latency. While the Generated Answer provides more specific details about model options (mentioning claude-3-haiku and Sonnet specifically), this additional detail doesn't contradict the Correct Answer - it merely elaborates on it. The core message about balancing speed and output quality is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   4%|▍         | 4/100 [00:19&lt;07:45,  4.84s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but misses a key element from the correct answer. While both answers highlight the ability to test prompts in parallel across evaluation suites, the second point differs significantly. The correct answer specifically mentions Claude for Sheets' excellence at office tasks like survey analysis and online data processing, while the generated answer instead talks about an integrated workflow and centralized environment. This represents a substantial difference in the functionality being described. Since one of the two key advantages is missing from the generated answer, it cannot be considered fully correct.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   5%|▌         | 5/100 [00:24&lt;07:29,  4.73s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core information - that missing &quot;\n\nHuman:&quot; and &quot;\n\nAssistant:&quot; turns in the prompt will result in an API error. The Generated Answer actually provides slightly more context by explaining that these turns are expected to indicate the start of human input and assistant response, but this additional detail doesn't change the fundamental correctness of the answer. There are no contradictions between the two answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   6%|▌         | 6/100 [00:30&lt;08:16,  5.28s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer and even provides more detailed information while maintaining the same core message. Both answers emphasize that:

1. Tool use requests are priced based on total input and output tokens, just like regular requests
2. There are additional tokens required for tool use, including:
   - The tools parameter
   - Tool use content blocks
   - Tool result content blocks
   - Special system prompt

The Generated Answer expands on these points with more detail but doesn't contradict or omit any critical information from the Correct Answer. The fundamental message about how tool use affects pricing (by adding more tokens that are counted in the same way as regular requests) is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   7%|▋         | 7/100 [00:34&lt;07:15,  4.69s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the essential information from the Correct Answer - specifically the release date (June 27th, 2024) and what features will be available (API usage, billing details, and rate limits). While the Correct Answer provides slightly more detail by mentioning the specific tabs (Usage, Cost, and Rate Limits), this is a minor detail that doesn't change the core meaning. Both answers convey the same fundamental information about what will be available and when.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   8%|▊         | 8/100 [00:39&lt;07:21,  4.80s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it misses a critical element from the Correct Answer. While both answers discuss latency implications of CoT, the Generated Answer fails to mention one of the key decision factors - whether the task requires in-depth thinking that a human would need to work through. The Generated Answer focuses heavily on performance and latency considerations, essentially repeating the same point twice, but doesn't address the fundamental question of whether the task's complexity actually warrants using CoT in the first place. This is a significant omission since it's one of the two key factors mentioned in the Correct Answer for determining when CoT is appropriate.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:   9%|▉         | 9/100 [00:43&lt;07:10,  4.73s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that Claude can be used to summarize PDF documents, making it easier to understand long documents without reading everything. While the Generated Answer provides additional details about text analysis capabilities and mentions the Anthropic Cookbook, these are supplementary details that don't contradict the core message. The essential functionality - uploading PDFs and getting summaries to more easily digest long documents - is accurately captured in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  10%|█         | 10/100 [00:47&lt;06:44,  4.49s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers indicate that you can view the API rate limits in a Rate Limits tab within Anthropic's console interface. The only difference is minor wording variation (&quot;Developer Console&quot; vs &quot;Anthropic Console&quot;) and the Generated Answer's inclusion of the word &quot;new,&quot; but these don't change the core substance of the answer. Both answers convey the same essential information about where to find the rate limits.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 10/100 questions. Current Accuracy: 0.8000
Evaluating End-to-End:  11%|█         | 11/100 [00:54&lt;07:41,  5.19s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect when compared to the correct answer. While the generated answer provides several reasonable metrics for evaluating a ticket classification system, it misses the specific key metrics mentioned in the correct answer: the 95th percentile response time and average cost per classification. The generated answer discusses cost and speed in more general terms, but doesn't mention these specific metrics that were identified in the correct answer. While the additional metrics suggested in the generated answer (like robustness, explainability, adaptability, etc.) might be useful, they don't align with the specific metrics outlined in the correct answer. Since the generated answer is missing these critical pieces of information from the correct answer, it should be marked as incorrect.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  12%|█▏        | 12/100 [00:59&lt;07:39,  5.22s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately describes both methods of specifying system prompts:

1. For Text Completions API: Both answers indicate that the system prompt goes before the first &quot;\n\nHuman:&quot; turn in the prompt text

2. For Messages API: Both answers specify that the system prompt is provided using the &quot;system&quot; parameter in the API request

The Generated Answer actually provides helpful concrete code examples to illustrate these concepts, which goes beyond but doesn't contradict the Correct Answer. The substance and core information about how to specify system prompts in both APIs is consistent between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 9, column 2
Evaluating End-to-End:  13%|█▎        | 13/100 [01:07&lt;08:35,  5.92s/it]
&lt;content&gt;
&lt;explanation&gt;
The generated answer, while detailed and structured, misses a key element from the correct answer. The correct answer specifically mentions using tags like &lt;thinking&gt; and &lt;answer&gt; in combination with chain of thought reasoning where Claude explains its step-by-step thinking process. While the generated answer does discuss using XML tags and breaking down tasks into steps, it doesn't explicitly mention the core concept of using &lt;thinking&gt; tags to prompt Claude to show its reasoning process.

The generated answer focuses more on a general methodology of breaking down tasks and using XML tags for structure, rather than the specific combination of XML tags with chain of thought reasoning that the correct answer describes. The correct answer provides a more focused and specific approach about using tags to explicitly prompt Claude's reasoning process.

Additionally, the correct answer provides a specific example of how to prompt Claude (&quot;Before answering, explain your reasoning step-by-step in &lt;thinking&gt; tags&quot;), which is a crucial piece of information missing from the generated answer.
&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  14%|█▍        | 14/100 [01:13&lt;08:36,  6.01s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect for several reasons:

1. While it correctly identifies that accuracy, cost, and response time are measured, it fails to provide the specific values that were given in the correct answer (89.01% accuracy, 1.61 seconds for 95th percentile response time, $0.0004 for average cost per request).

2. The response time metric is described differently - the correct answer specifically mentions &quot;95th percentile response time&quot; while the generated answer refers to &quot;average latency&quot;

3. The cost metric is described differently - the correct answer specifies &quot;cost per request routing&quot; while the generated answer refers to &quot;total cost&quot;

4. The generated answer includes placeholder text ([RESULT_ACCURACY], [RESULT_COST], [RESULT_RESPONSE_TIME]) instead of actual values.

These differences and omissions make the generated answer incomplete and partially incorrect compared to the correct answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  15%|█▌        | 15/100 [01:18&lt;07:52,  5.55s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the key elements from the Correct Answer:

1. Having clear success criteria
2. Having ways to empirically test against those criteria
3. Having a first draft prompt to improve

The Generated Answer actually provides slightly more detail by mentioning specific documentation sections, but the core substance perfectly matches the Correct Answer. There are no contradictions or missing critical pieces of information. The minor differences in phrasing (like listing the items with numbers vs. combining them in a sentence) don't affect the correctness of the answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  16%|█▌        | 16/100 [01:22&lt;07:11,  5.14s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key distinction between how mid-response prompting works in both APIs:

1. For the Text Completions API, it correctly states that you can &quot;pre-fill part of Claude's response by including it in the prompt&quot;

2. For the Messages API, it correctly explains that you can &quot;make the last input message have the assistant role, and the response will continue from that content&quot;

These points align perfectly with the substance of the Correct Answer. The additional information about streaming, input/output formats, and other differences between the APIs doesn't contradict the core information, it just provides extra context. Since there are no missing critical pieces of information and no contradictions with the Correct Answer, the Generated Answer should be considered correct.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  17%|█▋        | 17/100 [01:29&lt;07:51,  5.68s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the key point made in the Correct Answer - that Claude's response with a role-based system prompt produces a more detailed, structured, and actionable financial analysis compared to not having a specific role. In fact, the Generated Answer goes into even more specific detail about how the analysis differs, breaking down concrete examples of the improvements (like flagging CAC concerns and providing strategic recommendations). While it provides more granular details than the Correct Answer, it does not contradict anything in the Correct Answer and maintains the same core message about the role-based prompt leading to more insightful and structured analysis. The key comparison point about the quality difference between role-based and non-role-based responses is preserved in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  18%|█▊        | 18/100 [01:37&lt;08:42,  6.38s/it]
&lt;content&gt;
&lt;explanation&gt;
The Generated Answer is correct as it captures the key elements from the Correct Answer:

1. It mentions important quantitative metrics, including F1 score, accuracy, and other relevant metrics, which aligns with the Correct Answer's mention of &quot;F1 score, accuracy, precision, and recall.&quot;

2. It discusses how targets should be determined, mentioning industry benchmarks and prior experiments, which directly matches the Correct Answer's statement about basing targets on &quot;industry benchmarks, prior experiments, AI research, or expert knowledge.&quot;

While the Generated Answer provides more specific examples and additional metrics (like response time and toxicity), this additional detail doesn't contradict the Correct Answer - it merely expands upon it. The core substance of both answers is aligned: they both emphasize the importance of quantitative metrics and describe how targets should be determined based on industry standards and prior experience.

There are no critical omissions or contradictions between the two answers.
&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 9, column 182
Evaluating End-to-End:  19%|█▉        | 19/100 [01:41&lt;07:41,  5.70s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key elements from the Correct Answer:

1. The core concept of combining XML tags with other prompt engineering techniques
2. Specifically mentions multishot prompting using &lt;examples&gt; tags
3. Mentions chain of thought using &lt;thinking&gt; and &lt;answer&gt; tags
4. Notes that this creates &quot;super-structured, high-performance prompts&quot;

While the wording is slightly different, the substance and meaning are identical. There are no missing critical pieces of information and no contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  20%|██        | 20/100 [01:48&lt;08:10,  6.13s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the essential elements from the Correct Answer and even provides additional helpful implementation details. Both answers emphasize:

1. The need to provide a detailed rubric
2. Having the LLM evaluate the output against the rubric
3. Getting a &quot;correct&quot; or &quot;incorrect&quot; result as the final output

The Generated Answer goes into more specific implementation details about functions and steps, but this additional information doesn't contradict the core concept presented in the Correct Answer. The substance of how to use an LLM for grading (providing it with both the rubric and content to grade, then getting a binary evaluation) is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 20/100 questions. Current Accuracy: 0.7000
Evaluating End-to-End:  21%|██        | 21/100 [01:53&lt;07:43,  5.87s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer contains all the essential steps from the correct answer and actually provides more detailed information. The core steps are the same:

1. Subscribe to the model package on AWS Marketplace
2. Select and agree to terms
3. Get the Product ARN for your region
4. Create a JupyterLab space in SageMaker Studio
5. Upload and follow Voyage's notebook for deployment

While the generated answer includes additional information about alternative methods (HTTP API and Python package), this extra information doesn't contradict the correct answer - it just provides additional deployment options. The fundamental process for AWS Marketplace deployment matches the correct answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  22%|██▏       | 22/100 [02:00&lt;07:52,  6.06s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is incorrect because it misses some critical elements from the Correct Answer. Specifically:

1. It doesn't mention that you should provide a SINGLE tool (exclusivity)
2. It doesn't mention setting the tool_choice parameter to explicitly instruct the model to use that tool
3. It doesn't mention that tool names and descriptions should be written from the model's perspective since it will pass the input to the tool

While the Generated Answer does discuss JSON formatting and tool usage in general terms, it misses these specific key implementation details that are crucial for properly using tools to generate JSON output. The Generated Answer focuses more on general JSON formatting guidance rather than the specific tool setup requirements outlined in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  23%|██▎       | 23/100 [02:07&lt;08:11,  6.39s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides more detailed information than the Correct Answer while maintaining all the key points. Both answers agree on the fundamental differences:

1. Both mention that Claude 3 Haiku has vision capabilities
2. Both indicate that Claude 3 Haiku is faster and more performant
3. Both note that Claude 3 Haiku has more recent/up-to-date training data

The Generated Answer expands on these points with additional details about context windows, pricing, and language capabilities, but these additions don't contradict the Correct Answer - they simply provide more specific information. The core message about Claude 3 Haiku being more capable, faster, and more up-to-date is consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  24%|██▍       | 24/100 [02:10&lt;07:02,  5.56s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers emphasize the same key point - that using examples helps reduce misinterpretation of instructions and leads to more accurate outputs from Claude. While the Generated Answer adds some additional detail about enforcing uniform structure and style, this doesn't contradict the core message, and the fundamental benefit of reducing misinterpretation is clearly stated in both answers. The Generated Answer effectively captures the essential concept presented in the Correct Answer, just with slightly different wording and additional context.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  25%|██▌       | 25/100 [02:16&lt;06:58,  5.58s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it focuses on different advantages than what is specified in the Correct Answer. The Correct Answer emphasizes the ability to adapt models through providing domain-specific context in prompts without retraining, while the Generated Answer focuses on resource efficiency and cost-effectiveness. While the Generated Answer may state valid benefits of prompt engineering, it misses this critical piece of information about domain adaptation through context provision that is central to the Correct Answer. The answers are discussing different aspects and advantages, making them substantively different.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  26%|██▌       | 26/100 [02:20&lt;06:24,  5.20s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core information - that users can get started quickly by making a copy of Anthropic's provided Claude for Sheets template workbook. While the Generated Answer provides additional details about next steps after copying the template, the fundamental starting point matches the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes the key piece of information about making a copy of the template.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  27%|██▋       | 27/100 [02:25&lt;06:15,  5.15s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the essential meaning of the Correct Answer. Both answers explain that:

1. The &quot;index&quot; field identifies which specific content block the text delta applies to
2. The field is used to track/update content for specific blocks in the response
3. Both imply the relationship between the index and the streaming of text content

While they use slightly different wording and structure, the fundamental explanation of how the index field relates to text streaming and content blocks is consistent between both answers. The Generated Answer may be more technical in its explanation about &quot;cumulative results&quot; and &quot;Message content array,&quot; but it doesn't contradict or miss any critical information from the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  28%|██▊       | 28/100 [02:31&lt;06:27,  5.39s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides additional helpful details beyond the Correct Answer. Both answers agree on the key points:

1. Images must be base64-encoded
2. The supported formats are JPEG, PNG, GIF, and WebP
3. Images are included as part of the message content

The Generated Answer provides extra information about file size limits and maximum number of images per request, but this additional information doesn't contradict the Correct Answer - it simply provides more detail. The slight differences in how they describe the technical implementation (e.g., &quot;image content block&quot; vs &quot;content field with type set to image&quot;) are minor variations in wording that describe the same fundamental concept.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  29%|██▉       | 29/100 [02:37&lt;06:28,  5.47s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that TTFT is a specific component of overall latency, measuring specifically the time to generate the first token of a response. The Generated Answer actually provides additional relevant context about factors affecting TTFT and latency, but this extra information doesn't contradict the Correct Answer - it merely elaborates on it. The key relationship between TTFT and latency is accurately captured in both answers, with both emphasizing that TTFT is a component of overall latency that specifically measures the time to first token generation. The Generated Answer maintains the same essential meaning as the Correct Answer, just expressed with slightly different wording.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  30%|███       | 30/100 [02:44&lt;06:44,  5.78s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that providing examples of edge cases to Claude can improve its performance in routing support tickets. The Generated Answer actually goes into more detail by breaking down specific types of edge cases (implicit requests, emotional prioritization, intent vs. routing, and issue prioritization) and explaining how each type of example can help improve Claude's performance. While it provides more detail than the Correct Answer, it doesn't contradict it and maintains the same fundamental point about examples improving Claude's ability to handle edge cases in ticket routing. The substance and main message are aligned between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 30/100 questions. Current Accuracy: 0.7333
Evaluating End-to-End:  31%|███       | 31/100 [02:50&lt;06:51,  5.96s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures all the essential elements of the Correct Answer. Both answers describe:

1. That Claude determines when a tool is needed and generates a tool use request
2. That this results in a stop_reason of &quot;tool_use&quot;
3. That the user needs to extract the tool input from Claude's request
4. That the tool execution happens client-side
5. That the results need to be sent back to Claude

The Generated Answer actually provides slightly more detail in some areas, but doesn't contradict anything in the Correct Answer. The core workflow and relationship between the stop_reason=&quot;tool_use&quot; and the overall tool integration process is accurately represented in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  32%|███▏      | 32/100 [02:54&lt;06:08,  5.43s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the key information from the Correct Answer:

1. It correctly identifies the &quot;overloaded_error&quot; event as the error that may be sent during high usage periods
2. It correctly states this corresponds to HTTP 529 error code in non-streaming contexts
3. It correctly specifies this is for streaming responses

The Generated Answer simply rephrases the same information in a slightly different way, but maintains all the critical substance and technical details. There are no contradictions or missing pieces of information between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  33%|███▎      | 33/100 [02:58&lt;05:34,  5.00s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It identifies both types of deltas that can be contained in a content_block_delta event: text_delta and input_json_delta. While the formatting and presentation are slightly different (using a numbered list instead of prose), the substance and key information are exactly the same as the Correct Answer. Both answers convey the same two specific delta types without any omissions or contradictions.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  34%|███▍      | 34/100 [03:03&lt;05:20,  4.86s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. According to the Correct Answer, Claude 3.5 Sonnet and tool use became generally available on different dates:

- Claude 3.5 Sonnet: June 20th, 2024
- Tool use: May 30th, 2024

The Generated Answer incorrectly states that both became available on the same date (June 20th, 2024). This is a critical factual error as it misses the key distinction that these were separate releases with different availability dates. The difference in timing between these releases is an important piece of information that is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  35%|███▌      | 35/100 [03:06&lt;04:44,  4.38s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct in substance. While it doesn't include the specific timing (May 2024 for Europe and June 2024 for Canada), it accurately captures the key information about the order of launches - that Anthropic launched Claude.ai and the Claude iOS app in Europe first, followed by Canada. The omission of specific months doesn't change the fundamental accuracy of the sequence of events described.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  36%|███▌      | 36/100 [03:11&lt;04:56,  4.64s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the essential elements from the Correct Answer:

1. It correctly identifies that &quot;tool_use&quot; indicates Claude has decided to use a tool
2. It outlines the same key steps that need to be taken:
   - Extracting the tool name and input
   - Executing the tool code client-side
   - Sending back results in a tool_result content block

While the wording is slightly different, the substance and technical accuracy are completely aligned with the Correct Answer. There are no missing critical pieces of information and no contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  37%|███▋      | 37/100 [03:15&lt;04:42,  4.49s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same essential information as the Correct Answer. Both answers indicate that the anthropic library is used to interact with Claude/Anthropic's AI capabilities. While the Generated Answer provides slightly more detail by explaining what the anthropic library does, the core substance - that the anthropic library is the Python library used in the example - is consistent between both answers. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  38%|███▊      | 38/100 [03:20&lt;04:48,  4.66s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both main authentication methods described in the Correct Answer:

1. Direct provision of AWS credentials (access key, secret key, and optional session token)
2. Using default AWS credential providers (including both the ~/.aws/credentials file and environment variables)

The Generated Answer conveys the same essential information as the Correct Answer, just with slightly different wording. There are no missing critical pieces of information and no contradictions between the two answers. The substance and meaning are equivalent.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  39%|███▉      | 39/100 [03:25&lt;04:51,  4.78s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the same two key factors mentioned in the Correct Answer:

1. The risk/potential of prompt leaks (protecting sensitive information)
2. The impact on model performance due to added complexity

While the Generated Answer elaborates more on each factor with additional examples and details, the core substance and trade-off described is identical to the Correct Answer. Both answers emphasize the need to balance protecting against leaks with maintaining model performance. There are no contradictions between the two answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  40%|████      | 40/100 [03:31&lt;04:57,  4.96s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it conveys the same core message as the Correct Answer. Both answers emphasize that:

1. Anthropic offers different Claude models with varying capabilities and performance characteristics
2. Selecting the right model that matches your specific needs helps optimize for speed and performance
3. The choice of model affects the balance of performance and output quality

While the Generated Answer provides additional details about model families and the model overview page, these don't contradict the Correct Answer but rather expand upon it. The fundamental point about choosing the appropriate model to reduce latency is preserved in both answers. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 40/100 questions. Current Accuracy: 0.7750
Evaluating End-to-End:  41%|████      | 41/100 [03:36&lt;05:02,  5.13s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It contains all the essential information from the Correct Answer and even provides more detailed implementation examples. Both answers highlight the key points that:

1. You use the client.messages.stream() method
2. You iterate over the stream.text_stream attribute in a for loop

The Generated Answer expands on this with a practical code example and additional context, but the core information matches perfectly with the Correct Answer. There are no contradictions or missing critical pieces between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  42%|████▏     | 42/100 [03:42&lt;04:59,  5.16s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both key points from the Correct Answer:

1. It explains that you can guide Claude's response by pre-filling part of it in the messages list (though it specifically mentions the &quot;assistant&quot; message, which is just a more detailed explanation of the same concept)

2. It correctly identifies that the &quot;max_tokens&quot; parameter is used to generate short responses by limiting the length of the output

The substance and main concepts are the same between both answers, even though the exact wording differs slightly. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  43%|████▎     | 43/100 [03:46&lt;04:50,  5.09s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core message: that when building an eval set, it's better to have a larger number of test cases with automated grading rather than fewer test cases with high-quality human grading. The Generated Answer expands on this with additional details about automated grading methods, but the fundamental point matches exactly with the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes all critical information from the Correct Answer. While the Generated Answer provides more detail, this additional context doesn't change or contradict the main point.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  44%|████▍     | 44/100 [03:51&lt;04:28,  4.79s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. According to the Correct Answer, the two required fields are &quot;index&quot; and &quot;delta&quot;, where &quot;delta&quot; contains the &quot;type&quot; and &quot;text&quot;. The Generated Answer instead lists &quot;type&quot; and &quot;text&quot; as the required fields, which is not accurate according to the Correct Answer. This is a substantive difference, not just a wording variation, as it misidentifies the top-level required fields in the event structure. The Generated Answer is missing the critical &quot;index&quot; field requirement and incorrectly elevates &quot;type&quot; and &quot;text&quot; (which are actually nested within the &quot;delta&quot; field) to be the main required fields.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  45%|████▌     | 45/100 [03:55&lt;04:21,  4.76s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it misses a critical piece of information from the Correct Answer. While it correctly mentions the Anthropic Cookbook as one interactive way to learn Claude's capabilities, it completely fails to mention the Developer Console and its prompt generator tool, which is the second key interactive learning method specified in the Correct Answer. Instead, it incorrectly references &quot;Claude for Sheets usage examples&quot; as the second method, which wasn't mentioned in the Correct Answer at all. The omission of the Developer Console and the inclusion of incorrect information makes this answer incomplete and partially inaccurate.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  46%|████▌     | 46/100 [04:00&lt;04:19,  4.81s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. The core concept from the Correct Answer - that breaking tasks into subtasks improves accuracy because each subtask gets Claude's full attention and reduces errors compared to handling everything at once - is fully captured in the Generated Answer's first point about accuracy. While the Generated Answer goes on to provide additional points about clarity and traceability, these are supplementary details that don't contradict the core concept. The essential reasoning about improved accuracy through focused attention on subtasks is present and aligned between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  47%|████▋     | 47/100 [04:06&lt;04:28,  5.06s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key distinction mentioned in the Correct Answer - that Messages streaming responses can contain multiple content blocks of varying types, making them more complex than Text Completions streaming. While the Generated Answer provides additional details about the specific implementation differences, its core message aligns with the Correct Answer's main point about the fundamental difference in complexity and structure between the two streaming formats. There are no contradictions between the answers, and the Generated Answer includes all critical information from the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  48%|████▊     | 48/100 [04:10&lt;04:12,  4.86s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While it correctly mentions claude.ai and the web Console as one way to experiment with Claude, it incorrectly lists the Quickstart guide/API call as the second method instead of just the web Console. The Correct Answer specifically states that the two ways are claude.ai and Anthropic's web Console, which are essentially referring to the same interface. The Generated Answer introduces a different method (API calls) that wasn't mentioned in the Correct Answer. This represents a substantive difference in the information provided, not just a difference in wording.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  49%|████▉     | 49/100 [04:16&lt;04:20,  5.11s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that chain prompts help reduce errors and inconsistencies by breaking complex tasks into smaller, more manageable subtasks that Claude can focus on individually. While the Generated Answer provides more detailed explanations and additional benefits (like traceability and debugging), it doesn't contradict the Correct Answer. The fundamental principle - that breaking tasks into smaller pieces helps reduce errors and maintain consistency - is preserved in both answers. The additional details in the Generated Answer simply elaborate on the basic concept without changing its essential meaning.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  50%|█████     | 50/100 [04:21&lt;04:10,  5.01s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers state that an overloaded_error event corresponds to HTTP status code 529 in a non-streaming context for the Anthropic API. While the Correct Answer uses slightly more formal language (&quot;would normally correspond to&quot;), the core information - the 529 status code - is identical in both answers. The difference in phrasing does not change the fundamental meaning or accuracy of the response.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 50/100 questions. Current Accuracy: 0.7600
Evaluating End-to-End:  51%|█████     | 51/100 [04:25&lt;03:36,  4.42s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the exact same two ways to specify the embedding format as mentioned in the Correct Answer:

1. Both answers indicate that leaving the format unspecified will return embeddings as lists of floating-point numbers
2. Both answers state that setting the format to &quot;base64&quot; will return the embeddings as Base64 encodings

The Generated Answer simply presents the information in a more structured bullet-point format, but conveys the same essential information as the Correct Answer. There are no missing critical details or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  52%|█████▏    | 52/100 [04:31&lt;04:08,  5.18s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures all the essential elements from the Correct Answer:

1. It correctly explains that tool_use content blocks are sent as partial JSON strings
2. It mentions that these are sent as content_block_delta events
3. It notes that the client needs to accumulate these deltas
4. It mentions that parsing happens after receiving a content_block_stop event
5. It references both Pydantic and SDK helpers as parsing options

While the wording and structure differ slightly, the Generated Answer conveys the same key information and technical details as the Correct Answer. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  53%|█████▎    | 53/100 [04:35&lt;03:45,  4.79s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately identifies and describes both tutorials that Anthropic offers:

1. The GitHub tutorial which covers prompt engineering concepts with examples
2. The Google Sheets tutorial which is described as a lighter-weight version

The Generated Answer captures the key distinctions between the two tutorials and their delivery methods. While the exact wording differs slightly from the Correct Answer, the substance and meaning are essentially identical. The Generated Answer doesn't miss any critical information or make any contradictory claims compared to the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  54%|█████▍    | 54/100 [04:44&lt;04:38,  6.05s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides more comprehensive detail than the Correct Answer. It covers all the key points mentioned in the Correct Answer:

1. The 200K token context window
2. Tool use capabilities for integration with specialized applications
3. Multimodal input capabilities
4. Enterprise-grade security and data handling for sensitive information

The Generated Answer then goes beyond these points to provide additional relevant details about enterprise capabilities, such as HIPAA compliance, SOC II certification, reliability features, and global language support. While it contains more information than the Correct Answer, it doesn't contradict any points and includes all the critical elements specified in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  55%|█████▌    | 55/100 [04:47&lt;03:50,  5.12s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect because it omits a key region where Claude.ai API and iOS app are available - the United States. While the Generated Answer correctly mentions Canada and Europe, leaving out the United States represents a significant omission of information. The availability in all three regions (United States, Canada, and Europe) is a critical part of the complete and accurate answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  56%|█████▌    | 56/100 [04:54&lt;04:06,  5.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer and even provides additional helpful detail while maintaining the same core information:

1. It correctly identifies the two main approaches (push-based with webhooks and pull-based)
2. It accurately describes that push-based is more scalable but has security implications due to requiring a public endpoint
3. It correctly states that pull-based is easier to implement but has the drawback of making unnecessary calls to the support ticket system

The Generated Answer expands on these points with more detail, but does not contradict or omit any critical information from the Correct Answer. The substance and main distinctions between the two approaches are preserved.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  57%|█████▋    | 57/100 [04:58&lt;03:39,  5.11s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is completely correct. It contains all the key information from the Correct Answer: the release date (May 10th, 2024), what was released (a prompt generator tool), and where it's available (through the Developer Console). The wording is slightly different but conveys exactly the same information and meaning. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  58%|█████▊    | 58/100 [05:03&lt;03:34,  5.10s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers identify the Claude 3 Sonnet model as providing the best balance of intelligence and speed for high-throughput tasks like sales forecasting and targeted marketing. While the Generated Answer provides additional details and comparisons with other models, its core conclusion matches exactly with the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes all critical information present in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  59%|█████▉    | 59/100 [05:07&lt;03:26,  5.02s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information:

1. They both state that you can use either dot product or cosine similarity to calculate the similarity between Voyage embedding vectors
2. They both explain that these methods are equivalent because Voyage embeddings are normalized to length 1
3. The Generated Answer actually provides slightly more explanation about why this equivalence exists, but this additional detail doesn't change the core correctness

While the Generated Answer presents the information in a slightly different order and with different phrasing, the fundamental technical content and meaning is identical to the Correct Answer. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  60%|██████    | 60/100 [05:14&lt;03:44,  5.61s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key points from the Correct Answer and even expands on them in a complementary way. Both answers emphasize that examples help:

1. Reduce misinterpretation of instructions
2. Enforce consistent structure and style
3. Guide Claude toward desired output/performance

The Generated Answer provides additional details and examples, but these don't contradict the core message of the Correct Answer - they simply elaborate on it. The substance of both answers is fundamentally the same, even though they're worded differently. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 60/100 questions. Current Accuracy: 0.7833
Evaluating End-to-End:  61%|██████    | 61/100 [05:20&lt;03:32,  5.45s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It accurately identifies and describes the two types of content block deltas:

1. It correctly explains that input JSON deltas contain partial JSON strings for tool use inputs
2. It correctly identifies text deltas as containing text content updates

While the wording is slightly different from the Correct Answer, the substance and key information is the same. The Generated Answer effectively communicates that these deltas represent partial/incremental updates to their respective content types (text and JSON input). There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  62%|██████▏   | 62/100 [05:25&lt;03:28,  5.48s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the same key capabilities mentioned in the Correct Answer, just with slightly more detail and different phrasing. Both answers highlight:

1. Question answering/interactive capabilities for building systems like chatbots
2. Text analysis capabilities for personalization through understanding sentiment and preferences

The Generated Answer expands on these points with more specific examples (like customer support chatbots and educational AI tutors), but the core capabilities described are the same. There are no contradictions or missing critical pieces of information between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  63%|██████▎   | 63/100 [05:30&lt;03:18,  5.38s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures all the key elements from the Correct Answer and presents them in essentially the same order:

1. Both answers mention the message_start event coming first
2. Both describe the content blocks structure with start, delta, and stop events
3. Both mention message_delta events
4. Both include the message_stop event at the end
5. Both note that ping events may be dispersed throughout

The Generated Answer actually provides slightly more detail by explicitly mentioning that the message_start contains a Message object with empty content, but this additional detail doesn't contradict the Correct Answer. The core sequence and components are identical between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  64%|██████▍   | 64/100 [05:34&lt;02:56,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that the Anthropic API allows up to 20 images per request, while the claude.ai interface has a 5 image limit. While the Correct Answer provides slightly more context by mentioning &quot;Messages API&quot; and &quot;per turn,&quot; the core numerical limits are identical and accurately stated in the Generated Answer. The substance and critical information about the image limits are preserved, even if expressed more concisely.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  65%|██████▌   | 65/100 [05:38&lt;02:46,  4.74s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key substance of the Correct Answer, which is that when Claude's response contains an incomplete tool use block due to hitting the max_tokens limit, you should retry with a higher max_tokens value. The Generated Answer conveys the same essential instruction and solution as the Correct Answer, just with slightly different wording. There are no missing critical pieces of information or contradictions between the two answers. Both answers communicate the same core concept and recommended action.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  66%|██████▌   | 66/100 [05:42&lt;02:32,  4.49s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While both answers agree on the first step (developing test cases), they differ on the second step. The Correct Answer states that the second step is to &quot;take a look at Anthropic's guide to developing test cases&quot;, while the Generated Answer states it is to &quot;build a strong input prompt&quot;. These are substantively different steps. The Generated Answer misses the critical guidance about consulting Anthropic's documentation on test case development, which is specified in the Correct Answer. This represents a meaningful difference in the substance of what needs to be done before running a classification evaluation.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  67%|██████▋   | 67/100 [05:54&lt;02:57,  5.37s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but includes additional information that goes beyond what is specified in the correct answer and may not be accurate according to Anthropic's documentation. While it correctly mentions that you can pre-fill Claude's response using the &quot;Assistant&quot; role in messages, it adds several other claims about system prompts, simulating conversations, and max_tokens that aren't mentioned in the correct answer and may not be accurate implementations of the content parameter specifically. The core functionality - using the content parameter with assistant role to pre-fill responses - is present in the generated answer, but it's mixed with other unverified claims. Since we want to be strict about accuracy when dealing with documentation, and the answer includes potential misinformation alongside the correct information, it should be marked as incorrect.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  68%|██████▊   | 68/100 [06:00&lt;02:40,  5.03s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures both key advantages mentioned in the Correct Answer:

1. It correctly states that prompt engineering preserves general knowledge while fine-tuning risks catastrophic forgetting
2. It accurately notes that prompt engineering is more effective at helping models understand and utilize external content/retrieved documents

The Generated Answer essentially restates the same two main points from the Correct Answer, just with slightly different wording. There are no missing critical pieces of information and no contradictions between the two answers. The substance and meaning are identical.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  69%|██████▉   | 69/100 [06:05&lt;02:34,  4.99s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While it describes some technical aspects of using the API, it misses one of the key initial setup requirements mentioned in the Correct Answer - specifically installing and configuring the AWS CLI. The Generated Answer jumps straight into authentication and client creation details, but skips over the fundamental prerequisite of having the AWS CLI installed and configured. Additionally, the Correct Answer mentions the need to install an SDK for accessing Bedrock, which is not explicitly mentioned in the Generated Answer. These are important initial setup steps that are materially different from the authentication and client creation steps described in the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

ERROR:root:XML parsing error: mismatched tag: line 3, column 601
Evaluating End-to-End:  70%|███████   | 70/100 [06:09&lt;02:27,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It provides the exact same command structure and functionality as the Correct Answer, including:

1. The correct AWS CLI command `aws bedrock list-foundation-models`
2. The correct use of the `--region` parameter
3. The correct use of `--by-provider anthropic`
4. The correct query parameter to get model IDs
5. A specific example using `us-west-2` region

The Generated Answer conveys the same essential information and instructions as the Correct Answer, just with slightly different wording in the explanatory text. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 70/100 questions. Current Accuracy: 0.6429
Evaluating End-to-End:  71%|███████   | 71/100 [06:14&lt;02:19,  4.80s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that the `input_type` argument can be passed to specify whether the input text is a &quot;query&quot; or &quot;document&quot;. The Generated Answer actually provides additional detail about how the input_type affects processing, but this extra information doesn't contradict the Correct Answer. The essential point about the existence and purpose of the `input_type` parameter is accurately conveyed in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  72%|███████▏  | 72/100 [06:19&lt;02:15,  4.86s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is missing a critical piece of information that is present in the Correct Answer. While it correctly describes the basic difference between tool_use deltas (partial JSON strings for input field) and text deltas (simple text updates), it fails to mention that tool_use deltas may have delays between streaming events as the model emits one complete key-value pair at a time. This timing/delay characteristic is an important distinction mentioned in the Correct Answer that is completely absent from the Generated Answer. Since this represents a meaningful omission of a key technical detail about how the streaming works, the Generated Answer cannot be considered fully correct.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  73%|███████▎  | 73/100 [06:23&lt;02:07,  4.72s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It provides the exact same file size limits as the Correct Answer - 5MB for API uploads and 10MB for claude.ai uploads. The Generated Answer simply presents this information in a slightly different format (bullet points) and adds a minor detail about error messages, but the core information about the file size limits matches perfectly with the Correct Answer. There are no contradictions or missing critical pieces of information.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  74%|███████▍  | 74/100 [06:28&lt;02:05,  4.81s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers emphasize the key point of choosing a model that appropriately balances requirements for the specific use case. The Generated Answer actually provides more detail by mentioning Claude 3 Haiku as a specific example, but the core message about selecting a model based on the balance of speed/latency and output quality is present in both answers. There are no contradictions between the two answers, and the Generated Answer captures the essential consideration mentioned in the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  75%|███████▌  | 75/100 [06:33&lt;01:58,  4.75s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the key points from the Correct Answer:

1. It correctly identifies voyage-code-2 as the recommended embedding model
2. It correctly mentions the 17% performance improvement

The only minor difference is that the Generated Answer doesn't mention that the model achieves state-of-the-art results on general-purpose corpora. However, this is a supplementary detail rather than a critical piece of information about the core recommendation and performance comparison. The essential substance about the model recommendation and its 17% performance improvement is accurately conveyed.

Since the Generated Answer maintains the core accuracy of the information without any contradictions, just omitting a non-critical detail, it should be considered correct.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  76%|███████▌  | 76/100 [06:37&lt;01:48,  4.52s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is partially correct but not fully aligned with the Correct Answer. While both answers mention interactive Jupyter notebooks and working with PDFs, the Generated Answer diverges by discussing extending Claude's capabilities and VoyageAI, which aren't mentioned in the Correct Answer. The Correct Answer specifically mentions &quot;embeddings&quot; as a key feature, but the Generated Answer only mentions embeddings in the context of VoyageAI, which isn't part of the official answer. Since the Generated Answer misses the direct focus on embeddings as a core feature and includes potentially incorrect information about VoyageAI, it cannot be considered fully correct.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  77%|███████▋  | 77/100 [06:43&lt;01:56,  5.08s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the core concept presented in the Correct Answer - that a larger context window allows the model to incorporate more retrieved information during RAG, which improves the quality of the generated output. Both answers emphasize that larger context windows allow for better utilization of retrieved information, leading to improved performance. While the Generated Answer provides additional details about latency considerations and trade-offs, these additions don't contradict the Correct Answer - they simply provide more context and depth. The fundamental relationship between context window size and RAG effectiveness is consistently presented in both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  78%|███████▊  | 78/100 [06:50&lt;02:00,  5.49s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures all the key points from the Correct Answer and even expands on them in a helpful way. Both answers emphasize:

1. The tool's ability to identify edge cases where prompts might not perform well
2. The capability to rate individual results to assess prompt performance
3. The importance of ensuring consistent performance across different inputs
4. The ability to review results and spot patterns for making improvements
5. The ultimate goal of creating more robust and reliable AI applications

The Generated Answer adds some additional context about the beta status and feedback process, but this doesn't contradict the Correct Answer - it just provides extra information. The core substance and main points about how the Evaluation tool helps improve prompts are consistent between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  79%|███████▉  | 79/100 [06:54&lt;01:46,  5.05s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers state that Claude 3 Haiku has the fastest comparative latency. The Generated Answer provides additional context about classification tasks and compares it to other models, but the core claim about Haiku being the fastest matches exactly with the Correct Answer. There are no contradictions or missing critical information between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  80%|████████  | 80/100 [07:01&lt;01:51,  5.58s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It conveys the same core concept as the Correct Answer - that to have a multi-turn conversation using the Anthropic Messages API, you need to send the full conversation history with each request because the API is stateless. The Generated Answer actually provides more detail and a concrete code example, but the fundamental principle matches the Correct Answer. Both answers emphasize the importance of maintaining and sending the complete conversation history for each API call. There are no contradictions between the answers, and no critical information from the Correct Answer is missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 80/100 questions. Current Accuracy: 0.7750
Evaluating End-to-End:  81%|████████  | 81/100 [07:08&lt;01:56,  6.14s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the core message of the Correct Answer. Both answers emphasize that using XML tags to provide a specific role context (like General Counsel) helps Claude catch critical legal issues and risks in contract analysis that might otherwise be missed. While the Generated Answer provides more detail and additional benefits (like improved focus and parseability), it doesn't contradict the Correct Answer and includes the key point about helping to identify critical legal issues that could save the company from significant risks. The essence of both answers is the same - role prompting with XML tags improves Claude's ability to analyze legal contracts by providing important context that leads to better identification of crucial legal issues.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  82%|████████▏ | 82/100 [07:12&lt;01:39,  5.55s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is essentially correct. Both answers convey the same core distinction between how the two models handle missing information in tool calls: Claude 3 Opus is more likely to ask for clarification when information is missing, while Claude 3 Sonnet is more likely to try to infer or fill in missing information on its own. While the Generated Answer uses slightly different wording and adds some additional context about the models' general capabilities, the fundamental comparison regarding how they handle missing information matches the Correct Answer. There are no critical omissions or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  83%|████████▎ | 83/100 [07:20&lt;01:47,  6.30s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it covers all the key points mentioned in the Correct Answer and even provides additional helpful detail. Both answers emphasize:

1. Implementing retry logic for error handling
2. Conducting thorough staging/testing
3. Load testing
4. Error handling and logging setup
5. Gradual rollout process
6. Documentation and training
7. Monitoring and alerting

The Generated Answer expands on these points with more specific implementation details, but the core recommendations align perfectly with the Correct Answer. There are no contradictions between the two answers, and no critical pieces of information from the Correct Answer are missing from the Generated Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  84%|████████▍ | 84/100 [07:26&lt;01:40,  6.26s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It covers all three key evaluation metrics mentioned in the Correct Answer:

1. Accuracy (&quot;Accuracy: The percentage of correct predictions...&quot;)
2. Cost (&quot;Average Cost per Classification...&quot;)
3. Speed (&quot;95th Percentile Response Time...&quot;)

While the Generated Answer provides additional details and context beyond what's in the Correct Answer, it fully encompasses the core evaluation criteria specified in the Correct Answer. The extra information doesn't contradict the Correct Answer, it merely elaborates on it. Since all three essential components (accuracy, cost, and speed) are present and there are no contradictions, the Generated Answer should be considered correct.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  85%|████████▌ | 85/100 [07:31&lt;01:24,  5.63s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers identify the same two recommended methods for learning prompt engineering with Claude:

1. The GitHub prompting tutorial
2. The Google Sheets prompting tutorial

The Generated Answer provides slightly more detail by mentioning that the GitHub tutorial is &quot;example-filled&quot; and that the Google Sheets version is a &quot;lighter weight version,&quot; but these are just additional descriptive details that don't change the core substance. The fundamental information about the two recommended learning methods matches between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  86%|████████▌ | 86/100 [07:37&lt;01:23,  5.94s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct as it captures the key substantive differences outlined in the Correct Answer. Both answers emphasize that:

1. Pretrained LLMs are initially trained on unlabeled text data
2. These base models are not inherently good at following instructions/answering questions
3. Claude has undergone additional training/fine-tuning (including RLHF) to make it more capable at various tasks

While the Generated Answer includes additional details about interpretability and adaptability that aren't mentioned in the Correct Answer, these additions don't contradict the core message. The Generated Answer maintains the essential contrast between basic pretrained models and Claude's enhanced capabilities through additional training.

The substance and main points align between both answers, even though they are worded differently.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  87%|████████▋ | 87/100 [07:45&lt;01:23,  6.40s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides a more detailed expansion of the key points mentioned in the Correct Answer. It covers all the main advantages mentioned in the Correct Answer:

1. Cost and resource efficiency (points 1 and 2)
2. Speed and time efficiency (point 4)
3. Less data requirements (point 5)
4. Flexibility and rapid iteration (point 6)
5. Preservation of general knowledge (point 9)
6. Transparency (point 10)

The Generated Answer not only includes all the core concepts from the Correct Answer but also provides additional relevant details and examples. There are no contradictions between the two answers, and the Generated Answer doesn't miss any critical information from the Correct Answer. While the Generated Answer is more verbose and detailed, the substance and main points align perfectly with the Correct Answer.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  88%|████████▊ | 88/100 [07:49&lt;01:08,  5.75s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that you need to run the command `gcloud auth application-default login` to authenticate with GCP before accessing Claude models on Vertex AI. The Generated Answer adds a bit more context about why this authentication is needed (to access resources), but this additional detail doesn't change or contradict the core instruction. The substance and critical information is identical between both answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  89%|████████▉ | 89/100 [07:54&lt;00:59,  5.43s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the core information about the Prompt Generator tool being introduced on May 10th, 2024, and its main purpose of helping users create tailored prompts for specific tasks. While the Correct Answer provides additional context about the Claude iOS app and Claude Team plan, these are supplementary details rather than critical pieces of information about the Prompt Generator capabilities themselves. The Generated Answer accurately conveys the essential functionality and purpose of the new tool, even if it's more concise. There are no contradictions between the two answers, and the key functionality of helping users create customized prompts is preserved in both versions.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  90%|█████████ | 90/100 [07:57&lt;00:49,  4.91s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It conveys exactly the same information as the Correct Answer - that both Claude 3.5 Sonnet and the Artifacts feature became available on June 20th, 2024. While the wording is slightly different (omitting &quot;both&quot; and having a slightly different sentence structure), the core information and meaning are identical. There are no missing critical details or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 90/100 questions. Current Accuracy: 0.7000
Evaluating End-to-End:  91%|█████████ | 91/100 [08:02&lt;00:42,  4.71s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same key information - that to limit Claude's response to a single token, you should use the &quot;max_tokens&quot; parameter set to 1 in the request. The Generated Answer uses slightly different wording but communicates the same essential concept. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  92%|█████████▏| 92/100 [08:05&lt;00:35,  4.48s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. Both answers convey the same core concept that temperature controls randomness in the model's output generation. The Generated Answer simply provides more detail and elaboration about what higher and lower temperatures do specifically, but the fundamental meaning matches the Correct Answer. There are no contradictions between the two answers, and the Generated Answer includes the key concept about randomness control that is present in the Correct Answer. The additional details in the Generated Answer serve to explain the concept further rather than change its meaning.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  93%|█████████▎| 93/100 [08:10&lt;00:31,  4.54s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is incorrect. While it correctly identifies one way to specify API parameters (adding them as additional arguments after the prompt and model), it misses the second key method mentioned in the Correct Answer - the ability to pass in an API key for a specific cell. Instead, it incorrectly states that CLAUDEMESSAGES is the second method. The CLAUDEMESSAGES function is not mentioned in the Correct Answer at all, making this a significant deviation from the correct information. Since one of the two main methods is completely different from what's specified in the Correct Answer, this constitutes a critical error.&lt;/explanation&gt;
&lt;is_correct&gt;false&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  94%|█████████▍| 94/100 [08:14&lt;00:26,  4.46s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer captures the key points from the Correct Answer:

1. Prefilling with { causes Claude to skip the preamble
2. Results in direct JSON object output
3. Makes the response more concise
4. Makes it easier for programs to parse

While the wording is slightly different, the substance and meaning are essentially identical. The Generated Answer effectively communicates the same information about how prefilling with a curly brace affects Claude's output behavior. There are no missing critical pieces of information or contradictions between the two answers.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  95%|█████████▌| 95/100 [08:19&lt;00:22,  4.58s/it]
&lt;content&gt;
&lt;explanation&gt;The generated answer is partially correct but contains extra information that is not verified by the correct answer. The first two points about the multimodal cookbook and API reference documentation match the correct answer's substance. However, the third point about the developer community is not mentioned in the correct answer and appears to be additional unverified information. Since this addition doesn't contradict the correct information but rather adds to it, and the core resources (cookbook and API reference) are accurately captured, the generated answer can be considered substantially correct in terms of the key information provided.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  96%|█████████▌| 96/100 [08:22&lt;00:13,  4.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct and actually provides more detailed information than the Correct Answer while maintaining the same core information. Both answers convey that:

1. The API key can be specified as a parameter when creating a new Anthropic client
2. If not provided explicitly, the SDK will default to using the ANTHROPIC_API_KEY environment variable

The Generated Answer goes further by providing specific code examples in both Python and TypeScript, but this additional detail doesn't contradict or omit any of the key information from the Correct Answer. The substance of both answers is essentially the same.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  97%|█████████▋| 97/100 [08:26&lt;00:13,  4.60s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the same two key benefits mentioned in the Correct Answer:

1. Both answers mention identifying edge cases where prompts might fail/falter
2. Both answers emphasize ensuring consistent performance across test inputs/cases

The Generated Answer breaks these points out more explicitly with numbering, but the core substance is identical to the Correct Answer. The slight differences in wording (e.g., &quot;rate individual results&quot; vs &quot;test case inputs&quot;) don't change the fundamental meaning. Both answers emphasize the tool's ability to help identify problems and ensure reliability across different scenarios.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  98%|█████████▊| 98/100 [08:30&lt;00:10,  5.48s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It captures the key points from the Correct Answer:

1. It acknowledges that the pretrained model is not inherently good at answering questions or following instructions (matching the Correct Answer)

2. It explains that the final version of Claude went through fine-tuning and RLHF to become more helpful and capable (matching the Correct Answer)

While the Generated Answer provides additional details about biases and capabilities, these don't contradict the Correct Answer - they merely expand upon it. The core message about the transformation from pretrained model to final API version through fine-tuning and RLHF is consistent between both answers.

There are no critical pieces of information from the Correct Answer that are missing from the Generated Answer, nor are there any contradictions between the two.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End:  99%|█████████▉| 99/100 [08:33&lt;00:04,  4.67s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is exactly identical to the Correct Answer, stating that Anthropic's IPv6 address range is 2607:6bc0::/48. There are no differences in wording or substance, and all critical information is present.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Evaluating End-to-End: 100%|██████████| 100/100 [08:37&lt;00:00,  5.18s/it]
&lt;content&gt;
&lt;explanation&gt;The Generated Answer is correct. It identifies the same two methods for specifying the API key as mentioned in the Correct Answer:

1. Using the ANTHROPIC_API_KEY environment variable
2. Passing the API key directly when initializing the client

While the Generated Answer is more concise, it contains the same essential information as the Correct Answer. The additional details in the Correct Answer (like mentioning that the environment variable is used &quot;by default&quot;) are supplementary and don't change the core correctness of the Generated Answer. There are no contradictions between the two answers, and no critical information is missing.&lt;/explanation&gt;
&lt;is_correct&gt;true&lt;/is_correct&gt;
&lt;/content&gt;

Processed 100/100 questions. Current Accuracy: 0.7900
Detailed results saved to evaluation/csvs/evaluation_results_detailed_level_two.csv
Average Precision: 0.4533
Average Recall: 0.7142
Average MRR: 0.7733
Average F1: 0.5546
End-to-End Accuracy: 0.7900
Evaluation complete. Results saved to evaluation_results_level_two.json, evaluation_results_detailed_level_two.csv
</code></pre>

<pre class="codehilite"><code class="language-python">#visualizing our performance
plot_performance('evaluation/json_results', ['Basic RAG', 'Summary Indexing'])
</code></pre>

<p><img alt="png" src="guide_files/guide_28_0.png" /></p>
<h2 id="level-3-re-ranking-with-claude">Level 3 - Re-Ranking with Claude</h2>
<p>In this final enhancement to our retrieval system, we introduce a reranking step to further improve the relevance of the retrieved documents. This approach leverages Claude's power to better understand the context and nuances of both the query and the retrieved documents.</p>
<p>The <code>rerank_results</code> function uses Claude to reassess and reorder the initially retrieved documents:</p>
<ol>
<li>It presents Claude with the query and summaries of all retrieved documents.</li>
<li>Claude is asked to select and rank the most relevant documents.</li>
<li>The function parses Claude's response to get the reranked document indices.</li>
<li>It includes fallback mechanisms in case of errors or insufficient results.</li>
<li>Finally, it assigns descending relevance scores to the reranked results.</li>
</ol>
<p>The <code>retrieve_advanced</code> function implements the new retrieval pipeline:</p>
<ol>
<li>We initially retrieve more documents than needed (default 20, configurable via <code>initial_k</code>) from the vector database.</li>
<li>We then use the <code>rerank_results</code> function to refine this larger set down to the most relevant documents (default 3, configurable via <code>k</code>).</li>
<li>Finally, it generates a new context string from these reranked documents.</li>
</ol>
<p>This process casts a wider net initially and then uses AI to focus on the most pertinent information. By combining vector-based retrieval with LLM reranking, this approach aims to provide more accurate and contextually appropriate responses to user queries.</p>
<p>Our evaluations show significant improvements:</p>
<ul>
<li>Accuracy increased from 78% in our previous system to 85%.</li>
<li>Precision was improved by using our re-ranker to reduce the number of documents shown to the LLM.</li>
<li>MRR (Mean Reciprocal Rank) was likely improved by asking Claude to rank the relevance of each document in order.</li>
</ul>
<p>These improvements demonstrate the effectiveness of incorporating AI-powered reranking in our retrieval process.</p>
<pre class="codehilite"><code class="language-python">from typing import List, Dict

def rerank_results(query: str, results: List[Dict], k: int = 5) -&gt; List[Dict]:
    # Prepare the summaries with their indices
    summaries = []
    print(len(results))

    for i, result in enumerate(results):
        summary = f&quot;[{i}] Document Summary: {result['metadata']['summary']}&quot;
        summaries.append(summary)
    joined_summaries = &quot;\n\n&quot;.join(summaries)

    prompt = f&quot;&quot;&quot;
    Query: {query}
    You are about to be given a group of documents, each preceded by its index number in square brackets. Your task is to select the only {k} most relevant documents from the list to help us answer the query.

    &lt;documents&gt;
    {joined_summaries}
    &lt;/documents&gt;

    Output only the indices of {k} most relevant documents in order of relevance, separated by commas, enclosed in XML tags here:
    &lt;relevant_indices&gt;put the numbers of your indices here, seeparted by commas&lt;/relevant_indices&gt;
    &quot;&quot;&quot;
    try:
        response = client.messages.create(
            model=&quot;claude-3-haiku-20240307&quot;,
            max_tokens=50,
            messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}, {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;&lt;relevant_indices&gt;&quot;}],
            temperature=0,
            stop_sequences=[&quot;&lt;/relevant_indices&gt;&quot;]
        )

        # Extract the indices from the response
        response_text = response.content[0].text.strip()
        indices_str = response_text
        relevant_indices = []
        for idx in indices_str.split(','):
            try:
                relevant_indices.append(int(idx.strip()))
            except ValueError:
                continue  # Skip invalid indices
        print(indices_str)
        print(relevant_indices)
        # If we didn't get enough valid indices, fall back to the top k results by original order
        if len(relevant_indices) == 0:
            relevant_indices = list(range(min(k, len(results))))

        # Ensure we don't have out-of-range indices
        relevant_indices = [idx for idx in relevant_indices if idx &lt; len(results)]

        # Return the reranked results
        reranked_results = [results[idx] for idx in relevant_indices[:k]]
        # Assign descending relevance scores
        for i, result in enumerate(reranked_results):
            result['relevance_score'] = 100 - i  # Highest score is 100, decreasing by 1 for each rank

        return reranked_results

    except Exception as e:
        print(f&quot;An error occurred during reranking: {str(e)}&quot;)
        # Fall back to returning the top k results without reranking
        return results[:k]

def retrieve_advanced(query: str, db: SummaryIndexedVectorDB, k: int = 3, initial_k: int = 20) -&gt; Tuple[List[Dict], str]:
    # Step 1: Get initial results
    initial_results = db.search(query, k=initial_k)

    # Step 2: Re-rank results
    reranked_results = rerank_results(query, initial_results, k=k)

    # Step 3: Generate new context string from re-ranked results
    new_context = &quot;&quot;
    for result in reranked_results:
        chunk = result['metadata']
        new_context += f&quot;\n &lt;document&gt; \n {chunk['chunk_heading']}\n\n{chunk['text']} \n &lt;/document&gt; \n&quot;

    return reranked_results, new_context

# The answer_query_advanced function remains unchanged
def answer_query_advanced(query: str, db: SummaryIndexedVectorDB):
    documents, context = retrieve_advanced(query, db)
    prompt = f&quot;&quot;&quot;
    You have been tasked with helping us to answer the following query: 
    &lt;query&gt;
    {query}
    &lt;/query&gt;
    You have access to the following documents which are meant to provide context as you answer the query:
    &lt;documents&gt;
    {context}
    &lt;/documents&gt;
    Please remain faithful to the underlying context, and only deviate from it if you are 100% sure that you know the answer already. 
    Answer the question now, and avoid providing preamble such as 'Here is the answer', etc
    &quot;&quot;&quot;
    response = client.messages.create(
        model=&quot;claude-3-haiku-20240307&quot;,
        max_tokens=2500,
        messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}],
        temperature=0
    )
    return response.content[0].text
</code></pre>

<h2 id="evaluation">Evaluation</h2>
<pre class="codehilite"><code class="language-python"># Initialize the SummaryIndexedVectorDB
level_three_db = SummaryIndexedVectorDB(&quot;anthropic_docs_v3&quot;)
level_three_db.load_data('data/anthropic_summary_indexed_docs.json')

import pandas as pd

# Run the evaluations
avg_precision, avg_recall, avg_mrr, f1, precisions, recalls, mrrs  = evaluate_retrieval(retrieve_advanced, eval_data, level_three_db)
e2e_accuracy, e2e_results = evaluate_end_to_end(answer_query_advanced, level_two_db, eval_data)

# Create a DataFrame
df = pd.DataFrame({
    'question': [item['question'] for item in eval_data],
    'retrieval_precision': precisions,
    'retrieval_recall': recalls,
    'retrieval_mrr': mrrs,
    'e2e_correct': e2e_results
})

# Save to CSV
df.to_csv('evaluation/csvs/evaluation_results_detailed_level_three.csv', index=False)
print(&quot;Detailed results saved to evaluation_results_detailed_level_three.csv&quot;)

# Plot the results
# Print the results
print(f&quot;Average Precision: {avg_precision:.4f}&quot;)
print(f&quot;Average Recall: {avg_recall:.4f}&quot;)
print(f&quot;Average F1: {f1:.4f}&quot;)
print(f&quot;Average Mean Reciprocal Rank: {avg_mrr:4f}&quot;)
print(f&quot;End-to-End Accuracy: {e2e_accuracy:.4f}&quot;)

# Save the results to a file
with open('evaluation/json_results/evaluation_results_level_three.json', 'w') as f:
    json.dump({
        &quot;name&quot;: &quot;Summary Indexing + Re-Ranking&quot;,
        &quot;average_precision&quot;: avg_precision,
        &quot;average_recall&quot;: avg_recall,
        &quot;average_f1&quot;: f1,
        &quot;average_mrr&quot;: avg_mrr,
        &quot;end_to_end_accuracy&quot;: e2e_accuracy
    }, f, indent=2)

print(&quot;Evaluation complete. Results saved to evaluation_results_level_three.json, evaluation_results_detailed_level_three.csv, and evaluation_results_level_three.png&quot;)
</code></pre>

<pre class="codehilite"><code>Loading vector database from disk.
Evaluating Retrieval:   0%|          | 0/100 [00:00&lt;?, ?it/s]
18
0,2,7
[0, 2, 7]
Evaluating Retrieval:   1%|          | 1/100 [00:00&lt;01:31,  1.09it/s]
15
0,1,2
[0, 1, 2]
Evaluating Retrieval:   2%|▏         | 2/100 [00:01&lt;01:30,  1.09it/s]
20
1,13,15
[1, 13, 15]
Evaluating Retrieval:   3%|▎         | 3/100 [00:02&lt;01:21,  1.19it/s]
20
0,1,6
[0, 1, 6]
Evaluating Retrieval:   4%|▍         | 4/100 [00:03&lt;01:18,  1.22it/s]
9
0,1,2
[0, 1, 2]
Evaluating Retrieval:   5%|▌         | 5/100 [00:04&lt;01:21,  1.17it/s]
11
0,1,2
[0, 1, 2]
Evaluating Retrieval:   6%|▌         | 6/100 [00:05&lt;01:21,  1.16it/s]
20
0,5,11
[0, 5, 11]
Evaluating Retrieval:   7%|▋         | 7/100 [00:06&lt;01:20,  1.16it/s]
9
0,1,7
[0, 1, 7]
Evaluating Retrieval:   8%|▊         | 8/100 [00:06&lt;01:21,  1.13it/s]
20
1,19,10
[1, 19, 10]
Evaluating Retrieval:   9%|▉         | 9/100 [00:07&lt;01:19,  1.15it/s]
10
2,0,1
[2, 0, 1]
Evaluating Retrieval:  10%|█         | 10/100 [00:08&lt;01:18,  1.14it/s]
Processed 10/100 items. Current Avg Precision: 0.5000, Avg Recall: 0.8000, Avg MRR: 1.0000
20
0,4,11
[0, 4, 11]
Evaluating Retrieval:  11%|█         | 11/100 [00:09&lt;01:16,  1.16it/s]
8
0,3,2
[0, 3, 2]
Evaluating Retrieval:  12%|█▏        | 12/100 [00:10&lt;01:20,  1.10it/s]
20
4,3,6
[4, 3, 6]
Evaluating Retrieval:  13%|█▎        | 13/100 [00:11&lt;01:17,  1.12it/s]
20
0,1,6
[0, 1, 6]
Evaluating Retrieval:  14%|█▍        | 14/100 [00:12&lt;01:16,  1.12it/s]
20
0,1,3
[0, 1, 3]
Evaluating Retrieval:  15%|█▌        | 15/100 [00:13&lt;01:15,  1.12it/s]
16
0,1,7
[0, 1, 7]
Evaluating Retrieval:  16%|█▌        | 16/100 [00:13&lt;01:13,  1.15it/s]
10
0,1,2
[0, 1, 2]
Evaluating Retrieval:  17%|█▋        | 17/100 [00:14&lt;01:10,  1.17it/s]
20
5,6,8
[5, 6, 8]
Evaluating Retrieval:  18%|█▊        | 18/100 [00:15&lt;01:06,  1.23it/s]
2
1,5,3
[1, 5, 3]
Evaluating Retrieval:  19%|█▉        | 19/100 [00:16&lt;01:04,  1.26it/s]
20
0,1,3
[0, 1, 3]
Evaluating Retrieval:  20%|██        | 20/100 [00:17&lt;01:10,  1.13it/s]
Processed 20/100 items. Current Avg Precision: 0.4333, Avg Recall: 0.7250, Avg MRR: 0.9667
9
0,5,6
[0, 5, 6]
Evaluating Retrieval:  21%|██        | 21/100 [00:18&lt;01:06,  1.18it/s]
17
1,9,3
[1, 9, 3]
Evaluating Retrieval:  22%|██▏       | 22/100 [00:19&lt;01:09,  1.13it/s]
16
0,1,2
[0, 1, 2]
Evaluating Retrieval:  23%|██▎       | 23/100 [00:20&lt;01:11,  1.08it/s]
20
0,11,14
[0, 11, 14]
Evaluating Retrieval:  24%|██▍       | 24/100 [00:21&lt;01:16,  1.01s/it]
20
0,14,16
[0, 14, 16]
Evaluating Retrieval:  25%|██▌       | 25/100 [00:22&lt;01:12,  1.03it/s]
15
0,1,4
[0, 1, 4]
Evaluating Retrieval:  26%|██▌       | 26/100 [00:22&lt;01:07,  1.10it/s]
6
0,1,3
[0, 1, 3]
Evaluating Retrieval:  27%|██▋       | 27/100 [00:23&lt;01:03,  1.15it/s]
9
2,1,3
[2, 1, 3]
Evaluating Retrieval:  28%|██▊       | 28/100 [00:24&lt;00:59,  1.21it/s]
18
1,2,11
[1, 2, 11]
Evaluating Retrieval:  29%|██▉       | 29/100 [00:25&lt;00:58,  1.22it/s]
20
0, 4, 7
[0, 4, 7]
Evaluating Retrieval:  30%|███       | 30/100 [00:26&lt;00:59,  1.17it/s]
Processed 30/100 items. Current Avg Precision: 0.4556, Avg Recall: 0.7389, Avg MRR: 1.0000
9
0,3,4
[0, 3, 4]
Evaluating Retrieval:  31%|███       | 31/100 [00:26&lt;00:56,  1.23it/s]
9
1,2,0
[1, 2, 0]
Evaluating Retrieval:  32%|███▏      | 32/100 [00:27&lt;00:55,  1.23it/s]
6
1,0,4
[1, 0, 4]
Evaluating Retrieval:  33%|███▎      | 33/100 [00:28&lt;00:54,  1.22it/s]
20
0,1,3
[0, 1, 3]
Evaluating Retrieval:  34%|███▍      | 34/100 [00:29&lt;00:55,  1.20it/s]
20
0,1,7
[0, 1, 7]
Evaluating Retrieval:  35%|███▌      | 35/100 [00:30&lt;00:52,  1.25it/s]
16
0,1,2
[0, 1, 2]
Evaluating Retrieval:  36%|███▌      | 36/100 [00:31&lt;00:52,  1.21it/s]
10
5,6,8
[5, 6, 8]
Evaluating Retrieval:  37%|███▋      | 37/100 [00:31&lt;00:53,  1.18it/s]
20
4,11,3
[4, 11, 3]
Evaluating Retrieval:  38%|███▊      | 38/100 [00:32&lt;00:53,  1.17it/s]
2
1, 0, 0
[1, 0, 0]
Evaluating Retrieval:  39%|███▉      | 39/100 [00:33&lt;00:52,  1.15it/s]
20
2,6,16
[2, 6, 16]
Evaluating Retrieval:  40%|████      | 40/100 [00:34&lt;00:50,  1.18it/s]
Processed 40/100 items. Current Avg Precision: 0.4583, Avg Recall: 0.7167, Avg MRR: 0.9042
20
0,1,5
[0, 1, 5]
Evaluating Retrieval:  41%|████      | 41/100 [00:35&lt;00:49,  1.19it/s]
11
0,8,2
[0, 8, 2]
Evaluating Retrieval:  42%|████▏     | 42/100 [00:36&lt;00:46,  1.24it/s]
12
1,9,6
[1, 9, 6]
Evaluating Retrieval:  43%|████▎     | 43/100 [00:36&lt;00:45,  1.26it/s]
4
0,1,3
[0, 1, 3]
Evaluating Retrieval:  44%|████▍     | 44/100 [00:37&lt;00:44,  1.25it/s]
20
1, 3, 18
[1, 3, 18]
Evaluating Retrieval:  45%|████▌     | 45/100 [00:38&lt;00:43,  1.25it/s]
20
0,4,5
[0, 4, 5]
Evaluating Retrieval:  46%|████▌     | 46/100 [00:39&lt;00:42,  1.26it/s]
7
0,1,5
[0, 1, 5]
Evaluating Retrieval:  47%|████▋     | 47/100 [00:40&lt;00:42,  1.24it/s]
20
1,0,3
[1, 0, 3]
Evaluating Retrieval:  48%|████▊     | 48/100 [00:40&lt;00:43,  1.21it/s]
20
2,1,12
[2, 1, 12]
Evaluating Retrieval:  49%|████▉     | 49/100 [00:41&lt;00:43,  1.18it/s]
4
0,1,2
[0, 1, 2]
Evaluating Retrieval:  50%|█████     | 50/100 [00:42&lt;00:42,  1.18it/s]
Processed 50/100 items. Current Avg Precision: 0.4400, Avg Recall: 0.7033, Avg MRR: 0.8800
8
0,1,3
[0, 1, 3]
Evaluating Retrieval:  51%|█████     | 51/100 [00:43&lt;00:44,  1.10it/s]
4
0,3,1
[0, 3, 1]
Evaluating Retrieval:  52%|█████▏    | 52/100 [00:44&lt;00:40,  1.19it/s]
17
1, 2, 3
[1, 2, 3]
Evaluating Retrieval:  53%|█████▎    | 53/100 [00:45&lt;00:39,  1.18it/s]
20
1, 4, 5
[1, 4, 5]
Evaluating Retrieval:  54%|█████▍    | 54/100 [00:46&lt;00:37,  1.24it/s]
20
0,1,8
[0, 1, 8]
Evaluating Retrieval:  55%|█████▌    | 55/100 [00:46&lt;00:34,  1.29it/s]
20
0,2,6
[0, 2, 6]
Evaluating Retrieval:  56%|█████▌    | 56/100 [00:47&lt;00:34,  1.29it/s]
20
0,14,4
[0, 14, 4]
Evaluating Retrieval:  57%|█████▋    | 57/100 [00:48&lt;00:35,  1.20it/s]
20
0,1,2
[0, 1, 2]
Evaluating Retrieval:  58%|█████▊    | 58/100 [00:49&lt;00:36,  1.16it/s]
7
0,1,3
[0, 1, 3]
Evaluating Retrieval:  59%|█████▉    | 59/100 [00:50&lt;00:34,  1.19it/s]
20
1, 5, 15
[1, 5, 15]
Evaluating Retrieval:  60%|██████    | 60/100 [00:51&lt;00:33,  1.18it/s]
Processed 60/100 items. Current Avg Precision: 0.4444, Avg Recall: 0.7194, Avg MRR: 0.8889
6
2,4,1
[2, 4, 1]
Evaluating Retrieval:  61%|██████    | 61/100 [00:52&lt;00:34,  1.13it/s]
20
0,1,5
[0, 1, 5]
Evaluating Retrieval:  62%|██████▏   | 62/100 [00:53&lt;00:37,  1.01it/s]
5
0,1,3
[0, 1, 3]
Evaluating Retrieval:  63%|██████▎   | 63/100 [00:54&lt;00:40,  1.09s/it]
20
1,4,11
[1, 4, 11]
Evaluating Retrieval:  64%|██████▍   | 64/100 [00:55&lt;00:35,  1.02it/s]
7
2,3,4
[2, 3, 4]
Evaluating Retrieval:  65%|██████▌   | 65/100 [00:56&lt;00:33,  1.04it/s]
20
2,15,12
[2, 15, 12]
Evaluating Retrieval:  66%|██████▌   | 66/100 [00:57&lt;00:31,  1.09it/s]
16
1,3,4
[1, 3, 4]
Evaluating Retrieval:  67%|██████▋   | 67/100 [00:57&lt;00:29,  1.12it/s]
5
0, 2, 3
[0, 2, 3]
Evaluating Retrieval:  68%|██████▊   | 68/100 [00:58&lt;00:28,  1.14it/s]
20
2,3,5
[2, 3, 5]
Evaluating Retrieval:  69%|██████▉   | 69/100 [00:59&lt;00:26,  1.16it/s]
20
0,1,14
[0, 1, 14]
Evaluating Retrieval:  70%|███████   | 70/100 [01:00&lt;00:26,  1.12it/s]
Processed 70/100 items. Current Avg Precision: 0.4333, Avg Recall: 0.7024, Avg MRR: 0.8667
6
1,0,2
[1, 0, 2]
Evaluating Retrieval:  71%|███████   | 71/100 [01:01&lt;00:24,  1.16it/s]
6
0,1,2
[0, 1, 2]
Evaluating Retrieval:  72%|███████▏  | 72/100 [01:01&lt;00:22,  1.24it/s]
17
0,3,8
[0, 3, 8]
Evaluating Retrieval:  73%|███████▎  | 73/100 [01:02&lt;00:22,  1.20it/s]
20
3,1,16
[3, 1, 16]
Evaluating Retrieval:  74%|███████▍  | 74/100 [01:04&lt;00:27,  1.04s/it]
20
0, 3, 4
[0, 3, 4]
Evaluating Retrieval:  75%|███████▌  | 75/100 [01:05&lt;00:24,  1.03it/s]
20
3,0,2
[3, 0, 2]
Evaluating Retrieval:  76%|███████▌  | 76/100 [01:06&lt;00:22,  1.07it/s]
20
0,1,16
[0, 1, 16]
Evaluating Retrieval:  77%|███████▋  | 77/100 [01:06&lt;00:20,  1.10it/s]
20
0,4,13
[0, 4, 13]
Evaluating Retrieval:  78%|███████▊  | 78/100 [01:07&lt;00:19,  1.15it/s]
1
10,19,1
[10, 19, 1]
Evaluating Retrieval:  79%|███████▉  | 79/100 [01:08&lt;00:17,  1.22it/s]
20
0,1,10
[0, 1, 10]
Evaluating Retrieval:  80%|████████  | 80/100 [01:11&lt;00:28,  1.44s/it]
Processed 80/100 items. Current Avg Precision: 0.4375, Avg Recall
</code></pre>
            </article>
            
            <nav class="page-nav"><a href="skills/summarization/guide_zh.html" class="nav-link prev">← 摘要与 Claude</a><a href="skills/text_to_sql/guide_zh.html" class="nav-link next">Set your Anthropic API key →</a></nav>
        </main>
    </div>
</body>
</html>